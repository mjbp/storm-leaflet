(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var _typeof3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof2 = typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol" ? function (obj) {
	return typeof obj === "undefined" ? "undefined" : _typeof3(obj);
} : function (obj) {
	return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof3(obj);
};

/**
 * @name storm-map: 
 * @version 0.1.0: Thu, 26 Jul 2018 12:39:58 GMT
 * @author stormid
 * @license MIT
 */
(function (root, factory) {
	var mod = {
		exports: {}
	};
	if (typeof exports !== 'undefined') {
		mod.exports = exports;
		factory(mod.exports);
		module.exports = mod.exports.default;
	} else {
		factory(mod.exports);
		root.gulpWrapUmd = mod.exports.default;
	}
})(undefined, function (exports) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
		return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
	} : function (obj) {
		return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
	};

	var defaults = {
		callback: null
	};

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var leafletSrc = createCommonjsModule(function (module, exports) {
		/* @preserve
   * Leaflet 1.3.3, a JS library for interactive maps. http://leafletjs.com
   * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   */

		(function (global, factory) {
			factory(exports);
		})(commonjsGlobal, function (exports) {
			var version = "1.3.3";

			/*
    * @namespace Util
    *
    * Various utility functions, used by Leaflet internally.
    */

			var freeze = Object.freeze;
			Object.freeze = function (obj) {
				return obj;
			};

			// @function extend(dest: Object, src?: Object): Object
			// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
			function extend(dest) {
				var i, j, len, src;

				for (j = 1, len = arguments.length; j < len; j++) {
					src = arguments[j];
					for (i in src) {
						dest[i] = src[i];
					}
				}
				return dest;
			}

			// @function create(proto: Object, properties?: Object): Object
			// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
			var create = Object.create || function () {
				function F() {}
				return function (proto) {
					F.prototype = proto;
					return new F();
				};
			}();

			// @function bind(fn: Function, …): Function
			// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
			// Has a `L.bind()` shortcut.
			function bind(fn, obj) {
				var slice = Array.prototype.slice;

				if (fn.bind) {
					return fn.bind.apply(fn, slice.call(arguments, 1));
				}

				var args = slice.call(arguments, 2);

				return function () {
					return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
				};
			}

			// @property lastId: Number
			// Last unique ID used by [`stamp()`](#util-stamp)
			var lastId = 0;

			// @function stamp(obj: Object): Number
			// Returns the unique ID of an object, assigning it one if it doesn't have it.
			function stamp(obj) {
				/*eslint-disable */
				obj._leaflet_id = obj._leaflet_id || ++lastId;
				return obj._leaflet_id;
				/* eslint-enable */
			}

			// @function throttle(fn: Function, time: Number, context: Object): Function
			// Returns a function which executes function `fn` with the given scope `context`
			// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
			// `fn` will be called no more than one time per given amount of `time`. The arguments
			// received by the bound function will be any arguments passed when binding the
			// function, followed by any arguments passed when invoking the bound function.
			// Has an `L.throttle` shortcut.
			function throttle(fn, time, context) {
				var lock, args, wrapperFn, later;

				later = function later() {
					// reset lock and call if queued
					lock = false;
					if (args) {
						wrapperFn.apply(context, args);
						args = false;
					}
				};

				wrapperFn = function wrapperFn() {
					if (lock) {
						// called too soon, queue to call later
						args = arguments;
					} else {
						// call and lock until later
						fn.apply(context, arguments);
						setTimeout(later, time);
						lock = true;
					}
				};

				return wrapperFn;
			}

			// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
			// Returns the number `num` modulo `range` in such a way so it lies within
			// `range[0]` and `range[1]`. The returned value will be always smaller than
			// `range[1]` unless `includeMax` is set to `true`.
			function wrapNum(x, range, includeMax) {
				var max = range[1],
				    min = range[0],
				    d = max - min;
				return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
			}

			// @function falseFn(): Function
			// Returns a function which always returns `false`.
			function falseFn() {
				return false;
			}

			// @function formatNum(num: Number, digits?: Number): Number
			// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
			function formatNum(num, digits) {
				var pow = Math.pow(10, digits === undefined ? 6 : digits);
				return Math.round(num * pow) / pow;
			}

			// @function trim(str: String): String
			// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
			function trim(str) {
				return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
			}

			// @function splitWords(str: String): String[]
			// Trims and splits the string on whitespace and returns the array of parts.
			function splitWords(str) {
				return trim(str).split(/\s+/);
			}

			// @function setOptions(obj: Object, options: Object): Object
			// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
			function setOptions(obj, options) {
				if (!obj.hasOwnProperty('options')) {
					obj.options = obj.options ? create(obj.options) : {};
				}
				for (var i in options) {
					obj.options[i] = options[i];
				}
				return obj.options;
			}

			// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
			// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
			// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
			// be appended at the end. If `uppercase` is `true`, the parameter names will
			// be uppercased (e.g. `'?A=foo&B=bar'`)
			function getParamString(obj, existingUrl, uppercase) {
				var params = [];
				for (var i in obj) {
					params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
				}
				return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
			}

			var templateRe = /\{ *([\w_-]+) *\}/g;

			// @function template(str: String, data: Object): String
			// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
			// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
			// `('Hello foo, bar')`. You can also specify functions instead of strings for
			// data values — they will be evaluated passing `data` as an argument.
			function template(str, data) {
				return str.replace(templateRe, function (str, key) {
					var value = data[key];

					if (value === undefined) {
						throw new Error('No value provided for variable ' + str);
					} else if (typeof value === 'function') {
						value = value(data);
					}
					return value;
				});
			}

			// @function isArray(obj): Boolean
			// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
			var isArray = Array.isArray || function (obj) {
				return Object.prototype.toString.call(obj) === '[object Array]';
			};

			// @function indexOf(array: Array, el: Object): Number
			// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
			function indexOf(array, el) {
				for (var i = 0; i < array.length; i++) {
					if (array[i] === el) {
						return i;
					}
				}
				return -1;
			}

			// @property emptyImageUrl: String
			// Data URI string containing a base64-encoded empty GIF image.
			// Used as a hack to free memory from unused images on WebKit-powered
			// mobile devices (by setting image `src` to this string).
			var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

			// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

			function getPrefixed(name) {
				return window['webkit' + name] || window['moz' + name] || window['ms' + name];
			}

			var lastTime = 0;

			// fallback for IE 7-8
			function timeoutDefer(fn) {
				var time = +new Date(),
				    timeToCall = Math.max(0, 16 - (time - lastTime));

				lastTime = time + timeToCall;
				return window.setTimeout(fn, timeToCall);
			}

			var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
			var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
				window.clearTimeout(id);
			};

			// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
			// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
			// `context` if given. When `immediate` is set, `fn` is called immediately if
			// the browser doesn't have native support for
			// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
			// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
			function requestAnimFrame(fn, context, immediate) {
				if (immediate && requestFn === timeoutDefer) {
					fn.call(context);
				} else {
					return requestFn.call(window, bind(fn, context));
				}
			}

			// @function cancelAnimFrame(id: Number): undefined
			// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
			function cancelAnimFrame(id) {
				if (id) {
					cancelFn.call(window, id);
				}
			}

			var Util = (Object.freeze || Object)({
				freeze: freeze,
				extend: extend,
				create: create,
				bind: bind,
				lastId: lastId,
				stamp: stamp,
				throttle: throttle,
				wrapNum: wrapNum,
				falseFn: falseFn,
				formatNum: formatNum,
				trim: trim,
				splitWords: splitWords,
				setOptions: setOptions,
				getParamString: getParamString,
				template: template,
				isArray: isArray,
				indexOf: indexOf,
				emptyImageUrl: emptyImageUrl,
				requestFn: requestFn,
				cancelFn: cancelFn,
				requestAnimFrame: requestAnimFrame,
				cancelAnimFrame: cancelAnimFrame
			});

			// @class Class
			// @aka L.Class

			// @section
			// @uninheritable

			// Thanks to John Resig and Dean Edwards for inspiration!

			function Class() {}

			Class.extend = function (props) {

				// @function extend(props: Object): Function
				// [Extends the current class](#class-inheritance) given the properties to be included.
				// Returns a Javascript function that is a class constructor (to be called with `new`).
				var NewClass = function NewClass() {

					// call the constructor
					if (this.initialize) {
						this.initialize.apply(this, arguments);
					}

					// call all constructor hooks
					this.callInitHooks();
				};

				var parentProto = NewClass.__super__ = this.prototype;

				var proto = create(parentProto);
				proto.constructor = NewClass;

				NewClass.prototype = proto;

				// inherit parent's statics
				for (var i in this) {
					if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
						NewClass[i] = this[i];
					}
				}

				// mix static properties into the class
				if (props.statics) {
					extend(NewClass, props.statics);
					delete props.statics;
				}

				// mix includes into the prototype
				if (props.includes) {
					checkDeprecatedMixinEvents(props.includes);
					extend.apply(null, [proto].concat(props.includes));
					delete props.includes;
				}

				// merge options
				if (proto.options) {
					props.options = extend(create(proto.options), props.options);
				}

				// mix given properties into the prototype
				extend(proto, props);

				proto._initHooks = [];

				// add method for calling all hooks
				proto.callInitHooks = function () {

					if (this._initHooksCalled) {
						return;
					}

					if (parentProto.callInitHooks) {
						parentProto.callInitHooks.call(this);
					}

					this._initHooksCalled = true;

					for (var i = 0, len = proto._initHooks.length; i < len; i++) {
						proto._initHooks[i].call(this);
					}
				};

				return NewClass;
			};

			// @function include(properties: Object): this
			// [Includes a mixin](#class-includes) into the current class.
			Class.include = function (props) {
				extend(this.prototype, props);
				return this;
			};

			// @function mergeOptions(options: Object): this
			// [Merges `options`](#class-options) into the defaults of the class.
			Class.mergeOptions = function (options) {
				extend(this.prototype.options, options);
				return this;
			};

			// @function addInitHook(fn: Function): this
			// Adds a [constructor hook](#class-constructor-hooks) to the class.
			Class.addInitHook = function (fn) {
				// (Function) || (String, args...)
				var args = Array.prototype.slice.call(arguments, 1);

				var init = typeof fn === 'function' ? fn : function () {
					this[fn].apply(this, args);
				};

				this.prototype._initHooks = this.prototype._initHooks || [];
				this.prototype._initHooks.push(init);
				return this;
			};

			function checkDeprecatedMixinEvents(includes) {
				if (typeof L === 'undefined' || !L || !L.Mixin) {
					return;
				}

				includes = isArray(includes) ? includes : [includes];

				for (var i = 0; i < includes.length; i++) {
					if (includes[i] === L.Mixin.Events) {
						console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
					}
				}
			}

			/*
    * @class Evented
    * @aka L.Evented
    * @inherits Class
    *
    * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
    *
    * @example
    *
    * ```js
    * map.on('click', function(e) {
    * 	alert(e.latlng);
    * } );
    * ```
    *
    * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
    *
    * ```js
    * function onClick(e) { ... }
    *
    * map.on('click', onClick);
    * map.off('click', onClick);
    * ```
    */

			var Events = {
				/* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
				on: function on(types, fn, context) {

					// types can be a map of types/handlers
					if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
						for (var type in types) {
							// we don't process space-separated events here for performance;
							// it's a hot path since Layer uses the on(obj) syntax
							this._on(type, types[type], fn);
						}
					} else {
						// types can be a string of space-separated words
						types = splitWords(types);

						for (var i = 0, len = types.length; i < len; i++) {
							this._on(types[i], fn, context);
						}
					}

					return this;
				},

				/* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object.
     */
				off: function off(types, fn, context) {

					if (!types) {
						// clear all listeners if called without arguments
						delete this._events;
					} else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
						for (var type in types) {
							this._off(type, types[type], fn);
						}
					} else {
						types = splitWords(types);

						for (var i = 0, len = types.length; i < len; i++) {
							this._off(types[i], fn, context);
						}
					}

					return this;
				},

				// attach listener (without syntactic sugar now)
				_on: function _on(type, fn, context) {
					this._events = this._events || {};

					/* get/init listeners for type */
					var typeListeners = this._events[type];
					if (!typeListeners) {
						typeListeners = [];
						this._events[type] = typeListeners;
					}

					if (context === this) {
						// Less memory footprint.
						context = undefined;
					}
					var newListener = { fn: fn, ctx: context },
					    listeners = typeListeners;

					// check if fn already there
					for (var i = 0, len = listeners.length; i < len; i++) {
						if (listeners[i].fn === fn && listeners[i].ctx === context) {
							return;
						}
					}

					listeners.push(newListener);
				},

				_off: function _off(type, fn, context) {
					var listeners, i, len;

					if (!this._events) {
						return;
					}

					listeners = this._events[type];

					if (!listeners) {
						return;
					}

					if (!fn) {
						// Set all removed listeners to noop so they are not called if remove happens in fire
						for (i = 0, len = listeners.length; i < len; i++) {
							listeners[i].fn = falseFn;
						}
						// clear all listeners for a type if function isn't specified
						delete this._events[type];
						return;
					}

					if (context === this) {
						context = undefined;
					}

					if (listeners) {

						// find fn and remove it
						for (i = 0, len = listeners.length; i < len; i++) {
							var l = listeners[i];
							if (l.ctx !== context) {
								continue;
							}
							if (l.fn === fn) {

								// set the removed listener to noop so that's not called if remove happens in fire
								l.fn = falseFn;

								if (this._firingCount) {
									/* copy array in case events are being fired */
									this._events[type] = listeners = listeners.slice();
								}
								listeners.splice(i, 1);

								return;
							}
						}
					}
				},

				// @method fire(type: String, data?: Object, propagate?: Boolean): this
				// Fires an event of the specified type. You can optionally provide an data
				// object — the first argument of the listener function will contain its
				// properties. The event can optionally be propagated to event parents.
				fire: function fire(type, data, propagate) {
					if (!this.listens(type, propagate)) {
						return this;
					}

					var event = extend({}, data, {
						type: type,
						target: this,
						sourceTarget: data && data.sourceTarget || this
					});

					if (this._events) {
						var listeners = this._events[type];

						if (listeners) {
							this._firingCount = this._firingCount + 1 || 1;
							for (var i = 0, len = listeners.length; i < len; i++) {
								var l = listeners[i];
								l.fn.call(l.ctx || this, event);
							}

							this._firingCount--;
						}
					}

					if (propagate) {
						// propagate the event to parents (set with addEventParent)
						this._propagateEvent(event);
					}

					return this;
				},

				// @method listens(type: String): Boolean
				// Returns `true` if a particular event type has any listeners attached to it.
				listens: function listens(type, propagate) {
					var listeners = this._events && this._events[type];
					if (listeners && listeners.length) {
						return true;
					}

					if (propagate) {
						// also check parents for listeners if event propagates
						for (var id in this._eventParents) {
							if (this._eventParents[id].listens(type, propagate)) {
								return true;
							}
						}
					}
					return false;
				},

				// @method once(…): this
				// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
				once: function once(types, fn, context) {

					if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
						for (var type in types) {
							this.once(type, types[type], fn);
						}
						return this;
					}

					var handler = bind(function () {
						this.off(types, fn, context).off(types, handler, context);
					}, this);

					// add a listener that's executed once and removed after that
					return this.on(types, fn, context).on(types, handler, context);
				},

				// @method addEventParent(obj: Evented): this
				// Adds an event parent - an `Evented` that will receive propagated events
				addEventParent: function addEventParent(obj) {
					this._eventParents = this._eventParents || {};
					this._eventParents[stamp(obj)] = obj;
					return this;
				},

				// @method removeEventParent(obj: Evented): this
				// Removes an event parent, so it will stop receiving propagated events
				removeEventParent: function removeEventParent(obj) {
					if (this._eventParents) {
						delete this._eventParents[stamp(obj)];
					}
					return this;
				},

				_propagateEvent: function _propagateEvent(e) {
					for (var id in this._eventParents) {
						this._eventParents[id].fire(e.type, extend({
							layer: e.target,
							propagatedFrom: e.target
						}, e), true);
					}
				}
			};

			// aliases; we should ditch those eventually

			// @method addEventListener(…): this
			// Alias to [`on(…)`](#evented-on)
			Events.addEventListener = Events.on;

			// @method removeEventListener(…): this
			// Alias to [`off(…)`](#evented-off)

			// @method clearAllEventListeners(…): this
			// Alias to [`off()`](#evented-off)
			Events.removeEventListener = Events.clearAllEventListeners = Events.off;

			// @method addOneTimeEventListener(…): this
			// Alias to [`once(…)`](#evented-once)
			Events.addOneTimeEventListener = Events.once;

			// @method fireEvent(…): this
			// Alias to [`fire(…)`](#evented-fire)
			Events.fireEvent = Events.fire;

			// @method hasEventListeners(…): Boolean
			// Alias to [`listens(…)`](#evented-listens)
			Events.hasEventListeners = Events.listens;

			var Evented = Class.extend(Events);

			/*
    * @class Point
    * @aka L.Point
    *
    * Represents a point with `x` and `y` coordinates in pixels.
    *
    * @example
    *
    * ```js
    * var point = L.point(200, 300);
    * ```
    *
    * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
    *
    * ```js
    * map.panBy([200, 300]);
    * map.panBy(L.point(200, 300));
    * ```
    *
    * Note that `Point` does not inherit from Leafet's `Class` object,
    * which means new classes can't inherit from it, and new methods
    * can't be added to it with the `include` function.
    */

			function Point(x, y, round) {
				// @property x: Number; The `x` coordinate of the point
				this.x = round ? Math.round(x) : x;
				// @property y: Number; The `y` coordinate of the point
				this.y = round ? Math.round(y) : y;
			}

			var trunc = Math.trunc || function (v) {
				return v > 0 ? Math.floor(v) : Math.ceil(v);
			};

			Point.prototype = {

				// @method clone(): Point
				// Returns a copy of the current point.
				clone: function clone() {
					return new Point(this.x, this.y);
				},

				// @method add(otherPoint: Point): Point
				// Returns the result of addition of the current and the given points.
				add: function add(point) {
					// non-destructive, returns a new point
					return this.clone()._add(toPoint(point));
				},

				_add: function _add(point) {
					// destructive, used directly for performance in situations where it's safe to modify existing point
					this.x += point.x;
					this.y += point.y;
					return this;
				},

				// @method subtract(otherPoint: Point): Point
				// Returns the result of subtraction of the given point from the current.
				subtract: function subtract(point) {
					return this.clone()._subtract(toPoint(point));
				},

				_subtract: function _subtract(point) {
					this.x -= point.x;
					this.y -= point.y;
					return this;
				},

				// @method divideBy(num: Number): Point
				// Returns the result of division of the current point by the given number.
				divideBy: function divideBy(num) {
					return this.clone()._divideBy(num);
				},

				_divideBy: function _divideBy(num) {
					this.x /= num;
					this.y /= num;
					return this;
				},

				// @method multiplyBy(num: Number): Point
				// Returns the result of multiplication of the current point by the given number.
				multiplyBy: function multiplyBy(num) {
					return this.clone()._multiplyBy(num);
				},

				_multiplyBy: function _multiplyBy(num) {
					this.x *= num;
					this.y *= num;
					return this;
				},

				// @method scaleBy(scale: Point): Point
				// Multiply each coordinate of the current point by each coordinate of
				// `scale`. In linear algebra terms, multiply the point by the
				// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
				// defined by `scale`.
				scaleBy: function scaleBy(point) {
					return new Point(this.x * point.x, this.y * point.y);
				},

				// @method unscaleBy(scale: Point): Point
				// Inverse of `scaleBy`. Divide each coordinate of the current point by
				// each coordinate of `scale`.
				unscaleBy: function unscaleBy(point) {
					return new Point(this.x / point.x, this.y / point.y);
				},

				// @method round(): Point
				// Returns a copy of the current point with rounded coordinates.
				round: function round() {
					return this.clone()._round();
				},

				_round: function _round() {
					this.x = Math.round(this.x);
					this.y = Math.round(this.y);
					return this;
				},

				// @method floor(): Point
				// Returns a copy of the current point with floored coordinates (rounded down).
				floor: function floor() {
					return this.clone()._floor();
				},

				_floor: function _floor() {
					this.x = Math.floor(this.x);
					this.y = Math.floor(this.y);
					return this;
				},

				// @method ceil(): Point
				// Returns a copy of the current point with ceiled coordinates (rounded up).
				ceil: function ceil() {
					return this.clone()._ceil();
				},

				_ceil: function _ceil() {
					this.x = Math.ceil(this.x);
					this.y = Math.ceil(this.y);
					return this;
				},

				// @method trunc(): Point
				// Returns a copy of the current point with truncated coordinates (rounded towards zero).
				trunc: function trunc() {
					return this.clone()._trunc();
				},

				_trunc: function _trunc() {
					this.x = trunc(this.x);
					this.y = trunc(this.y);
					return this;
				},

				// @method distanceTo(otherPoint: Point): Number
				// Returns the cartesian distance between the current and the given points.
				distanceTo: function distanceTo(point) {
					point = toPoint(point);

					var x = point.x - this.x,
					    y = point.y - this.y;

					return Math.sqrt(x * x + y * y);
				},

				// @method equals(otherPoint: Point): Boolean
				// Returns `true` if the given point has the same coordinates.
				equals: function equals(point) {
					point = toPoint(point);

					return point.x === this.x && point.y === this.y;
				},

				// @method contains(otherPoint: Point): Boolean
				// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
				contains: function contains(point) {
					point = toPoint(point);

					return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
				},

				// @method toString(): String
				// Returns a string representation of the point for debugging purposes.
				toString: function toString() {
					return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
				}
			};

			// @factory L.point(x: Number, y: Number, round?: Boolean)
			// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

			// @alternative
			// @factory L.point(coords: Number[])
			// Expects an array of the form `[x, y]` instead.

			// @alternative
			// @factory L.point(coords: Object)
			// Expects a plain object of the form `{x: Number, y: Number}` instead.
			function toPoint(x, y, round) {
				if (x instanceof Point) {
					return x;
				}
				if (isArray(x)) {
					return new Point(x[0], x[1]);
				}
				if (x === undefined || x === null) {
					return x;
				}
				if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && 'x' in x && 'y' in x) {
					return new Point(x.x, x.y);
				}
				return new Point(x, y, round);
			}

			/*
    * @class Bounds
    * @aka L.Bounds
    *
    * Represents a rectangular area in pixel coordinates.
    *
    * @example
    *
    * ```js
    * var p1 = L.point(10, 10),
    * p2 = L.point(40, 60),
    * bounds = L.bounds(p1, p2);
    * ```
    *
    * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
    *
    * ```js
    * otherBounds.intersects([[10, 10], [40, 60]]);
    * ```
    *
    * Note that `Bounds` does not inherit from Leafet's `Class` object,
    * which means new classes can't inherit from it, and new methods
    * can't be added to it with the `include` function.
    */

			function Bounds(a, b) {
				if (!a) {
					return;
				}

				var points = b ? [a, b] : a;

				for (var i = 0, len = points.length; i < len; i++) {
					this.extend(points[i]);
				}
			}

			Bounds.prototype = {
				// @method extend(point: Point): this
				// Extends the bounds to contain the given point.
				extend: function extend(point) {
					// (Point)
					point = toPoint(point);

					// @property min: Point
					// The top left corner of the rectangle.
					// @property max: Point
					// The bottom right corner of the rectangle.
					if (!this.min && !this.max) {
						this.min = point.clone();
						this.max = point.clone();
					} else {
						this.min.x = Math.min(point.x, this.min.x);
						this.max.x = Math.max(point.x, this.max.x);
						this.min.y = Math.min(point.y, this.min.y);
						this.max.y = Math.max(point.y, this.max.y);
					}
					return this;
				},

				// @method getCenter(round?: Boolean): Point
				// Returns the center point of the bounds.
				getCenter: function getCenter(round) {
					return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
				},

				// @method getBottomLeft(): Point
				// Returns the bottom-left point of the bounds.
				getBottomLeft: function getBottomLeft() {
					return new Point(this.min.x, this.max.y);
				},

				// @method getTopRight(): Point
				// Returns the top-right point of the bounds.
				getTopRight: function getTopRight() {
					// -> Point
					return new Point(this.max.x, this.min.y);
				},

				// @method getTopLeft(): Point
				// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
				getTopLeft: function getTopLeft() {
					return this.min; // left, top
				},

				// @method getBottomRight(): Point
				// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
				getBottomRight: function getBottomRight() {
					return this.max; // right, bottom
				},

				// @method getSize(): Point
				// Returns the size of the given bounds
				getSize: function getSize() {
					return this.max.subtract(this.min);
				},

				// @method contains(otherBounds: Bounds): Boolean
				// Returns `true` if the rectangle contains the given one.
				// @alternative
				// @method contains(point: Point): Boolean
				// Returns `true` if the rectangle contains the given point.
				contains: function contains(obj) {
					var min, max;

					if (typeof obj[0] === 'number' || obj instanceof Point) {
						obj = toPoint(obj);
					} else {
						obj = toBounds(obj);
					}

					if (obj instanceof Bounds) {
						min = obj.min;
						max = obj.max;
					} else {
						min = max = obj;
					}

					return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
				},

				// @method intersects(otherBounds: Bounds): Boolean
				// Returns `true` if the rectangle intersects the given bounds. Two bounds
				// intersect if they have at least one point in common.
				intersects: function intersects(bounds) {
					// (Bounds) -> Boolean
					bounds = toBounds(bounds);

					var min = this.min,
					    max = this.max,
					    min2 = bounds.min,
					    max2 = bounds.max,
					    xIntersects = max2.x >= min.x && min2.x <= max.x,
					    yIntersects = max2.y >= min.y && min2.y <= max.y;

					return xIntersects && yIntersects;
				},

				// @method overlaps(otherBounds: Bounds): Boolean
				// Returns `true` if the rectangle overlaps the given bounds. Two bounds
				// overlap if their intersection is an area.
				overlaps: function overlaps(bounds) {
					// (Bounds) -> Boolean
					bounds = toBounds(bounds);

					var min = this.min,
					    max = this.max,
					    min2 = bounds.min,
					    max2 = bounds.max,
					    xOverlaps = max2.x > min.x && min2.x < max.x,
					    yOverlaps = max2.y > min.y && min2.y < max.y;

					return xOverlaps && yOverlaps;
				},

				isValid: function isValid() {
					return !!(this.min && this.max);
				}
			};

			// @factory L.bounds(corner1: Point, corner2: Point)
			// Creates a Bounds object from two corners coordinate pairs.
			// @alternative
			// @factory L.bounds(points: Point[])
			// Creates a Bounds object from the given array of points.
			function toBounds(a, b) {
				if (!a || a instanceof Bounds) {
					return a;
				}
				return new Bounds(a, b);
			}

			/*
    * @class LatLngBounds
    * @aka L.LatLngBounds
    *
    * Represents a rectangular geographical area on a map.
    *
    * @example
    *
    * ```js
    * var corner1 = L.latLng(40.712, -74.227),
    * corner2 = L.latLng(40.774, -74.125),
    * bounds = L.latLngBounds(corner1, corner2);
    * ```
    *
    * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
    *
    * ```js
    * map.fitBounds([
    * 	[40.712, -74.227],
    * 	[40.774, -74.125]
    * ]);
    * ```
    *
    * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
    *
    * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
    * which means new classes can't inherit from it, and new methods
    * can't be added to it with the `include` function.
    */

			function LatLngBounds(corner1, corner2) {
				// (LatLng, LatLng) or (LatLng[])
				if (!corner1) {
					return;
				}

				var latlngs = corner2 ? [corner1, corner2] : corner1;

				for (var i = 0, len = latlngs.length; i < len; i++) {
					this.extend(latlngs[i]);
				}
			}

			LatLngBounds.prototype = {

				// @method extend(latlng: LatLng): this
				// Extend the bounds to contain the given point

				// @alternative
				// @method extend(otherBounds: LatLngBounds): this
				// Extend the bounds to contain the given bounds
				extend: function extend(obj) {
					var sw = this._southWest,
					    ne = this._northEast,
					    sw2,
					    ne2;

					if (obj instanceof LatLng) {
						sw2 = obj;
						ne2 = obj;
					} else if (obj instanceof LatLngBounds) {
						sw2 = obj._southWest;
						ne2 = obj._northEast;

						if (!sw2 || !ne2) {
							return this;
						}
					} else {
						return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
					}

					if (!sw && !ne) {
						this._southWest = new LatLng(sw2.lat, sw2.lng);
						this._northEast = new LatLng(ne2.lat, ne2.lng);
					} else {
						sw.lat = Math.min(sw2.lat, sw.lat);
						sw.lng = Math.min(sw2.lng, sw.lng);
						ne.lat = Math.max(ne2.lat, ne.lat);
						ne.lng = Math.max(ne2.lng, ne.lng);
					}

					return this;
				},

				// @method pad(bufferRatio: Number): LatLngBounds
				// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
				// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
				// Negative values will retract the bounds.
				pad: function pad(bufferRatio) {
					var sw = this._southWest,
					    ne = this._northEast,
					    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
					    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

					return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
				},

				// @method getCenter(): LatLng
				// Returns the center point of the bounds.
				getCenter: function getCenter() {
					return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
				},

				// @method getSouthWest(): LatLng
				// Returns the south-west point of the bounds.
				getSouthWest: function getSouthWest() {
					return this._southWest;
				},

				// @method getNorthEast(): LatLng
				// Returns the north-east point of the bounds.
				getNorthEast: function getNorthEast() {
					return this._northEast;
				},

				// @method getNorthWest(): LatLng
				// Returns the north-west point of the bounds.
				getNorthWest: function getNorthWest() {
					return new LatLng(this.getNorth(), this.getWest());
				},

				// @method getSouthEast(): LatLng
				// Returns the south-east point of the bounds.
				getSouthEast: function getSouthEast() {
					return new LatLng(this.getSouth(), this.getEast());
				},

				// @method getWest(): Number
				// Returns the west longitude of the bounds
				getWest: function getWest() {
					return this._southWest.lng;
				},

				// @method getSouth(): Number
				// Returns the south latitude of the bounds
				getSouth: function getSouth() {
					return this._southWest.lat;
				},

				// @method getEast(): Number
				// Returns the east longitude of the bounds
				getEast: function getEast() {
					return this._northEast.lng;
				},

				// @method getNorth(): Number
				// Returns the north latitude of the bounds
				getNorth: function getNorth() {
					return this._northEast.lat;
				},

				// @method contains(otherBounds: LatLngBounds): Boolean
				// Returns `true` if the rectangle contains the given one.

				// @alternative
				// @method contains (latlng: LatLng): Boolean
				// Returns `true` if the rectangle contains the given point.
				contains: function contains(obj) {
					// (LatLngBounds) or (LatLng) -> Boolean
					if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
						obj = toLatLng(obj);
					} else {
						obj = toLatLngBounds(obj);
					}

					var sw = this._southWest,
					    ne = this._northEast,
					    sw2,
					    ne2;

					if (obj instanceof LatLngBounds) {
						sw2 = obj.getSouthWest();
						ne2 = obj.getNorthEast();
					} else {
						sw2 = ne2 = obj;
					}

					return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
				},

				// @method intersects(otherBounds: LatLngBounds): Boolean
				// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
				intersects: function intersects(bounds) {
					bounds = toLatLngBounds(bounds);

					var sw = this._southWest,
					    ne = this._northEast,
					    sw2 = bounds.getSouthWest(),
					    ne2 = bounds.getNorthEast(),
					    latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
					    lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

					return latIntersects && lngIntersects;
				},

				// @method overlaps(otherBounds: Bounds): Boolean
				// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
				overlaps: function overlaps(bounds) {
					bounds = toLatLngBounds(bounds);

					var sw = this._southWest,
					    ne = this._northEast,
					    sw2 = bounds.getSouthWest(),
					    ne2 = bounds.getNorthEast(),
					    latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
					    lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

					return latOverlaps && lngOverlaps;
				},

				// @method toBBoxString(): String
				// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
				toBBoxString: function toBBoxString() {
					return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
				},

				// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
				// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
				equals: function equals(bounds, maxMargin) {
					if (!bounds) {
						return false;
					}

					bounds = toLatLngBounds(bounds);

					return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
				},

				// @method isValid(): Boolean
				// Returns `true` if the bounds are properly initialized.
				isValid: function isValid() {
					return !!(this._southWest && this._northEast);
				}
			};

			// TODO International date line?

			// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
			// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

			// @alternative
			// @factory L.latLngBounds(latlngs: LatLng[])
			// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
			function toLatLngBounds(a, b) {
				if (a instanceof LatLngBounds) {
					return a;
				}
				return new LatLngBounds(a, b);
			}

			/* @class LatLng
    * @aka L.LatLng
    *
    * Represents a geographical point with a certain latitude and longitude.
    *
    * @example
    *
    * ```
    * var latlng = L.latLng(50.5, 30.5);
    * ```
    *
    * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
    *
    * ```
    * map.panTo([50, 30]);
    * map.panTo({lon: 30, lat: 50});
    * map.panTo({lat: 50, lng: 30});
    * map.panTo(L.latLng(50, 30));
    * ```
    *
    * Note that `LatLng` does not inherit from Leaflet's `Class` object,
    * which means new classes can't inherit from it, and new methods
    * can't be added to it with the `include` function.
    */

			function LatLng(lat, lng, alt) {
				if (isNaN(lat) || isNaN(lng)) {
					throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
				}

				// @property lat: Number
				// Latitude in degrees
				this.lat = +lat;

				// @property lng: Number
				// Longitude in degrees
				this.lng = +lng;

				// @property alt: Number
				// Altitude in meters (optional)
				if (alt !== undefined) {
					this.alt = +alt;
				}
			}

			LatLng.prototype = {
				// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
				// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
				equals: function equals(obj, maxMargin) {
					if (!obj) {
						return false;
					}

					obj = toLatLng(obj);

					var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));

					return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
				},

				// @method toString(): String
				// Returns a string representation of the point (for debugging purposes).
				toString: function toString(precision) {
					return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
				},

				// @method distanceTo(otherLatLng: LatLng): Number
				// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
				distanceTo: function distanceTo(other) {
					return Earth.distance(this, toLatLng(other));
				},

				// @method wrap(): LatLng
				// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
				wrap: function wrap() {
					return Earth.wrapLatLng(this);
				},

				// @method toBounds(sizeInMeters: Number): LatLngBounds
				// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
				toBounds: function toBounds(sizeInMeters) {
					var latAccuracy = 180 * sizeInMeters / 40075017,
					    lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);

					return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
				},

				clone: function clone() {
					return new LatLng(this.lat, this.lng, this.alt);
				}
			};

			// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
			// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

			// @alternative
			// @factory L.latLng(coords: Array): LatLng
			// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

			// @alternative
			// @factory L.latLng(coords: Object): LatLng
			// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

			function toLatLng(a, b, c) {
				if (a instanceof LatLng) {
					return a;
				}
				if (isArray(a) && _typeof(a[0]) !== 'object') {
					if (a.length === 3) {
						return new LatLng(a[0], a[1], a[2]);
					}
					if (a.length === 2) {
						return new LatLng(a[0], a[1]);
					}
					return null;
				}
				if (a === undefined || a === null) {
					return a;
				}
				if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && 'lat' in a) {
					return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
				}
				if (b === undefined) {
					return null;
				}
				return new LatLng(a, b, c);
			}

			/*
    * @namespace CRS
    * @crs L.CRS.Base
    * Object that defines coordinate reference systems for projecting
    * geographical points into pixel (screen) coordinates and back (and to
    * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
    * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
    *
    * Leaflet defines the most usual CRSs by default. If you want to use a
    * CRS not defined by default, take a look at the
    * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
    *
    * Note that the CRS instances do not inherit from Leafet's `Class` object,
    * and can't be instantiated. Also, new classes can't inherit from them,
    * and methods can't be added to them with the `include` function.
    */

			var CRS = {
				// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
				// Projects geographical coordinates into pixel coordinates for a given zoom.
				latLngToPoint: function latLngToPoint(latlng, zoom) {
					var projectedPoint = this.projection.project(latlng),
					    scale = this.scale(zoom);

					return this.transformation._transform(projectedPoint, scale);
				},

				// @method pointToLatLng(point: Point, zoom: Number): LatLng
				// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
				// zoom into geographical coordinates.
				pointToLatLng: function pointToLatLng(point, zoom) {
					var scale = this.scale(zoom),
					    untransformedPoint = this.transformation.untransform(point, scale);

					return this.projection.unproject(untransformedPoint);
				},

				// @method project(latlng: LatLng): Point
				// Projects geographical coordinates into coordinates in units accepted for
				// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
				project: function project(latlng) {
					return this.projection.project(latlng);
				},

				// @method unproject(point: Point): LatLng
				// Given a projected coordinate returns the corresponding LatLng.
				// The inverse of `project`.
				unproject: function unproject(point) {
					return this.projection.unproject(point);
				},

				// @method scale(zoom: Number): Number
				// Returns the scale used when transforming projected coordinates into
				// pixel coordinates for a particular zoom. For example, it returns
				// `256 * 2^zoom` for Mercator-based CRS.
				scale: function scale(zoom) {
					return 256 * Math.pow(2, zoom);
				},

				// @method zoom(scale: Number): Number
				// Inverse of `scale()`, returns the zoom level corresponding to a scale
				// factor of `scale`.
				zoom: function zoom(scale) {
					return Math.log(scale / 256) / Math.LN2;
				},

				// @method getProjectedBounds(zoom: Number): Bounds
				// Returns the projection's bounds scaled and transformed for the provided `zoom`.
				getProjectedBounds: function getProjectedBounds(zoom) {
					if (this.infinite) {
						return null;
					}

					var b = this.projection.bounds,
					    s = this.scale(zoom),
					    min = this.transformation.transform(b.min, s),
					    max = this.transformation.transform(b.max, s);

					return new Bounds(min, max);
				},

				// @method distance(latlng1: LatLng, latlng2: LatLng): Number
				// Returns the distance between two geographical coordinates.

				// @property code: String
				// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
				//
				// @property wrapLng: Number[]
				// An array of two numbers defining whether the longitude (horizontal) coordinate
				// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
				// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
				//
				// @property wrapLat: Number[]
				// Like `wrapLng`, but for the latitude (vertical) axis.

				// wrapLng: [min, max],
				// wrapLat: [min, max],

				// @property infinite: Boolean
				// If true, the coordinate space will be unbounded (infinite in both axes)
				infinite: false,

				// @method wrapLatLng(latlng: LatLng): LatLng
				// Returns a `LatLng` where lat and lng has been wrapped according to the
				// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
				wrapLatLng: function wrapLatLng(latlng) {
					var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
					    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
					    alt = latlng.alt;

					return new LatLng(lat, lng, alt);
				},

				// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
				// Returns a `LatLngBounds` with the same size as the given one, ensuring
				// that its center is within the CRS's bounds.
				// Only accepts actual `L.LatLngBounds` instances, not arrays.
				wrapLatLngBounds: function wrapLatLngBounds(bounds) {
					var center = bounds.getCenter(),
					    newCenter = this.wrapLatLng(center),
					    latShift = center.lat - newCenter.lat,
					    lngShift = center.lng - newCenter.lng;

					if (latShift === 0 && lngShift === 0) {
						return bounds;
					}

					var sw = bounds.getSouthWest(),
					    ne = bounds.getNorthEast(),
					    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
					    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

					return new LatLngBounds(newSw, newNe);
				}
			};

			/*
    * @namespace CRS
    * @crs L.CRS.Earth
    *
    * Serves as the base for CRS that are global such that they cover the earth.
    * Can only be used as the base for other CRS and cannot be used directly,
    * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
    * meters.
    */

			var Earth = extend({}, CRS, {
				wrapLng: [-180, 180],

				// Mean Earth Radius, as recommended for use by
				// the International Union of Geodesy and Geophysics,
				// see http://rosettacode.org/wiki/Haversine_formula
				R: 6371000,

				// distance between two geographical points using spherical law of cosines approximation
				distance: function distance(latlng1, latlng2) {
					var rad = Math.PI / 180,
					    lat1 = latlng1.lat * rad,
					    lat2 = latlng2.lat * rad,
					    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
					    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
					    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
					    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
					return this.R * c;
				}
			});

			/*
    * @namespace Projection
    * @projection L.Projection.SphericalMercator
    *
    * Spherical Mercator projection — the most common projection for online maps,
    * used by almost all free and commercial tile providers. Assumes that Earth is
    * a sphere. Used by the `EPSG:3857` CRS.
    */

			var SphericalMercator = {

				R: 6378137,
				MAX_LATITUDE: 85.0511287798,

				project: function project(latlng) {
					var d = Math.PI / 180,
					    max = this.MAX_LATITUDE,
					    lat = Math.max(Math.min(max, latlng.lat), -max),
					    sin = Math.sin(lat * d);

					return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
				},

				unproject: function unproject(point) {
					var d = 180 / Math.PI;

					return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
				},

				bounds: function () {
					var d = 6378137 * Math.PI;
					return new Bounds([-d, -d], [d, d]);
				}()
			};

			/*
    * @class Transformation
    * @aka L.Transformation
    *
    * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
    * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
    * the reverse. Used by Leaflet in its projections code.
    *
    * @example
    *
    * ```js
    * var transformation = L.transformation(2, 5, -1, 10),
    * 	p = L.point(1, 2),
    * 	p2 = transformation.transform(p), //  L.point(7, 8)
    * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
    * ```
    */

			// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
			// Creates a `Transformation` object with the given coefficients.
			function Transformation(a, b, c, d) {
				if (isArray(a)) {
					// use array properties
					this._a = a[0];
					this._b = a[1];
					this._c = a[2];
					this._d = a[3];
					return;
				}
				this._a = a;
				this._b = b;
				this._c = c;
				this._d = d;
			}

			Transformation.prototype = {
				// @method transform(point: Point, scale?: Number): Point
				// Returns a transformed point, optionally multiplied by the given scale.
				// Only accepts actual `L.Point` instances, not arrays.
				transform: function transform(point, scale) {
					// (Point, Number) -> Point
					return this._transform(point.clone(), scale);
				},

				// destructive transform (faster)
				_transform: function _transform(point, scale) {
					scale = scale || 1;
					point.x = scale * (this._a * point.x + this._b);
					point.y = scale * (this._c * point.y + this._d);
					return point;
				},

				// @method untransform(point: Point, scale?: Number): Point
				// Returns the reverse transformation of the given point, optionally divided
				// by the given scale. Only accepts actual `L.Point` instances, not arrays.
				untransform: function untransform(point, scale) {
					scale = scale || 1;
					return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
				}
			};

			// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

			// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
			// Instantiates a Transformation object with the given coefficients.

			// @alternative
			// @factory L.transformation(coefficients: Array): Transformation
			// Expects an coefficients array of the form
			// `[a: Number, b: Number, c: Number, d: Number]`.

			function toTransformation(a, b, c, d) {
				return new Transformation(a, b, c, d);
			}

			/*
    * @namespace CRS
    * @crs L.CRS.EPSG3857
    *
    * The most common CRS for online maps, used by almost all free and commercial
    * tile providers. Uses Spherical Mercator projection. Set in by default in
    * Map's `crs` option.
    */

			var EPSG3857 = extend({}, Earth, {
				code: 'EPSG:3857',
				projection: SphericalMercator,

				transformation: function () {
					var scale = 0.5 / (Math.PI * SphericalMercator.R);
					return toTransformation(scale, 0.5, -scale, 0.5);
				}()
			});

			var EPSG900913 = extend({}, EPSG3857, {
				code: 'EPSG:900913'
			});

			// @namespace SVG; @section
			// There are several static functions which can be called without instantiating L.SVG:

			// @function create(name: String): SVGElement
			// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
			// corresponding to the class name passed. For example, using 'line' will return
			// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
			function svgCreate(name) {
				return document.createElementNS('http://www.w3.org/2000/svg', name);
			}

			// @function pointsToPath(rings: Point[], closed: Boolean): String
			// Generates a SVG path string for multiple rings, with each ring turning
			// into "M..L..L.." instructions
			function pointsToPath(rings, closed) {
				var str = '',
				    i,
				    j,
				    len,
				    len2,
				    points,
				    p;

				for (i = 0, len = rings.length; i < len; i++) {
					points = rings[i];

					for (j = 0, len2 = points.length; j < len2; j++) {
						p = points[j];
						str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
					}

					// closes the ring for polygons; "x" is VML syntax
					str += closed ? svg ? 'z' : 'x' : '';
				}

				// SVG complains about empty path strings
				return str || 'M0 0';
			}

			/*
    * @namespace Browser
    * @aka L.Browser
    *
    * A namespace with static properties for browser/feature detection used by Leaflet internally.
    *
    * @example
    *
    * ```js
    * if (L.Browser.ielt9) {
    *   alert('Upgrade your browser, dude!');
    * }
    * ```
    */

			var style$1 = document.documentElement.style;

			// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
			var ie = 'ActiveXObject' in window;

			// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
			var ielt9 = ie && !document.addEventListener;

			// @property edge: Boolean; `true` for the Edge web browser.
			var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

			// @property webkit: Boolean;
			// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
			var webkit = userAgentContains('webkit');

			// @property android: Boolean
			// `true` for any browser running on an Android platform.
			var android = userAgentContains('android');

			// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
			var android23 = userAgentContains('android 2') || userAgentContains('android 3');

			/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
			var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
			// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
			var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

			// @property opera: Boolean; `true` for the Opera browser
			var opera = !!window.opera;

			// @property chrome: Boolean; `true` for the Chrome browser.
			var chrome = userAgentContains('chrome');

			// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
			var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

			// @property safari: Boolean; `true` for the Safari browser.
			var safari = !chrome && userAgentContains('safari');

			var phantom = userAgentContains('phantom');

			// @property opera12: Boolean
			// `true` for the Opera browser supporting CSS transforms (version 12 or later).
			var opera12 = 'OTransition' in style$1;

			// @property win: Boolean; `true` when the browser is running in a Windows platform
			var win = navigator.platform.indexOf('Win') === 0;

			// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
			var ie3d = ie && 'transition' in style$1;

			// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
			var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;

			// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
			var gecko3d = 'MozPerspective' in style$1;

			// @property any3d: Boolean
			// `true` for all browsers supporting CSS transforms.
			var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

			// @property mobile: Boolean; `true` for all browsers running in a mobile device.
			var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

			// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
			var mobileWebkit = mobile && webkit;

			// @property mobileWebkit3d: Boolean
			// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
			var mobileWebkit3d = mobile && webkit3d;

			// @property msPointer: Boolean
			// `true` for browsers implementing the Microsoft touch events model (notably IE10).
			var msPointer = !window.PointerEvent && window.MSPointerEvent;

			// @property pointer: Boolean
			// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
			var pointer = !!(window.PointerEvent || msPointer);

			// @property touch: Boolean
			// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
			// This does not necessarily mean that the browser is running in a computer with
			// a touchscreen, it only means that the browser is capable of understanding
			// touch events.
			var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

			// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
			var mobileOpera = mobile && opera;

			// @property mobileGecko: Boolean
			// `true` for gecko-based browsers running in a mobile device.
			var mobileGecko = mobile && gecko;

			// @property retina: Boolean
			// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
			var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

			// @property canvas: Boolean
			// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
			var canvas = function () {
				return !!document.createElement('canvas').getContext;
			}();

			// @property svg: Boolean
			// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
			var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

			// @property vml: Boolean
			// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
			var vml = !svg && function () {
				try {
					var div = document.createElement('div');
					div.innerHTML = '<v:shape adj="1"/>';

					var shape = div.firstChild;
					shape.style.behavior = 'url(#default#VML)';

					return shape && _typeof(shape.adj) === 'object';
				} catch (e) {
					return false;
				}
			}();

			function userAgentContains(str) {
				return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
			}

			var Browser = (Object.freeze || Object)({
				ie: ie,
				ielt9: ielt9,
				edge: edge,
				webkit: webkit,
				android: android,
				android23: android23,
				androidStock: androidStock,
				opera: opera,
				chrome: chrome,
				gecko: gecko,
				safari: safari,
				phantom: phantom,
				opera12: opera12,
				win: win,
				ie3d: ie3d,
				webkit3d: webkit3d,
				gecko3d: gecko3d,
				any3d: any3d,
				mobile: mobile,
				mobileWebkit: mobileWebkit,
				mobileWebkit3d: mobileWebkit3d,
				msPointer: msPointer,
				pointer: pointer,
				touch: touch,
				mobileOpera: mobileOpera,
				mobileGecko: mobileGecko,
				retina: retina,
				canvas: canvas,
				svg: svg,
				vml: vml
			});

			/*
    * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
    */

			var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';
			var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';
			var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';
			var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
			var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

			var _pointers = {};
			var _pointerDocListener = false;

			// DomEvent.DoubleTap needs to know about this
			var _pointersCount = 0;

			// Provides a touch events wrapper for (ms)pointer events.
			// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

			function addPointerListener(obj, type, handler, id) {
				if (type === 'touchstart') {
					_addPointerStart(obj, handler, id);
				} else if (type === 'touchmove') {
					_addPointerMove(obj, handler, id);
				} else if (type === 'touchend') {
					_addPointerEnd(obj, handler, id);
				}

				return this;
			}

			function removePointerListener(obj, type, id) {
				var handler = obj['_leaflet_' + type + id];

				if (type === 'touchstart') {
					obj.removeEventListener(POINTER_DOWN, handler, false);
				} else if (type === 'touchmove') {
					obj.removeEventListener(POINTER_MOVE, handler, false);
				} else if (type === 'touchend') {
					obj.removeEventListener(POINTER_UP, handler, false);
					obj.removeEventListener(POINTER_CANCEL, handler, false);
				}

				return this;
			}

			function _addPointerStart(obj, handler, id) {
				var onDown = bind(function (e) {
					if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
						// In IE11, some touch events needs to fire for form controls, or
						// the controls will stop working. We keep a whitelist of tag names that
						// need these events. For other target tags, we prevent default on the event.
						if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
							preventDefault(e);
						} else {
							return;
						}
					}

					_handlePointer(e, handler);
				});

				obj['_leaflet_touchstart' + id] = onDown;
				obj.addEventListener(POINTER_DOWN, onDown, false);

				// need to keep track of what pointers and how many are active to provide e.touches emulation
				if (!_pointerDocListener) {
					// we listen documentElement as any drags that end by moving the touch off the screen get fired there
					document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
					document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
					document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
					document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

					_pointerDocListener = true;
				}
			}

			function _globalPointerDown(e) {
				_pointers[e.pointerId] = e;
				_pointersCount++;
			}

			function _globalPointerMove(e) {
				if (_pointers[e.pointerId]) {
					_pointers[e.pointerId] = e;
				}
			}

			function _globalPointerUp(e) {
				delete _pointers[e.pointerId];
				_pointersCount--;
			}

			function _handlePointer(e, handler) {
				e.touches = [];
				for (var i in _pointers) {
					e.touches.push(_pointers[i]);
				}
				e.changedTouches = [e];

				handler(e);
			}

			function _addPointerMove(obj, handler, id) {
				var onMove = function onMove(e) {
					// don't fire touch moves when mouse isn't down
					if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
						return;
					}

					_handlePointer(e, handler);
				};

				obj['_leaflet_touchmove' + id] = onMove;
				obj.addEventListener(POINTER_MOVE, onMove, false);
			}

			function _addPointerEnd(obj, handler, id) {
				var onUp = function onUp(e) {
					_handlePointer(e, handler);
				};

				obj['_leaflet_touchend' + id] = onUp;
				obj.addEventListener(POINTER_UP, onUp, false);
				obj.addEventListener(POINTER_CANCEL, onUp, false);
			}

			/*
    * Extends the event handling code with double tap support for mobile browsers.
    */

			var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
			var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
			var _pre = '_leaflet_';

			// inspired by Zepto touch code by Thomas Fuchs
			function addDoubleTapListener(obj, handler, id) {
				var last,
				    touch$$1,
				    doubleTap = false,
				    delay = 250;

				function onTouchStart(e) {
					var count;

					if (pointer) {
						if (!edge || e.pointerType === 'mouse') {
							return;
						}
						count = _pointersCount;
					} else {
						count = e.touches.length;
					}

					if (count > 1) {
						return;
					}

					var now = Date.now(),
					    delta = now - (last || now);

					touch$$1 = e.touches ? e.touches[0] : e;
					doubleTap = delta > 0 && delta <= delay;
					last = now;
				}

				function onTouchEnd(e) {
					if (doubleTap && !touch$$1.cancelBubble) {
						if (pointer) {
							if (!edge || e.pointerType === 'mouse') {
								return;
							}
							// work around .type being readonly with MSPointer* events
							var newTouch = {},
							    prop,
							    i;

							for (i in touch$$1) {
								prop = touch$$1[i];
								newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
							}
							touch$$1 = newTouch;
						}
						touch$$1.type = 'dblclick';
						handler(touch$$1);
						last = null;
					}
				}

				obj[_pre + _touchstart + id] = onTouchStart;
				obj[_pre + _touchend + id] = onTouchEnd;
				obj[_pre + 'dblclick' + id] = handler;

				obj.addEventListener(_touchstart, onTouchStart, false);
				obj.addEventListener(_touchend, onTouchEnd, false);

				// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
				// the browser doesn't fire touchend/pointerup events but does fire
				// native dblclicks. See #4127.
				// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
				obj.addEventListener('dblclick', handler, false);

				return this;
			}

			function removeDoubleTapListener(obj, id) {
				var touchstart = obj[_pre + _touchstart + id],
				    touchend = obj[_pre + _touchend + id],
				    dblclick = obj[_pre + 'dblclick' + id];

				obj.removeEventListener(_touchstart, touchstart, false);
				obj.removeEventListener(_touchend, touchend, false);
				if (!edge) {
					obj.removeEventListener('dblclick', dblclick, false);
				}

				return this;
			}

			/*
    * @namespace DomUtil
    *
    * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
    * tree, used by Leaflet internally.
    *
    * Most functions expecting or returning a `HTMLElement` also work for
    * SVG elements. The only difference is that classes refer to CSS classes
    * in HTML and SVG classes in SVG.
    */

			// @property TRANSFORM: String
			// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
			var TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

			// webkitTransition comes first because some browser versions that drop vendor prefix don't do
			// the same for the transitionend event, in particular the Android 4.1 stock browser

			// @property TRANSITION: String
			// Vendor-prefixed transition style name.
			var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

			// @property TRANSITION_END: String
			// Vendor-prefixed transitionend event name.
			var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

			// @function get(id: String|HTMLElement): HTMLElement
			// Returns an element given its DOM id, or returns the element itself
			// if it was passed directly.
			function get(id) {
				return typeof id === 'string' ? document.getElementById(id) : id;
			}

			// @function getStyle(el: HTMLElement, styleAttrib: String): String
			// Returns the value for a certain style attribute on an element,
			// including computed values or values set through CSS.
			function getStyle(el, style) {
				var value = el.style[style] || el.currentStyle && el.currentStyle[style];

				if ((!value || value === 'auto') && document.defaultView) {
					var css = document.defaultView.getComputedStyle(el, null);
					value = css ? css[style] : null;
				}
				return value === 'auto' ? null : value;
			}

			// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
			// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
			function create$1(tagName, className, container) {
				var el = document.createElement(tagName);
				el.className = className || '';

				if (container) {
					container.appendChild(el);
				}
				return el;
			}

			// @function remove(el: HTMLElement)
			// Removes `el` from its parent element
			function _remove(el) {
				var parent = el.parentNode;
				if (parent) {
					parent.removeChild(el);
				}
			}

			// @function empty(el: HTMLElement)
			// Removes all of `el`'s children elements from `el`
			function empty(el) {
				while (el.firstChild) {
					el.removeChild(el.firstChild);
				}
			}

			// @function toFront(el: HTMLElement)
			// Makes `el` the last child of its parent, so it renders in front of the other children.
			function toFront(el) {
				var parent = el.parentNode;
				if (parent.lastChild !== el) {
					parent.appendChild(el);
				}
			}

			// @function toBack(el: HTMLElement)
			// Makes `el` the first child of its parent, so it renders behind the other children.
			function toBack(el) {
				var parent = el.parentNode;
				if (parent.firstChild !== el) {
					parent.insertBefore(el, parent.firstChild);
				}
			}

			// @function hasClass(el: HTMLElement, name: String): Boolean
			// Returns `true` if the element's class attribute contains `name`.
			function hasClass(el, name) {
				if (el.classList !== undefined) {
					return el.classList.contains(name);
				}
				var className = getClass(el);
				return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
			}

			// @function addClass(el: HTMLElement, name: String)
			// Adds `name` to the element's class attribute.
			function addClass(el, name) {
				if (el.classList !== undefined) {
					var classes = splitWords(name);
					for (var i = 0, len = classes.length; i < len; i++) {
						el.classList.add(classes[i]);
					}
				} else if (!hasClass(el, name)) {
					var className = getClass(el);
					setClass(el, (className ? className + ' ' : '') + name);
				}
			}

			// @function removeClass(el: HTMLElement, name: String)
			// Removes `name` from the element's class attribute.
			function removeClass(el, name) {
				if (el.classList !== undefined) {
					el.classList.remove(name);
				} else {
					setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
				}
			}

			// @function setClass(el: HTMLElement, name: String)
			// Sets the element's class.
			function setClass(el, name) {
				if (el.className.baseVal === undefined) {
					el.className = name;
				} else {
					// in case of SVG element
					el.className.baseVal = name;
				}
			}

			// @function getClass(el: HTMLElement): String
			// Returns the element's class.
			function getClass(el) {
				return el.className.baseVal === undefined ? el.className : el.className.baseVal;
			}

			// @function setOpacity(el: HTMLElement, opacity: Number)
			// Set the opacity of an element (including old IE support).
			// `opacity` must be a number from `0` to `1`.
			function _setOpacity(el, value) {
				if ('opacity' in el.style) {
					el.style.opacity = value;
				} else if ('filter' in el.style) {
					_setOpacityIE(el, value);
				}
			}

			function _setOpacityIE(el, value) {
				var filter = false,
				    filterName = 'DXImageTransform.Microsoft.Alpha';

				// filters collection throws an error if we try to retrieve a filter that doesn't exist
				try {
					filter = el.filters.item(filterName);
				} catch (e) {
					// don't set opacity to 1 if we haven't already set an opacity,
					// it isn't needed and breaks transparent pngs.
					if (value === 1) {
						return;
					}
				}

				value = Math.round(value * 100);

				if (filter) {
					filter.Enabled = value !== 100;
					filter.Opacity = value;
				} else {
					el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
				}
			}

			// @function testProp(props: String[]): String|false
			// Goes through the array of style names and returns the first name
			// that is a valid style name for an element. If no such name is found,
			// it returns false. Useful for vendor-prefixed styles like `transform`.
			function testProp(props) {
				var style = document.documentElement.style;

				for (var i = 0; i < props.length; i++) {
					if (props[i] in style) {
						return props[i];
					}
				}
				return false;
			}

			// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
			// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
			// and optionally scaled by `scale`. Does not have an effect if the
			// browser doesn't support 3D CSS transforms.
			function setTransform(el, offset, scale) {
				var pos = offset || new Point(0, 0);

				el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
			}

			// @function setPosition(el: HTMLElement, position: Point)
			// Sets the position of `el` to coordinates specified by `position`,
			// using CSS translate or top/left positioning depending on the browser
			// (used by Leaflet internally to position its layers).
			function setPosition(el, point) {

				/*eslint-disable */
				el._leaflet_pos = point;
				/* eslint-enable */

				if (any3d) {
					setTransform(el, point);
				} else {
					el.style.left = point.x + 'px';
					el.style.top = point.y + 'px';
				}
			}

			// @function getPosition(el: HTMLElement): Point
			// Returns the coordinates of an element previously positioned with setPosition.
			function getPosition(el) {
				// this method is only used for elements previously positioned using setPosition,
				// so it's safe to cache the position for performance

				return el._leaflet_pos || new Point(0, 0);
			}

			// @function disableTextSelection()
			// Prevents the user from generating `selectstart` DOM events, usually generated
			// when the user drags the mouse through a page with text. Used internally
			// by Leaflet to override the behaviour of any click-and-drag interaction on
			// the map. Affects drag interactions on the whole document.

			// @function enableTextSelection()
			// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
			var disableTextSelection;
			var enableTextSelection;
			var _userSelect;
			if ('onselectstart' in document) {
				disableTextSelection = function disableTextSelection() {
					on(window, 'selectstart', preventDefault);
				};
				enableTextSelection = function enableTextSelection() {
					off(window, 'selectstart', preventDefault);
				};
			} else {
				var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

				disableTextSelection = function disableTextSelection() {
					if (userSelectProperty) {
						var style = document.documentElement.style;
						_userSelect = style[userSelectProperty];
						style[userSelectProperty] = 'none';
					}
				};
				enableTextSelection = function enableTextSelection() {
					if (userSelectProperty) {
						document.documentElement.style[userSelectProperty] = _userSelect;
						_userSelect = undefined;
					}
				};
			}

			// @function disableImageDrag()
			// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
			// for `dragstart` DOM events, usually generated when the user drags an image.
			function disableImageDrag() {
				on(window, 'dragstart', preventDefault);
			}

			// @function enableImageDrag()
			// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
			function enableImageDrag() {
				off(window, 'dragstart', preventDefault);
			}

			var _outlineElement;
			var _outlineStyle;
			// @function preventOutline(el: HTMLElement)
			// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
			// of the element `el` invisible. Used internally by Leaflet to prevent
			// focusable elements from displaying an outline when the user performs a
			// drag interaction on them.
			function preventOutline(element) {
				while (element.tabIndex === -1) {
					element = element.parentNode;
				}
				if (!element.style) {
					return;
				}
				restoreOutline();
				_outlineElement = element;
				_outlineStyle = element.style.outline;
				element.style.outline = 'none';
				on(window, 'keydown', restoreOutline);
			}

			// @function restoreOutline()
			// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
			function restoreOutline() {
				if (!_outlineElement) {
					return;
				}
				_outlineElement.style.outline = _outlineStyle;
				_outlineElement = undefined;
				_outlineStyle = undefined;
				off(window, 'keydown', restoreOutline);
			}

			// @function getSizedParentNode(el: HTMLElement): HTMLElement
			// Finds the closest parent node which size (width and height) is not null.
			function getSizedParentNode(element) {
				do {
					element = element.parentNode;
				} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
				return element;
			}

			// @function getScale(el: HTMLElement): Object
			// Computes the CSS scale currently applied on the element.
			// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
			// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
			function getScale(element) {
				var rect = element.getBoundingClientRect(); // Read-only in old browsers.

				return {
					x: rect.width / element.offsetWidth || 1,
					y: rect.height / element.offsetHeight || 1,
					boundingClientRect: rect
				};
			}

			var DomUtil = (Object.freeze || Object)({
				TRANSFORM: TRANSFORM,
				TRANSITION: TRANSITION,
				TRANSITION_END: TRANSITION_END,
				get: get,
				getStyle: getStyle,
				create: create$1,
				remove: _remove,
				empty: empty,
				toFront: toFront,
				toBack: toBack,
				hasClass: hasClass,
				addClass: addClass,
				removeClass: removeClass,
				setClass: setClass,
				getClass: getClass,
				setOpacity: _setOpacity,
				testProp: testProp,
				setTransform: setTransform,
				setPosition: setPosition,
				getPosition: getPosition,
				disableTextSelection: disableTextSelection,
				enableTextSelection: enableTextSelection,
				disableImageDrag: disableImageDrag,
				enableImageDrag: enableImageDrag,
				preventOutline: preventOutline,
				restoreOutline: restoreOutline,
				getSizedParentNode: getSizedParentNode,
				getScale: getScale
			});

			/*
    * @namespace DomEvent
    * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
    */

			// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

			// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
			// Adds a listener function (`fn`) to a particular DOM event type of the
			// element `el`. You can optionally specify the context of the listener
			// (object the `this` keyword will point to). You can also pass several
			// space-separated types (e.g. `'click dblclick'`).

			// @alternative
			// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
			// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
			function on(obj, types, fn, context) {

				if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
					for (var type in types) {
						addOne(obj, type, types[type], fn);
					}
				} else {
					types = splitWords(types);

					for (var i = 0, len = types.length; i < len; i++) {
						addOne(obj, types[i], fn, context);
					}
				}

				return this;
			}

			var eventsKey = '_leaflet_events';

			// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
			// Removes a previously added listener function.
			// Note that if you passed a custom context to on, you must pass the same
			// context to `off` in order to remove the listener.

			// @alternative
			// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
			// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
			function off(obj, types, fn, context) {

				if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
					for (var type in types) {
						removeOne(obj, type, types[type], fn);
					}
				} else if (types) {
					types = splitWords(types);

					for (var i = 0, len = types.length; i < len; i++) {
						removeOne(obj, types[i], fn, context);
					}
				} else {
					for (var j in obj[eventsKey]) {
						removeOne(obj, j, obj[eventsKey][j]);
					}
					delete obj[eventsKey];
				}

				return this;
			}

			function addOne(obj, type, fn, context) {
				var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

				if (obj[eventsKey] && obj[eventsKey][id]) {
					return this;
				}

				var handler = function handler(e) {
					return fn.call(context || obj, e || window.event);
				};

				var originalHandler = handler;

				if (pointer && type.indexOf('touch') === 0) {
					// Needs DomEvent.Pointer.js
					addPointerListener(obj, type, handler, id);
				} else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {
					// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
					// See #5180
					addDoubleTapListener(obj, handler, id);
				} else if ('addEventListener' in obj) {

					if (type === 'mousewheel') {
						obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
					} else if (type === 'mouseenter' || type === 'mouseleave') {
						handler = function handler(e) {
							e = e || window.event;
							if (isExternalTarget(obj, e)) {
								originalHandler(e);
							}
						};
						obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
					} else {
						if (type === 'click' && android) {
							handler = function handler(e) {
								filterClick(e, originalHandler);
							};
						}
						obj.addEventListener(type, handler, false);
					}
				} else if ('attachEvent' in obj) {
					obj.attachEvent('on' + type, handler);
				}

				obj[eventsKey] = obj[eventsKey] || {};
				obj[eventsKey][id] = handler;
			}

			function removeOne(obj, type, fn, context) {

				var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
				    handler = obj[eventsKey] && obj[eventsKey][id];

				if (!handler) {
					return this;
				}

				if (pointer && type.indexOf('touch') === 0) {
					removePointerListener(obj, type, id);
				} else if (touch && type === 'dblclick' && removeDoubleTapListener && !(pointer && chrome)) {
					removeDoubleTapListener(obj, id);
				} else if ('removeEventListener' in obj) {

					if (type === 'mousewheel') {
						obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
					} else {
						obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
					}
				} else if ('detachEvent' in obj) {
					obj.detachEvent('on' + type, handler);
				}

				obj[eventsKey][id] = null;
			}

			// @function stopPropagation(ev: DOMEvent): this
			// Stop the given event from propagation to parent elements. Used inside the listener functions:
			// ```js
			// L.DomEvent.on(div, 'click', function (ev) {
			// 	L.DomEvent.stopPropagation(ev);
			// });
			// ```
			function stopPropagation(e) {

				if (e.stopPropagation) {
					e.stopPropagation();
				} else if (e.originalEvent) {
					// In case of Leaflet event.
					e.originalEvent._stopped = true;
				} else {
					e.cancelBubble = true;
				}
				skipped(e);

				return this;
			}

			// @function disableScrollPropagation(el: HTMLElement): this
			// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
			function disableScrollPropagation(el) {
				addOne(el, 'mousewheel', stopPropagation);
				return this;
			}

			// @function disableClickPropagation(el: HTMLElement): this
			// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
			// `'mousedown'` and `'touchstart'` events (plus browser variants).
			function disableClickPropagation(el) {
				on(el, 'mousedown touchstart dblclick', stopPropagation);
				addOne(el, 'click', fakeStop);
				return this;
			}

			// @function preventDefault(ev: DOMEvent): this
			// Prevents the default action of the DOM Event `ev` from happening (such as
			// following a link in the href of the a element, or doing a POST request
			// with page reload when a `<form>` is submitted).
			// Use it inside listener functions.
			function preventDefault(e) {
				if (e.preventDefault) {
					e.preventDefault();
				} else {
					e.returnValue = false;
				}
				return this;
			}

			// @function stop(ev: DOMEvent): this
			// Does `stopPropagation` and `preventDefault` at the same time.
			function stop(e) {
				preventDefault(e);
				stopPropagation(e);
				return this;
			}

			// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
			// Gets normalized mouse position from a DOM event relative to the
			// `container` (border excluded) or to the whole page if not specified.
			function getMousePosition(e, container) {
				if (!container) {
					return new Point(e.clientX, e.clientY);
				}

				var scale = getScale(container),
				    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

				return new Point(
				// offset.left/top values are in page scale (like clientX/Y),
				// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
				(e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
			}

			// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
			// and Firefox scrolls device pixels, not CSS pixels
			var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1;

			// @function getWheelDelta(ev: DOMEvent): Number
			// Gets normalized wheel delta from a mousewheel DOM event, in vertical
			// pixels scrolled (negative if scrolling down).
			// Events from pointing devices without precise scrolling are mapped to
			// a best guess of 60 pixels.
			function getWheelDelta(e) {
				return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
				e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
				e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
				e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
				e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
				e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
				e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
				e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
				0;
			}

			var skipEvents = {};

			function fakeStop(e) {
				// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
				skipEvents[e.type] = true;
			}

			function skipped(e) {
				var events = skipEvents[e.type];
				// reset when checking, as it's only used in map container and propagates outside of the map
				skipEvents[e.type] = false;
				return events;
			}

			// check if element really left/entered the event target (for mouseenter/mouseleave)
			function isExternalTarget(el, e) {

				var related = e.relatedTarget;

				if (!related) {
					return true;
				}

				try {
					while (related && related !== el) {
						related = related.parentNode;
					}
				} catch (err) {
					return false;
				}
				return related !== el;
			}

			var lastClick;

			// this is a horrible workaround for a bug in Android where a single touch triggers two click events
			function filterClick(e, handler) {
				var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
				    elapsed = lastClick && timeStamp - lastClick;

				// are they closer together than 500ms yet more than 100ms?
				// Android typically triggers them ~300ms apart while multiple listeners
				// on the same event should be triggered far faster;
				// or check if click is simulated on the element, and if it is, reject any non-simulated events

				if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
					stop(e);
					return;
				}
				lastClick = timeStamp;

				handler(e);
			}

			var DomEvent = (Object.freeze || Object)({
				on: on,
				off: off,
				stopPropagation: stopPropagation,
				disableScrollPropagation: disableScrollPropagation,
				disableClickPropagation: disableClickPropagation,
				preventDefault: preventDefault,
				stop: stop,
				getMousePosition: getMousePosition,
				getWheelDelta: getWheelDelta,
				fakeStop: fakeStop,
				skipped: skipped,
				isExternalTarget: isExternalTarget,
				addListener: on,
				removeListener: off
			});

			/*
    * @class PosAnimation
    * @aka L.PosAnimation
    * @inherits Evented
    * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
    *
    * @example
    * ```js
    * var fx = new L.PosAnimation();
    * fx.run(el, [300, 500], 0.5);
    * ```
    *
    * @constructor L.PosAnimation()
    * Creates a `PosAnimation` object.
    *
    */

			var PosAnimation = Evented.extend({

				// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
				// Run an animation of a given element to a new position, optionally setting
				// duration in seconds (`0.25` by default) and easing linearity factor (3rd
				// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
				// `0.5` by default).
				run: function run(el, newPos, duration, easeLinearity) {
					this.stop();

					this._el = el;
					this._inProgress = true;
					this._duration = duration || 0.25;
					this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

					this._startPos = getPosition(el);
					this._offset = newPos.subtract(this._startPos);
					this._startTime = +new Date();

					// @event start: Event
					// Fired when the animation starts
					this.fire('start');

					this._animate();
				},

				// @method stop()
				// Stops the animation (if currently running).
				stop: function stop() {
					if (!this._inProgress) {
						return;
					}

					this._step(true);
					this._complete();
				},

				_animate: function _animate() {
					// animation loop
					this._animId = requestAnimFrame(this._animate, this);
					this._step();
				},

				_step: function _step(round) {
					var elapsed = +new Date() - this._startTime,
					    duration = this._duration * 1000;

					if (elapsed < duration) {
						this._runFrame(this._easeOut(elapsed / duration), round);
					} else {
						this._runFrame(1);
						this._complete();
					}
				},

				_runFrame: function _runFrame(progress, round) {
					var pos = this._startPos.add(this._offset.multiplyBy(progress));
					if (round) {
						pos._round();
					}
					setPosition(this._el, pos);

					// @event step: Event
					// Fired continuously during the animation.
					this.fire('step');
				},

				_complete: function _complete() {
					cancelAnimFrame(this._animId);

					this._inProgress = false;
					// @event end: Event
					// Fired when the animation ends.
					this.fire('end');
				},

				_easeOut: function _easeOut(t) {
					return 1 - Math.pow(1 - t, this._easeOutPower);
				}
			});

			/*
    * @class Map
    * @aka L.Map
    * @inherits Evented
    *
    * The central class of the API — it is used to create a map on a page and manipulate it.
    *
    * @example
    *
    * ```js
    * // initialize the map on the "map" div with a given center and zoom
    * var map = L.map('map', {
    * 	center: [51.505, -0.09],
    * 	zoom: 13
    * });
    * ```
    *
    */

			var Map = Evented.extend({

				options: {
					// @section Map State Options
					// @option crs: CRS = L.CRS.EPSG3857
					// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
					// sure what it means.
					crs: EPSG3857,

					// @option center: LatLng = undefined
					// Initial geographic center of the map
					center: undefined,

					// @option zoom: Number = undefined
					// Initial map zoom level
					zoom: undefined,

					// @option minZoom: Number = *
					// Minimum zoom level of the map.
					// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
					// the lowest of their `minZoom` options will be used instead.
					minZoom: undefined,

					// @option maxZoom: Number = *
					// Maximum zoom level of the map.
					// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
					// the highest of their `maxZoom` options will be used instead.
					maxZoom: undefined,

					// @option layers: Layer[] = []
					// Array of layers that will be added to the map initially
					layers: [],

					// @option maxBounds: LatLngBounds = null
					// When this option is set, the map restricts the view to the given
					// geographical bounds, bouncing the user back if the user tries to pan
					// outside the view. To set the restriction dynamically, use
					// [`setMaxBounds`](#map-setmaxbounds) method.
					maxBounds: undefined,

					// @option renderer: Renderer = *
					// The default method for drawing vector layers on the map. `L.SVG`
					// or `L.Canvas` by default depending on browser support.
					renderer: undefined,

					// @section Animation Options
					// @option zoomAnimation: Boolean = true
					// Whether the map zoom animation is enabled. By default it's enabled
					// in all browsers that support CSS3 Transitions except Android.
					zoomAnimation: true,

					// @option zoomAnimationThreshold: Number = 4
					// Won't animate zoom if the zoom difference exceeds this value.
					zoomAnimationThreshold: 4,

					// @option fadeAnimation: Boolean = true
					// Whether the tile fade animation is enabled. By default it's enabled
					// in all browsers that support CSS3 Transitions except Android.
					fadeAnimation: true,

					// @option markerZoomAnimation: Boolean = true
					// Whether markers animate their zoom with the zoom animation, if disabled
					// they will disappear for the length of the animation. By default it's
					// enabled in all browsers that support CSS3 Transitions except Android.
					markerZoomAnimation: true,

					// @option transform3DLimit: Number = 2^23
					// Defines the maximum size of a CSS translation transform. The default
					// value should not be changed unless a web browser positions layers in
					// the wrong place after doing a large `panBy`.
					transform3DLimit: 8388608, // Precision limit of a 32-bit float

					// @section Interaction Options
					// @option zoomSnap: Number = 1
					// Forces the map's zoom level to always be a multiple of this, particularly
					// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
					// By default, the zoom level snaps to the nearest integer; lower values
					// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
					// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
					zoomSnap: 1,

					// @option zoomDelta: Number = 1
					// Controls how much the map's zoom level will change after a
					// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
					// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
					// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
					zoomDelta: 1,

					// @option trackResize: Boolean = true
					// Whether the map automatically handles browser window resize to update itself.
					trackResize: true
				},

				initialize: function initialize(id, options) {
					// (HTMLElement or String, Object)
					options = setOptions(this, options);

					this._initContainer(id);
					this._initLayout();

					// hack for https://github.com/Leaflet/Leaflet/issues/1980
					this._onResize = bind(this._onResize, this);

					this._initEvents();

					if (options.maxBounds) {
						this.setMaxBounds(options.maxBounds);
					}

					if (options.zoom !== undefined) {
						this._zoom = this._limitZoom(options.zoom);
					}

					if (options.center && options.zoom !== undefined) {
						this.setView(toLatLng(options.center), options.zoom, { reset: true });
					}

					this._handlers = [];
					this._layers = {};
					this._zoomBoundLayers = {};
					this._sizeChanged = true;

					this.callInitHooks();

					// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
					this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation;

					// zoom transitions run with the same duration for all layers, so if one of transitionend events
					// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
					if (this._zoomAnimated) {
						this._createAnimProxy();
						on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
					}

					this._addLayers(this.options.layers);
				},

				// @section Methods for modifying map state

				// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
				// Sets the view of the map (geographical center and zoom) with the given
				// animation options.
				setView: function setView(center, zoom, options) {

					zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
					center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
					options = options || {};

					this._stop();

					if (this._loaded && !options.reset && options !== true) {

						if (options.animate !== undefined) {
							options.zoom = extend({ animate: options.animate }, options.zoom);
							options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
						}

						// try animating pan or zoom
						var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

						if (moved) {
							// prevent resize handler call, the view will refresh after animation anyway
							clearTimeout(this._sizeTimer);
							return this;
						}
					}

					// animation didn't start, just reset the map view
					this._resetView(center, zoom);

					return this;
				},

				// @method setZoom(zoom: Number, options?: Zoom/pan options): this
				// Sets the zoom of the map.
				setZoom: function setZoom(zoom, options) {
					if (!this._loaded) {
						this._zoom = zoom;
						return this;
					}
					return this.setView(this.getCenter(), zoom, { zoom: options });
				},

				// @method zoomIn(delta?: Number, options?: Zoom options): this
				// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
				zoomIn: function zoomIn(delta, options) {
					delta = delta || (any3d ? this.options.zoomDelta : 1);
					return this.setZoom(this._zoom + delta, options);
				},

				// @method zoomOut(delta?: Number, options?: Zoom options): this
				// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
				zoomOut: function zoomOut(delta, options) {
					delta = delta || (any3d ? this.options.zoomDelta : 1);
					return this.setZoom(this._zoom - delta, options);
				},

				// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
				// Zooms the map while keeping a specified geographical point on the map
				// stationary (e.g. used internally for scroll zoom and double-click zoom).
				// @alternative
				// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
				// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
				setZoomAround: function setZoomAround(latlng, zoom, options) {
					var scale = this.getZoomScale(zoom),
					    viewHalf = this.getSize().divideBy(2),
					    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
					    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
					    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

					return this.setView(newCenter, zoom, { zoom: options });
				},

				_getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {

					options = options || {};
					bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

					var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
					    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
					    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

					zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

					if (zoom === Infinity) {
						return {
							center: bounds.getCenter(),
							zoom: zoom
						};
					}

					var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
					    swPoint = this.project(bounds.getSouthWest(), zoom),
					    nePoint = this.project(bounds.getNorthEast(), zoom),
					    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

					return {
						center: center,
						zoom: zoom
					};
				},

				// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
				// Sets a map view that contains the given geographical bounds with the
				// maximum zoom level possible.
				fitBounds: function fitBounds(bounds, options) {

					bounds = toLatLngBounds(bounds);

					if (!bounds.isValid()) {
						throw new Error('Bounds are not valid.');
					}

					var target = this._getBoundsCenterZoom(bounds, options);
					return this.setView(target.center, target.zoom, options);
				},

				// @method fitWorld(options?: fitBounds options): this
				// Sets a map view that mostly contains the whole world with the maximum
				// zoom level possible.
				fitWorld: function fitWorld(options) {
					return this.fitBounds([[-90, -180], [90, 180]], options);
				},

				// @method panTo(latlng: LatLng, options?: Pan options): this
				// Pans the map to a given center.
				panTo: function panTo(center, options) {
					// (LatLng)
					return this.setView(center, this._zoom, { pan: options });
				},

				// @method panBy(offset: Point, options?: Pan options): this
				// Pans the map by a given number of pixels (animated).
				panBy: function panBy(offset, options) {
					offset = toPoint(offset).round();
					options = options || {};

					if (!offset.x && !offset.y) {
						return this.fire('moveend');
					}
					// If we pan too far, Chrome gets issues with tiles
					// and makes them disappear or appear in the wrong place (slightly offset) #2602
					if (options.animate !== true && !this.getSize().contains(offset)) {
						this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
						return this;
					}

					if (!this._panAnim) {
						this._panAnim = new PosAnimation();

						this._panAnim.on({
							'step': this._onPanTransitionStep,
							'end': this._onPanTransitionEnd
						}, this);
					}

					// don't fire movestart if animating inertia
					if (!options.noMoveStart) {
						this.fire('movestart');
					}

					// animate pan unless animate: false specified
					if (options.animate !== false) {
						addClass(this._mapPane, 'leaflet-pan-anim');

						var newPos = this._getMapPanePos().subtract(offset).round();
						this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
					} else {
						this._rawPanBy(offset);
						this.fire('move').fire('moveend');
					}

					return this;
				},

				// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
				// Sets the view of the map (geographical center and zoom) performing a smooth
				// pan-zoom animation.
				flyTo: function flyTo(targetCenter, targetZoom, options) {

					options = options || {};
					if (options.animate === false || !any3d) {
						return this.setView(targetCenter, targetZoom, options);
					}

					this._stop();

					var from = this.project(this.getCenter()),
					    to = this.project(targetCenter),
					    size = this.getSize(),
					    startZoom = this._zoom;

					targetCenter = toLatLng(targetCenter);
					targetZoom = targetZoom === undefined ? startZoom : targetZoom;

					var w0 = Math.max(size.x, size.y),
					    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
					    u1 = to.distanceTo(from) || 1,
					    rho = 1.42,
					    rho2 = rho * rho;

					function r(i) {
						var s1 = i ? -1 : 1,
						    s2 = i ? w1 : w0,
						    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
						    b1 = 2 * s2 * rho2 * u1,
						    b = t1 / b1,
						    sq = Math.sqrt(b * b + 1) - b;

						// workaround for floating point precision bug when sq = 0, log = -Infinite,
						// thus triggering an infinite loop in flyTo
						var log = sq < 0.000000001 ? -18 : Math.log(sq);

						return log;
					}

					function sinh(n) {
						return (Math.exp(n) - Math.exp(-n)) / 2;
					}
					function cosh(n) {
						return (Math.exp(n) + Math.exp(-n)) / 2;
					}
					function tanh(n) {
						return sinh(n) / cosh(n);
					}

					var r0 = r(0);

					function w(s) {
						return w0 * (cosh(r0) / cosh(r0 + rho * s));
					}
					function u(s) {
						return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
					}

					function easeOut(t) {
						return 1 - Math.pow(1 - t, 1.5);
					}

					var start = Date.now(),
					    S = (r(1) - r0) / rho,
					    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

					function frame() {
						var t = (Date.now() - start) / duration,
						    s = easeOut(t) * S;

						if (t <= 1) {
							this._flyToFrame = requestAnimFrame(frame, this);

							this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
						} else {
							this._move(targetCenter, targetZoom)._moveEnd(true);
						}
					}

					this._moveStart(true, options.noMoveStart);

					frame.call(this);
					return this;
				},

				// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
				// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
				// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
				flyToBounds: function flyToBounds(bounds, options) {
					var target = this._getBoundsCenterZoom(bounds, options);
					return this.flyTo(target.center, target.zoom, options);
				},

				// @method setMaxBounds(bounds: Bounds): this
				// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
				setMaxBounds: function setMaxBounds(bounds) {
					bounds = toLatLngBounds(bounds);

					if (!bounds.isValid()) {
						this.options.maxBounds = null;
						return this.off('moveend', this._panInsideMaxBounds);
					} else if (this.options.maxBounds) {
						this.off('moveend', this._panInsideMaxBounds);
					}

					this.options.maxBounds = bounds;

					if (this._loaded) {
						this._panInsideMaxBounds();
					}

					return this.on('moveend', this._panInsideMaxBounds);
				},

				// @method setMinZoom(zoom: Number): this
				// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
				setMinZoom: function setMinZoom(zoom) {
					var oldZoom = this.options.minZoom;
					this.options.minZoom = zoom;

					if (this._loaded && oldZoom !== zoom) {
						this.fire('zoomlevelschange');

						if (this.getZoom() < this.options.minZoom) {
							return this.setZoom(zoom);
						}
					}

					return this;
				},

				// @method setMaxZoom(zoom: Number): this
				// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
				setMaxZoom: function setMaxZoom(zoom) {
					var oldZoom = this.options.maxZoom;
					this.options.maxZoom = zoom;

					if (this._loaded && oldZoom !== zoom) {
						this.fire('zoomlevelschange');

						if (this.getZoom() > this.options.maxZoom) {
							return this.setZoom(zoom);
						}
					}

					return this;
				},

				// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
				// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
				panInsideBounds: function panInsideBounds(bounds, options) {
					this._enforcingBounds = true;
					var center = this.getCenter(),
					    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

					if (!center.equals(newCenter)) {
						this.panTo(newCenter, options);
					}

					this._enforcingBounds = false;
					return this;
				},

				// @method invalidateSize(options: Zoom/pan options): this
				// Checks if the map container size changed and updates the map if so —
				// call it after you've changed the map size dynamically, also animating
				// pan by default. If `options.pan` is `false`, panning will not occur.
				// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
				// that it doesn't happen often even if the method is called many
				// times in a row.

				// @alternative
				// @method invalidateSize(animate: Boolean): this
				// Checks if the map container size changed and updates the map if so —
				// call it after you've changed the map size dynamically, also animating
				// pan by default.
				invalidateSize: function invalidateSize(options) {
					if (!this._loaded) {
						return this;
					}

					options = extend({
						animate: false,
						pan: true
					}, options === true ? { animate: true } : options);

					var oldSize = this.getSize();
					this._sizeChanged = true;
					this._lastCenter = null;

					var newSize = this.getSize(),
					    oldCenter = oldSize.divideBy(2).round(),
					    newCenter = newSize.divideBy(2).round(),
					    offset = oldCenter.subtract(newCenter);

					if (!offset.x && !offset.y) {
						return this;
					}

					if (options.animate && options.pan) {
						this.panBy(offset);
					} else {
						if (options.pan) {
							this._rawPanBy(offset);
						}

						this.fire('move');

						if (options.debounceMoveend) {
							clearTimeout(this._sizeTimer);
							this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
						} else {
							this.fire('moveend');
						}
					}

					// @section Map state change events
					// @event resize: ResizeEvent
					// Fired when the map is resized.
					return this.fire('resize', {
						oldSize: oldSize,
						newSize: newSize
					});
				},

				// @section Methods for modifying map state
				// @method stop(): this
				// Stops the currently running `panTo` or `flyTo` animation, if any.
				stop: function stop() {
					this.setZoom(this._limitZoom(this._zoom));
					if (!this.options.zoomSnap) {
						this.fire('viewreset');
					}
					return this._stop();
				},

				// @section Geolocation methods
				// @method locate(options?: Locate options): this
				// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
				// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
				// and optionally sets the map view to the user's location with respect to
				// detection accuracy (or to the world view if geolocation failed).
				// Note that, if your page doesn't use HTTPS, this method will fail in
				// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
				// See `Locate options` for more details.
				locate: function locate(options) {

					options = this._locateOptions = extend({
						timeout: 10000,
						watch: false
						// setView: false
						// maxZoom: <Number>
						// maximumAge: 0
						// enableHighAccuracy: false
					}, options);

					if (!('geolocation' in navigator)) {
						this._handleGeolocationError({
							code: 0,
							message: 'Geolocation not supported.'
						});
						return this;
					}

					var onResponse = bind(this._handleGeolocationResponse, this),
					    onError = bind(this._handleGeolocationError, this);

					if (options.watch) {
						this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
					} else {
						navigator.geolocation.getCurrentPosition(onResponse, onError, options);
					}
					return this;
				},

				// @method stopLocate(): this
				// Stops watching location previously initiated by `map.locate({watch: true})`
				// and aborts resetting the map view if map.locate was called with
				// `{setView: true}`.
				stopLocate: function stopLocate() {
					if (navigator.geolocation && navigator.geolocation.clearWatch) {
						navigator.geolocation.clearWatch(this._locationWatchId);
					}
					if (this._locateOptions) {
						this._locateOptions.setView = false;
					}
					return this;
				},

				_handleGeolocationError: function _handleGeolocationError(error) {
					var c = error.code,
					    message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

					if (this._locateOptions.setView && !this._loaded) {
						this.fitWorld();
					}

					// @section Location events
					// @event locationerror: ErrorEvent
					// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
					this.fire('locationerror', {
						code: c,
						message: 'Geolocation error: ' + message + '.'
					});
				},

				_handleGeolocationResponse: function _handleGeolocationResponse(pos) {
					var lat = pos.coords.latitude,
					    lng = pos.coords.longitude,
					    latlng = new LatLng(lat, lng),
					    bounds = latlng.toBounds(pos.coords.accuracy * 2),
					    options = this._locateOptions;

					if (options.setView) {
						var zoom = this.getBoundsZoom(bounds);
						this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
					}

					var data = {
						latlng: latlng,
						bounds: bounds,
						timestamp: pos.timestamp
					};

					for (var i in pos.coords) {
						if (typeof pos.coords[i] === 'number') {
							data[i] = pos.coords[i];
						}
					}

					// @event locationfound: LocationEvent
					// Fired when geolocation (using the [`locate`](#map-locate) method)
					// went successfully.
					this.fire('locationfound', data);
				},

				// TODO Appropriate docs section?
				// @section Other Methods
				// @method addHandler(name: String, HandlerClass: Function): this
				// Adds a new `Handler` to the map, given its name and constructor function.
				addHandler: function addHandler(name, HandlerClass) {
					if (!HandlerClass) {
						return this;
					}

					var handler = this[name] = new HandlerClass(this);

					this._handlers.push(handler);

					if (this.options[name]) {
						handler.enable();
					}

					return this;
				},

				// @method remove(): this
				// Destroys the map and clears all related event listeners.
				remove: function remove() {

					this._initEvents(true);

					if (this._containerId !== this._container._leaflet_id) {
						throw new Error('Map container is being reused by another instance');
					}

					try {
						// throws error in IE6-8
						delete this._container._leaflet_id;
						delete this._containerId;
					} catch (e) {
						/*eslint-disable */
						this._container._leaflet_id = undefined;
						/* eslint-enable */
						this._containerId = undefined;
					}

					if (this._locationWatchId !== undefined) {
						this.stopLocate();
					}

					this._stop();

					_remove(this._mapPane);

					if (this._clearControlPos) {
						this._clearControlPos();
					}
					if (this._resizeRequest) {
						cancelAnimFrame(this._resizeRequest);
						this._resizeRequest = null;
					}

					this._clearHandlers();

					if (this._loaded) {
						// @section Map state change events
						// @event unload: Event
						// Fired when the map is destroyed with [remove](#map-remove) method.
						this.fire('unload');
					}

					var i;
					for (i in this._layers) {
						this._layers[i].remove();
					}
					for (i in this._panes) {
						_remove(this._panes[i]);
					}

					this._layers = [];
					this._panes = [];
					delete this._mapPane;
					delete this._renderer;

					return this;
				},

				// @section Other Methods
				// @method createPane(name: String, container?: HTMLElement): HTMLElement
				// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
				// then returns it. The pane is created as a child of `container`, or
				// as a child of the main map pane if not set.
				createPane: function createPane(name, container) {
					var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
					    pane = create$1('div', className, container || this._mapPane);

					if (name) {
						this._panes[name] = pane;
					}
					return pane;
				},

				// @section Methods for Getting Map State

				// @method getCenter(): LatLng
				// Returns the geographical center of the map view
				getCenter: function getCenter() {
					this._checkIfLoaded();

					if (this._lastCenter && !this._moved()) {
						return this._lastCenter;
					}
					return this.layerPointToLatLng(this._getCenterLayerPoint());
				},

				// @method getZoom(): Number
				// Returns the current zoom level of the map view
				getZoom: function getZoom() {
					return this._zoom;
				},

				// @method getBounds(): LatLngBounds
				// Returns the geographical bounds visible in the current map view
				getBounds: function getBounds() {
					var bounds = this.getPixelBounds(),
					    sw = this.unproject(bounds.getBottomLeft()),
					    ne = this.unproject(bounds.getTopRight());

					return new LatLngBounds(sw, ne);
				},

				// @method getMinZoom(): Number
				// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
				getMinZoom: function getMinZoom() {
					return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
				},

				// @method getMaxZoom(): Number
				// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
				getMaxZoom: function getMaxZoom() {
					return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
				},

				// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
				// Returns the maximum zoom level on which the given bounds fit to the map
				// view in its entirety. If `inside` (optional) is set to `true`, the method
				// instead returns the minimum zoom level on which the map view fits into
				// the given bounds in its entirety.
				getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
					// (LatLngBounds[, Boolean, Point]) -> Number
					bounds = toLatLngBounds(bounds);
					padding = toPoint(padding || [0, 0]);

					var zoom = this.getZoom() || 0,
					    min = this.getMinZoom(),
					    max = this.getMaxZoom(),
					    nw = bounds.getNorthWest(),
					    se = bounds.getSouthEast(),
					    size = this.getSize().subtract(padding),
					    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
					    snap = any3d ? this.options.zoomSnap : 1,
					    scalex = size.x / boundsSize.x,
					    scaley = size.y / boundsSize.y,
					    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

					zoom = this.getScaleZoom(scale, zoom);

					if (snap) {
						zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
						zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
					}

					return Math.max(min, Math.min(max, zoom));
				},

				// @method getSize(): Point
				// Returns the current size of the map container (in pixels).
				getSize: function getSize() {
					if (!this._size || this._sizeChanged) {
						this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);

						this._sizeChanged = false;
					}
					return this._size.clone();
				},

				// @method getPixelBounds(): Bounds
				// Returns the bounds of the current map view in projected pixel
				// coordinates (sometimes useful in layer and overlay implementations).
				getPixelBounds: function getPixelBounds(center, zoom) {
					var topLeftPoint = this._getTopLeftPoint(center, zoom);
					return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
				},

				// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
				// the map pane? "left point of the map layer" can be confusing, specially
				// since there can be negative offsets.
				// @method getPixelOrigin(): Point
				// Returns the projected pixel coordinates of the top left point of
				// the map layer (useful in custom layer and overlay implementations).
				getPixelOrigin: function getPixelOrigin() {
					this._checkIfLoaded();
					return this._pixelOrigin;
				},

				// @method getPixelWorldBounds(zoom?: Number): Bounds
				// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
				// If `zoom` is omitted, the map's current zoom level is used.
				getPixelWorldBounds: function getPixelWorldBounds(zoom) {
					return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
				},

				// @section Other Methods

				// @method getPane(pane: String|HTMLElement): HTMLElement
				// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
				getPane: function getPane(pane) {
					return typeof pane === 'string' ? this._panes[pane] : pane;
				},

				// @method getPanes(): Object
				// Returns a plain object containing the names of all [panes](#map-pane) as keys and
				// the panes as values.
				getPanes: function getPanes() {
					return this._panes;
				},

				// @method getContainer: HTMLElement
				// Returns the HTML element that contains the map.
				getContainer: function getContainer() {
					return this._container;
				},

				// @section Conversion Methods

				// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
				// Returns the scale factor to be applied to a map transition from zoom level
				// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
				getZoomScale: function getZoomScale(toZoom, fromZoom) {
					// TODO replace with universal implementation after refactoring projections
					var crs = this.options.crs;
					fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
					return crs.scale(toZoom) / crs.scale(fromZoom);
				},

				// @method getScaleZoom(scale: Number, fromZoom: Number): Number
				// Returns the zoom level that the map would end up at, if it is at `fromZoom`
				// level and everything is scaled by a factor of `scale`. Inverse of
				// [`getZoomScale`](#map-getZoomScale).
				getScaleZoom: function getScaleZoom(scale, fromZoom) {
					var crs = this.options.crs;
					fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
					var zoom = crs.zoom(scale * crs.scale(fromZoom));
					return isNaN(zoom) ? Infinity : zoom;
				},

				// @method project(latlng: LatLng, zoom: Number): Point
				// Projects a geographical coordinate `LatLng` according to the projection
				// of the map's CRS, then scales it according to `zoom` and the CRS's
				// `Transformation`. The result is pixel coordinate relative to
				// the CRS origin.
				project: function project(latlng, zoom) {
					zoom = zoom === undefined ? this._zoom : zoom;
					return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
				},

				// @method unproject(point: Point, zoom: Number): LatLng
				// Inverse of [`project`](#map-project).
				unproject: function unproject(point, zoom) {
					zoom = zoom === undefined ? this._zoom : zoom;
					return this.options.crs.pointToLatLng(toPoint(point), zoom);
				},

				// @method layerPointToLatLng(point: Point): LatLng
				// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
				// returns the corresponding geographical coordinate (for the current zoom level).
				layerPointToLatLng: function layerPointToLatLng(point) {
					var projectedPoint = toPoint(point).add(this.getPixelOrigin());
					return this.unproject(projectedPoint);
				},

				// @method latLngToLayerPoint(latlng: LatLng): Point
				// Given a geographical coordinate, returns the corresponding pixel coordinate
				// relative to the [origin pixel](#map-getpixelorigin).
				latLngToLayerPoint: function latLngToLayerPoint(latlng) {
					var projectedPoint = this.project(toLatLng(latlng))._round();
					return projectedPoint._subtract(this.getPixelOrigin());
				},

				// @method wrapLatLng(latlng: LatLng): LatLng
				// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
				// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
				// CRS's bounds.
				// By default this means longitude is wrapped around the dateline so its
				// value is between -180 and +180 degrees.
				wrapLatLng: function wrapLatLng(latlng) {
					return this.options.crs.wrapLatLng(toLatLng(latlng));
				},

				// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
				// Returns a `LatLngBounds` with the same size as the given one, ensuring that
				// its center is within the CRS's bounds.
				// By default this means the center longitude is wrapped around the dateline so its
				// value is between -180 and +180 degrees, and the majority of the bounds
				// overlaps the CRS's bounds.
				wrapLatLngBounds: function wrapLatLngBounds(latlng) {
					return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
				},

				// @method distance(latlng1: LatLng, latlng2: LatLng): Number
				// Returns the distance between two geographical coordinates according to
				// the map's CRS. By default this measures distance in meters.
				distance: function distance(latlng1, latlng2) {
					return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
				},

				// @method containerPointToLayerPoint(point: Point): Point
				// Given a pixel coordinate relative to the map container, returns the corresponding
				// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
				containerPointToLayerPoint: function containerPointToLayerPoint(point) {
					// (Point)
					return toPoint(point).subtract(this._getMapPanePos());
				},

				// @method layerPointToContainerPoint(point: Point): Point
				// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
				// returns the corresponding pixel coordinate relative to the map container.
				layerPointToContainerPoint: function layerPointToContainerPoint(point) {
					// (Point)
					return toPoint(point).add(this._getMapPanePos());
				},

				// @method containerPointToLatLng(point: Point): LatLng
				// Given a pixel coordinate relative to the map container, returns
				// the corresponding geographical coordinate (for the current zoom level).
				containerPointToLatLng: function containerPointToLatLng(point) {
					var layerPoint = this.containerPointToLayerPoint(toPoint(point));
					return this.layerPointToLatLng(layerPoint);
				},

				// @method latLngToContainerPoint(latlng: LatLng): Point
				// Given a geographical coordinate, returns the corresponding pixel coordinate
				// relative to the map container.
				latLngToContainerPoint: function latLngToContainerPoint(latlng) {
					return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
				},

				// @method mouseEventToContainerPoint(ev: MouseEvent): Point
				// Given a MouseEvent object, returns the pixel coordinate relative to the
				// map container where the event took place.
				mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
					return getMousePosition(e, this._container);
				},

				// @method mouseEventToLayerPoint(ev: MouseEvent): Point
				// Given a MouseEvent object, returns the pixel coordinate relative to
				// the [origin pixel](#map-getpixelorigin) where the event took place.
				mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
					return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
				},

				// @method mouseEventToLatLng(ev: MouseEvent): LatLng
				// Given a MouseEvent object, returns geographical coordinate where the
				// event took place.
				mouseEventToLatLng: function mouseEventToLatLng(e) {
					// (MouseEvent)
					return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
				},

				// map initialization methods

				_initContainer: function _initContainer(id) {
					var container = this._container = get(id);

					if (!container) {
						throw new Error('Map container not found.');
					} else if (container._leaflet_id) {
						throw new Error('Map container is already initialized.');
					}

					on(container, 'scroll', this._onScroll, this);
					this._containerId = stamp(container);
				},

				_initLayout: function _initLayout() {
					var container = this._container;

					this._fadeAnimated = this.options.fadeAnimation && any3d;

					addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

					var position = getStyle(container, 'position');

					if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
						container.style.position = 'relative';
					}

					this._initPanes();

					if (this._initControlPos) {
						this._initControlPos();
					}
				},

				_initPanes: function _initPanes() {
					var panes = this._panes = {};
					this._paneRenderers = {};

					// @section
					//
					// Panes are DOM elements used to control the ordering of layers on the map. You
					// can access panes with [`map.getPane`](#map-getpane) or
					// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
					// [`map.createPane`](#map-createpane) method.
					//
					// Every map has the following default panes that differ only in zIndex.
					//
					// @pane mapPane: HTMLElement = 'auto'
					// Pane that contains all other map panes

					this._mapPane = this.createPane('mapPane', this._container);
					setPosition(this._mapPane, new Point(0, 0));

					// @pane tilePane: HTMLElement = 200
					// Pane for `GridLayer`s and `TileLayer`s
					this.createPane('tilePane');
					// @pane overlayPane: HTMLElement = 400
					// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
					this.createPane('shadowPane');
					// @pane shadowPane: HTMLElement = 500
					// Pane for overlay shadows (e.g. `Marker` shadows)
					this.createPane('overlayPane');
					// @pane markerPane: HTMLElement = 600
					// Pane for `Icon`s of `Marker`s
					this.createPane('markerPane');
					// @pane tooltipPane: HTMLElement = 650
					// Pane for `Tooltip`s.
					this.createPane('tooltipPane');
					// @pane popupPane: HTMLElement = 700
					// Pane for `Popup`s.
					this.createPane('popupPane');

					if (!this.options.markerZoomAnimation) {
						addClass(panes.markerPane, 'leaflet-zoom-hide');
						addClass(panes.shadowPane, 'leaflet-zoom-hide');
					}
				},

				// private methods that modify map state

				// @section Map state change events
				_resetView: function _resetView(center, zoom) {
					setPosition(this._mapPane, new Point(0, 0));

					var loading = !this._loaded;
					this._loaded = true;
					zoom = this._limitZoom(zoom);

					this.fire('viewprereset');

					var zoomChanged = this._zoom !== zoom;
					this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged);

					// @event viewreset: Event
					// Fired when the map needs to redraw its content (this usually happens
					// on map zoom or load). Very useful for creating custom overlays.
					this.fire('viewreset');

					// @event load: Event
					// Fired when the map is initialized (when its center and zoom are set
					// for the first time).
					if (loading) {
						this.fire('load');
					}
				},

				_moveStart: function _moveStart(zoomChanged, noMoveStart) {
					// @event zoomstart: Event
					// Fired when the map zoom is about to change (e.g. before zoom animation).
					// @event movestart: Event
					// Fired when the view of the map starts changing (e.g. user starts dragging the map).
					if (zoomChanged) {
						this.fire('zoomstart');
					}
					if (!noMoveStart) {
						this.fire('movestart');
					}
					return this;
				},

				_move: function _move(center, zoom, data) {
					if (zoom === undefined) {
						zoom = this._zoom;
					}
					var zoomChanged = this._zoom !== zoom;

					this._zoom = zoom;
					this._lastCenter = center;
					this._pixelOrigin = this._getNewPixelOrigin(center);

					// @event zoom: Event
					// Fired repeatedly during any change in zoom level, including zoom
					// and fly animations.
					if (zoomChanged || data && data.pinch) {
						// Always fire 'zoom' if pinching because #3530
						this.fire('zoom', data);
					}

					// @event move: Event
					// Fired repeatedly during any movement of the map, including pan and
					// fly animations.
					return this.fire('move', data);
				},

				_moveEnd: function _moveEnd(zoomChanged) {
					// @event zoomend: Event
					// Fired when the map has changed, after any animations.
					if (zoomChanged) {
						this.fire('zoomend');
					}

					// @event moveend: Event
					// Fired when the center of the map stops changing (e.g. user stopped
					// dragging the map).
					return this.fire('moveend');
				},

				_stop: function _stop() {
					cancelAnimFrame(this._flyToFrame);
					if (this._panAnim) {
						this._panAnim.stop();
					}
					return this;
				},

				_rawPanBy: function _rawPanBy(offset) {
					setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
				},

				_getZoomSpan: function _getZoomSpan() {
					return this.getMaxZoom() - this.getMinZoom();
				},

				_panInsideMaxBounds: function _panInsideMaxBounds() {
					if (!this._enforcingBounds) {
						this.panInsideBounds(this.options.maxBounds);
					}
				},

				_checkIfLoaded: function _checkIfLoaded() {
					if (!this._loaded) {
						throw new Error('Set map center and zoom first.');
					}
				},

				// DOM event handling

				// @section Interaction events
				_initEvents: function _initEvents(remove$$1) {
					this._targets = {};
					this._targets[stamp(this._container)] = this;

					var onOff = remove$$1 ? off : on;

					// @event click: MouseEvent
					// Fired when the user clicks (or taps) the map.
					// @event dblclick: MouseEvent
					// Fired when the user double-clicks (or double-taps) the map.
					// @event mousedown: MouseEvent
					// Fired when the user pushes the mouse button on the map.
					// @event mouseup: MouseEvent
					// Fired when the user releases the mouse button on the map.
					// @event mouseover: MouseEvent
					// Fired when the mouse enters the map.
					// @event mouseout: MouseEvent
					// Fired when the mouse leaves the map.
					// @event mousemove: MouseEvent
					// Fired while the mouse moves over the map.
					// @event contextmenu: MouseEvent
					// Fired when the user pushes the right mouse button on the map, prevents
					// default browser context menu from showing if there are listeners on
					// this event. Also fired on mobile when the user holds a single touch
					// for a second (also called long press).
					// @event keypress: KeyboardEvent
					// Fired when the user presses a key from the keyboard while the map is focused.
					onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

					if (this.options.trackResize) {
						onOff(window, 'resize', this._onResize, this);
					}

					if (any3d && this.options.transform3DLimit) {
						(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
					}
				},

				_onResize: function _onResize() {
					cancelAnimFrame(this._resizeRequest);
					this._resizeRequest = requestAnimFrame(function () {
						this.invalidateSize({ debounceMoveend: true });
					}, this);
				},

				_onScroll: function _onScroll() {
					this._container.scrollTop = 0;
					this._container.scrollLeft = 0;
				},

				_onMoveEnd: function _onMoveEnd() {
					var pos = this._getMapPanePos();
					if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
						// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
						// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
						this._resetView(this.getCenter(), this.getZoom());
					}
				},

				_findEventTargets: function _findEventTargets(e, type) {
					var targets = [],
					    target,
					    isHover = type === 'mouseout' || type === 'mouseover',
					    src = e.target || e.srcElement,
					    dragging = false;

					while (src) {
						target = this._targets[stamp(src)];
						if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
							// Prevent firing click after you just dragged an object.
							dragging = true;
							break;
						}
						if (target && target.listens(type, true)) {
							if (isHover && !isExternalTarget(src, e)) {
								break;
							}
							targets.push(target);
							if (isHover) {
								break;
							}
						}
						if (src === this._container) {
							break;
						}
						src = src.parentNode;
					}
					if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
						targets = [this];
					}
					return targets;
				},

				_handleDOMEvent: function _handleDOMEvent(e) {
					if (!this._loaded || skipped(e)) {
						return;
					}

					var type = e.type;

					if (type === 'mousedown' || type === 'keypress') {
						// prevents outline when clicking on keyboard-focusable element
						preventOutline(e.target || e.srcElement);
					}

					this._fireDOMEvent(e, type);
				},

				_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

				_fireDOMEvent: function _fireDOMEvent(e, type, targets) {

					if (e.type === 'click') {
						// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
						// @event preclick: MouseEvent
						// Fired before mouse click on the map (sometimes useful when you
						// want something to happen on click before any existing click
						// handlers start running).
						var synth = extend({}, e);
						synth.type = 'preclick';
						this._fireDOMEvent(synth, synth.type, targets);
					}

					if (e._stopped) {
						return;
					}

					// Find the layer the event is propagating from and its parents.
					targets = (targets || []).concat(this._findEventTargets(e, type));

					if (!targets.length) {
						return;
					}

					var target = targets[0];
					if (type === 'contextmenu' && target.listens(type, true)) {
						preventDefault(e);
					}

					var data = {
						originalEvent: e
					};

					if (e.type !== 'keypress') {
						var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
						data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
						data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
						data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
					}

					for (var i = 0; i < targets.length; i++) {
						targets[i].fire(type, data, true);
						if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
							return;
						}
					}
				},

				_draggableMoved: function _draggableMoved(obj) {
					obj = obj.dragging && obj.dragging.enabled() ? obj : this;
					return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
				},

				_clearHandlers: function _clearHandlers() {
					for (var i = 0, len = this._handlers.length; i < len; i++) {
						this._handlers[i].disable();
					}
				},

				// @section Other Methods

				// @method whenReady(fn: Function, context?: Object): this
				// Runs the given function `fn` when the map gets initialized with
				// a view (center and zoom) and at least one layer, or immediately
				// if it's already initialized, optionally passing a function context.
				whenReady: function whenReady(callback, context) {
					if (this._loaded) {
						callback.call(context || this, { target: this });
					} else {
						this.on('load', callback, context);
					}
					return this;
				},

				// private methods for getting map state

				_getMapPanePos: function _getMapPanePos() {
					return getPosition(this._mapPane) || new Point(0, 0);
				},

				_moved: function _moved() {
					var pos = this._getMapPanePos();
					return pos && !pos.equals([0, 0]);
				},

				_getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
					var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
					return pixelOrigin.subtract(this._getMapPanePos());
				},

				_getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
					var viewHalf = this.getSize()._divideBy(2);
					return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
				},

				_latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
					var topLeft = this._getNewPixelOrigin(center, zoom);
					return this.project(latlng, zoom)._subtract(topLeft);
				},

				_latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
					var topLeft = this._getNewPixelOrigin(center, zoom);
					return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
				},

				// layer point of the current center
				_getCenterLayerPoint: function _getCenterLayerPoint() {
					return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
				},

				// offset of the specified place to the current center in pixels
				_getCenterOffset: function _getCenterOffset(latlng) {
					return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
				},

				// adjust center for view to get inside bounds
				_limitCenter: function _limitCenter(center, zoom, bounds) {

					if (!bounds) {
						return center;
					}

					var centerPoint = this.project(center, zoom),
					    viewHalf = this.getSize().divideBy(2),
					    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
					    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

					// If offset is less than a pixel, ignore.
					// This prevents unstable projections from getting into
					// an infinite loop of tiny offsets.
					if (offset.round().equals([0, 0])) {
						return center;
					}

					return this.unproject(centerPoint.add(offset), zoom);
				},

				// adjust offset for view to get inside bounds
				_limitOffset: function _limitOffset(offset, bounds) {
					if (!bounds) {
						return offset;
					}

					var viewBounds = this.getPixelBounds(),
					    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

					return offset.add(this._getBoundsOffset(newBounds, bounds));
				},

				// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
				_getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
					var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
					    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
					    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
					    dx = this._rebound(minOffset.x, -maxOffset.x),
					    dy = this._rebound(minOffset.y, -maxOffset.y);

					return new Point(dx, dy);
				},

				_rebound: function _rebound(left, right) {
					return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
				},

				_limitZoom: function _limitZoom(zoom) {
					var min = this.getMinZoom(),
					    max = this.getMaxZoom(),
					    snap = any3d ? this.options.zoomSnap : 1;
					if (snap) {
						zoom = Math.round(zoom / snap) * snap;
					}
					return Math.max(min, Math.min(max, zoom));
				},

				_onPanTransitionStep: function _onPanTransitionStep() {
					this.fire('move');
				},

				_onPanTransitionEnd: function _onPanTransitionEnd() {
					removeClass(this._mapPane, 'leaflet-pan-anim');
					this.fire('moveend');
				},

				_tryAnimatedPan: function _tryAnimatedPan(center, options) {
					// difference between the new and current centers in pixels
					var offset = this._getCenterOffset(center)._trunc();

					// don't animate too far unless animate: true specified in options
					if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
						return false;
					}

					this.panBy(offset, options);

					return true;
				},

				_createAnimProxy: function _createAnimProxy() {

					var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
					this._panes.mapPane.appendChild(proxy);

					this.on('zoomanim', function (e) {
						var prop = TRANSFORM,
						    transform = this._proxy.style[prop];

						setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

						// workaround for case when transform is the same and so transitionend event is not fired
						if (transform === this._proxy.style[prop] && this._animatingZoom) {
							this._onZoomTransitionEnd();
						}
					}, this);

					this.on('load moveend', function () {
						var c = this.getCenter(),
						    z = this.getZoom();
						setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
					}, this);

					this._on('unload', this._destroyAnimProxy, this);
				},

				_destroyAnimProxy: function _destroyAnimProxy() {
					_remove(this._proxy);
					delete this._proxy;
				},

				_catchTransitionEnd: function _catchTransitionEnd(e) {
					if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
						this._onZoomTransitionEnd();
					}
				},

				_nothingToAnimate: function _nothingToAnimate() {
					return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
				},

				_tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {

					if (this._animatingZoom) {
						return true;
					}

					options = options || {};

					// don't animate if disabled, not supported or zoom difference is too large
					if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
						return false;
					}

					// offset is the pixel coords of the zoom origin relative to the current center
					var scale = this.getZoomScale(zoom),
					    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

					// don't animate if the zoom origin isn't within one screen from the current center, unless forced
					if (options.animate !== true && !this.getSize().contains(offset)) {
						return false;
					}

					requestAnimFrame(function () {
						this._moveStart(true, false)._animateZoom(center, zoom, true);
					}, this);

					return true;
				},

				_animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
					if (!this._mapPane) {
						return;
					}

					if (startAnim) {
						this._animatingZoom = true;

						// remember what center/zoom to set after animation
						this._animateToCenter = center;
						this._animateToZoom = zoom;

						addClass(this._mapPane, 'leaflet-zoom-anim');
					}

					// @event zoomanim: ZoomAnimEvent
					// Fired on every frame of a zoom animation
					this.fire('zoomanim', {
						center: center,
						zoom: zoom,
						noUpdate: noUpdate
					});

					// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
					setTimeout(bind(this._onZoomTransitionEnd, this), 250);
				},

				_onZoomTransitionEnd: function _onZoomTransitionEnd() {
					if (!this._animatingZoom) {
						return;
					}

					if (this._mapPane) {
						removeClass(this._mapPane, 'leaflet-zoom-anim');
					}

					this._animatingZoom = false;

					this._move(this._animateToCenter, this._animateToZoom);

					// This anim frame should prevent an obscure iOS webkit tile loading race condition.
					requestAnimFrame(function () {
						this._moveEnd(true);
					}, this);
				}
			});

			// @section

			// @factory L.map(id: String, options?: Map options)
			// Instantiates a map object given the DOM ID of a `<div>` element
			// and optionally an object literal with `Map options`.
			//
			// @alternative
			// @factory L.map(el: HTMLElement, options?: Map options)
			// Instantiates a map object given an instance of a `<div>` HTML element
			// and optionally an object literal with `Map options`.
			function createMap(id, options) {
				return new Map(id, options);
			}

			/*
    * @class Control
    * @aka L.Control
    * @inherits Class
    *
    * L.Control is a base class for implementing map controls. Handles positioning.
    * All other controls extend from this class.
    */

			var Control = Class.extend({
				// @section
				// @aka Control options
				options: {
					// @option position: String = 'topright'
					// The position of the control (one of the map corners). Possible values are `'topleft'`,
					// `'topright'`, `'bottomleft'` or `'bottomright'`
					position: 'topright'
				},

				initialize: function initialize(options) {
					setOptions(this, options);
				},

				/* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
				getPosition: function getPosition() {
					return this.options.position;
				},

				// @method setPosition(position: string): this
				// Sets the position of the control.
				setPosition: function setPosition(position) {
					var map = this._map;

					if (map) {
						map.removeControl(this);
					}

					this.options.position = position;

					if (map) {
						map.addControl(this);
					}

					return this;
				},

				// @method getContainer: HTMLElement
				// Returns the HTMLElement that contains the control.
				getContainer: function getContainer() {
					return this._container;
				},

				// @method addTo(map: Map): this
				// Adds the control to the given map.
				addTo: function addTo(map) {
					this.remove();
					this._map = map;

					var container = this._container = this.onAdd(map),
					    pos = this.getPosition(),
					    corner = map._controlCorners[pos];

					addClass(container, 'leaflet-control');

					if (pos.indexOf('bottom') !== -1) {
						corner.insertBefore(container, corner.firstChild);
					} else {
						corner.appendChild(container);
					}

					return this;
				},

				// @method remove: this
				// Removes the control from the map it is currently active on.
				remove: function remove() {
					if (!this._map) {
						return this;
					}

					_remove(this._container);

					if (this.onRemove) {
						this.onRemove(this._map);
					}

					this._map = null;

					return this;
				},

				_refocusOnMap: function _refocusOnMap(e) {
					// if map exists and event is not a keyboard event
					if (this._map && e && e.screenX > 0 && e.screenY > 0) {
						this._map.getContainer().focus();
					}
				}
			});

			var control = function control(options) {
				return new Control(options);
			};

			/* @section Extension methods
    * @uninheritable
    *
    * Every control should extend from `L.Control` and (re-)implement the following methods.
    *
    * @method onAdd(map: Map): HTMLElement
    * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
    *
    * @method onRemove(map: Map)
    * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
    */

			/* @namespace Map
    * @section Methods for Layers and Controls
    */
			Map.include({
				// @method addControl(control: Control): this
				// Adds the given control to the map
				addControl: function addControl(control) {
					control.addTo(this);
					return this;
				},

				// @method removeControl(control: Control): this
				// Removes the given control from the map
				removeControl: function removeControl(control) {
					control.remove();
					return this;
				},

				_initControlPos: function _initControlPos() {
					var corners = this._controlCorners = {},
					    l = 'leaflet-',
					    container = this._controlContainer = create$1('div', l + 'control-container', this._container);

					function createCorner(vSide, hSide) {
						var className = l + vSide + ' ' + l + hSide;

						corners[vSide + hSide] = create$1('div', className, container);
					}

					createCorner('top', 'left');
					createCorner('top', 'right');
					createCorner('bottom', 'left');
					createCorner('bottom', 'right');
				},

				_clearControlPos: function _clearControlPos() {
					for (var i in this._controlCorners) {
						_remove(this._controlCorners[i]);
					}
					_remove(this._controlContainer);
					delete this._controlCorners;
					delete this._controlContainer;
				}
			});

			/*
    * @class Control.Layers
    * @aka L.Control.Layers
    * @inherits Control
    *
    * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
    *
    * @example
    *
    * ```js
    * var baseLayers = {
    * 	"Mapbox": mapbox,
    * 	"OpenStreetMap": osm
    * };
    *
    * var overlays = {
    * 	"Marker": marker,
    * 	"Roads": roadsLayer
    * };
    *
    * L.control.layers(baseLayers, overlays).addTo(map);
    * ```
    *
    * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
    *
    * ```js
    * {
    *     "<someName1>": layer1,
    *     "<someName2>": layer2
    * }
    * ```
    *
    * The layer names can contain HTML, which allows you to add additional styling to the items:
    *
    * ```js
    * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
    * ```
    */

			var Layers = Control.extend({
				// @section
				// @aka Control.Layers options
				options: {
					// @option collapsed: Boolean = true
					// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
					collapsed: true,
					position: 'topright',

					// @option autoZIndex: Boolean = true
					// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
					autoZIndex: true,

					// @option hideSingleBase: Boolean = false
					// If `true`, the base layers in the control will be hidden when there is only one.
					hideSingleBase: false,

					// @option sortLayers: Boolean = false
					// Whether to sort the layers. When `false`, layers will keep the order
					// in which they were added to the control.
					sortLayers: false,

					// @option sortFunction: Function = *
					// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
					// that will be used for sorting the layers, when `sortLayers` is `true`.
					// The function receives both the `L.Layer` instances and their names, as in
					// `sortFunction(layerA, layerB, nameA, nameB)`.
					// By default, it sorts layers alphabetically by their name.
					sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {
						return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
					}
				},

				initialize: function initialize(baseLayers, overlays, options) {
					setOptions(this, options);

					this._layerControlInputs = [];
					this._layers = [];
					this._lastZIndex = 0;
					this._handlingClick = false;

					for (var i in baseLayers) {
						this._addLayer(baseLayers[i], i);
					}

					for (i in overlays) {
						this._addLayer(overlays[i], i, true);
					}
				},

				onAdd: function onAdd(map) {
					this._initLayout();
					this._update();

					this._map = map;
					map.on('zoomend', this._checkDisabledLayers, this);

					for (var i = 0; i < this._layers.length; i++) {
						this._layers[i].layer.on('add remove', this._onLayerChange, this);
					}

					return this._container;
				},

				addTo: function addTo(map) {
					Control.prototype.addTo.call(this, map);
					// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
					return this._expandIfNotCollapsed();
				},

				onRemove: function onRemove() {
					this._map.off('zoomend', this._checkDisabledLayers, this);

					for (var i = 0; i < this._layers.length; i++) {
						this._layers[i].layer.off('add remove', this._onLayerChange, this);
					}
				},

				// @method addBaseLayer(layer: Layer, name: String): this
				// Adds a base layer (radio button entry) with the given name to the control.
				addBaseLayer: function addBaseLayer(layer, name) {
					this._addLayer(layer, name);
					return this._map ? this._update() : this;
				},

				// @method addOverlay(layer: Layer, name: String): this
				// Adds an overlay (checkbox entry) with the given name to the control.
				addOverlay: function addOverlay(layer, name) {
					this._addLayer(layer, name, true);
					return this._map ? this._update() : this;
				},

				// @method removeLayer(layer: Layer): this
				// Remove the given layer from the control.
				removeLayer: function removeLayer(layer) {
					layer.off('add remove', this._onLayerChange, this);

					var obj = this._getLayer(stamp(layer));
					if (obj) {
						this._layers.splice(this._layers.indexOf(obj), 1);
					}
					return this._map ? this._update() : this;
				},

				// @method expand(): this
				// Expand the control container if collapsed.
				expand: function expand() {
					addClass(this._container, 'leaflet-control-layers-expanded');
					this._form.style.height = null;
					var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
					if (acceptableHeight < this._form.clientHeight) {
						addClass(this._form, 'leaflet-control-layers-scrollbar');
						this._form.style.height = acceptableHeight + 'px';
					} else {
						removeClass(this._form, 'leaflet-control-layers-scrollbar');
					}
					this._checkDisabledLayers();
					return this;
				},

				// @method collapse(): this
				// Collapse the control container if expanded.
				collapse: function collapse() {
					removeClass(this._container, 'leaflet-control-layers-expanded');
					return this;
				},

				_initLayout: function _initLayout() {
					var className = 'leaflet-control-layers',
					    container = this._container = create$1('div', className),
					    collapsed = this.options.collapsed;

					// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
					container.setAttribute('aria-haspopup', true);

					disableClickPropagation(container);
					disableScrollPropagation(container);

					var form = this._form = create$1('form', className + '-list');

					if (collapsed) {
						this._map.on('click', this.collapse, this);

						if (!android) {
							on(container, {
								mouseenter: this.expand,
								mouseleave: this.collapse
							}, this);
						}
					}

					var link = this._layersLink = create$1('a', className + '-toggle', container);
					link.href = '#';
					link.title = 'Layers';

					if (touch) {
						on(link, 'click', stop);
						on(link, 'click', this.expand, this);
					} else {
						on(link, 'focus', this.expand, this);
					}

					if (!collapsed) {
						this.expand();
					}

					this._baseLayersList = create$1('div', className + '-base', form);
					this._separator = create$1('div', className + '-separator', form);
					this._overlaysList = create$1('div', className + '-overlays', form);

					container.appendChild(form);
				},

				_getLayer: function _getLayer(id) {
					for (var i = 0; i < this._layers.length; i++) {

						if (this._layers[i] && stamp(this._layers[i].layer) === id) {
							return this._layers[i];
						}
					}
				},

				_addLayer: function _addLayer(layer, name, overlay) {
					if (this._map) {
						layer.on('add remove', this._onLayerChange, this);
					}

					this._layers.push({
						layer: layer,
						name: name,
						overlay: overlay
					});

					if (this.options.sortLayers) {
						this._layers.sort(bind(function (a, b) {
							return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
						}, this));
					}

					if (this.options.autoZIndex && layer.setZIndex) {
						this._lastZIndex++;
						layer.setZIndex(this._lastZIndex);
					}

					this._expandIfNotCollapsed();
				},

				_update: function _update() {
					if (!this._container) {
						return this;
					}

					empty(this._baseLayersList);
					empty(this._overlaysList);

					this._layerControlInputs = [];
					var baseLayersPresent,
					    overlaysPresent,
					    i,
					    obj,
					    baseLayersCount = 0;

					for (i = 0; i < this._layers.length; i++) {
						obj = this._layers[i];
						this._addItem(obj);
						overlaysPresent = overlaysPresent || obj.overlay;
						baseLayersPresent = baseLayersPresent || !obj.overlay;
						baseLayersCount += !obj.overlay ? 1 : 0;
					}

					// Hide base layers section if there's only one layer.
					if (this.options.hideSingleBase) {
						baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
						this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
					}

					this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

					return this;
				},

				_onLayerChange: function _onLayerChange(e) {
					if (!this._handlingClick) {
						this._update();
					}

					var obj = this._getLayer(stamp(e.target));

					// @namespace Map
					// @section Layer events
					// @event baselayerchange: LayersControlEvent
					// Fired when the base layer is changed through the [layer control](#control-layers).
					// @event overlayadd: LayersControlEvent
					// Fired when an overlay is selected through the [layer control](#control-layers).
					// @event overlayremove: LayersControlEvent
					// Fired when an overlay is deselected through the [layer control](#control-layers).
					// @namespace Control.Layers
					var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

					if (type) {
						this._map.fire(type, obj);
					}
				},

				// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
				_createRadioElement: function _createRadioElement(name, checked) {

					var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';

					var radioFragment = document.createElement('div');
					radioFragment.innerHTML = radioHtml;

					return radioFragment.firstChild;
				},

				_addItem: function _addItem(obj) {
					var label = document.createElement('label'),
					    checked = this._map.hasLayer(obj.layer),
					    input;

					if (obj.overlay) {
						input = document.createElement('input');
						input.type = 'checkbox';
						input.className = 'leaflet-control-layers-selector';
						input.defaultChecked = checked;
					} else {
						input = this._createRadioElement('leaflet-base-layers', checked);
					}

					this._layerControlInputs.push(input);
					input.layerId = stamp(obj.layer);

					on(input, 'click', this._onInputClick, this);

					var name = document.createElement('span');
					name.innerHTML = ' ' + obj.name;

					// Helps from preventing layer control flicker when checkboxes are disabled
					// https://github.com/Leaflet/Leaflet/issues/2771
					var holder = document.createElement('div');

					label.appendChild(holder);
					holder.appendChild(input);
					holder.appendChild(name);

					var container = obj.overlay ? this._overlaysList : this._baseLayersList;
					container.appendChild(label);

					this._checkDisabledLayers();
					return label;
				},

				_onInputClick: function _onInputClick() {
					var inputs = this._layerControlInputs,
					    input,
					    layer;
					var addedLayers = [],
					    removedLayers = [];

					this._handlingClick = true;

					for (var i = inputs.length - 1; i >= 0; i--) {
						input = inputs[i];
						layer = this._getLayer(input.layerId).layer;

						if (input.checked) {
							addedLayers.push(layer);
						} else if (!input.checked) {
							removedLayers.push(layer);
						}
					}

					// Bugfix issue 2318: Should remove all old layers before readding new ones
					for (i = 0; i < removedLayers.length; i++) {
						if (this._map.hasLayer(removedLayers[i])) {
							this._map.removeLayer(removedLayers[i]);
						}
					}
					for (i = 0; i < addedLayers.length; i++) {
						if (!this._map.hasLayer(addedLayers[i])) {
							this._map.addLayer(addedLayers[i]);
						}
					}

					this._handlingClick = false;

					this._refocusOnMap();
				},

				_checkDisabledLayers: function _checkDisabledLayers() {
					var inputs = this._layerControlInputs,
					    input,
					    layer,
					    zoom = this._map.getZoom();

					for (var i = inputs.length - 1; i >= 0; i--) {
						input = inputs[i];
						layer = this._getLayer(input.layerId).layer;
						input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
					}
				},

				_expandIfNotCollapsed: function _expandIfNotCollapsed() {
					if (this._map && !this.options.collapsed) {
						this.expand();
					}
					return this;
				},

				_expand: function _expand() {
					// Backward compatibility, remove me in 1.1.
					return this.expand();
				},

				_collapse: function _collapse() {
					// Backward compatibility, remove me in 1.1.
					return this.collapse();
				}

			});

			// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
			// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
			var layers = function layers(baseLayers, overlays, options) {
				return new Layers(baseLayers, overlays, options);
			};

			/*
    * @class Control.Zoom
    * @aka L.Control.Zoom
    * @inherits Control
    *
    * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
    */

			var Zoom = Control.extend({
				// @section
				// @aka Control.Zoom options
				options: {
					position: 'topleft',

					// @option zoomInText: String = '+'
					// The text set on the 'zoom in' button.
					zoomInText: '+',

					// @option zoomInTitle: String = 'Zoom in'
					// The title set on the 'zoom in' button.
					zoomInTitle: 'Zoom in',

					// @option zoomOutText: String = '&#x2212;'
					// The text set on the 'zoom out' button.
					zoomOutText: '&#x2212;',

					// @option zoomOutTitle: String = 'Zoom out'
					// The title set on the 'zoom out' button.
					zoomOutTitle: 'Zoom out'
				},

				onAdd: function onAdd(map) {
					var zoomName = 'leaflet-control-zoom',
					    container = create$1('div', zoomName + ' leaflet-bar'),
					    options = this.options;

					this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
					this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

					this._updateDisabled();
					map.on('zoomend zoomlevelschange', this._updateDisabled, this);

					return container;
				},

				onRemove: function onRemove(map) {
					map.off('zoomend zoomlevelschange', this._updateDisabled, this);
				},

				disable: function disable() {
					this._disabled = true;
					this._updateDisabled();
					return this;
				},

				enable: function enable() {
					this._disabled = false;
					this._updateDisabled();
					return this;
				},

				_zoomIn: function _zoomIn(e) {
					if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
						this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
					}
				},

				_zoomOut: function _zoomOut(e) {
					if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
						this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
					}
				},

				_createButton: function _createButton(html, title, className, container, fn) {
					var link = create$1('a', className, container);
					link.innerHTML = html;
					link.href = '#';
					link.title = title;

					/*
      * Will force screen readers like VoiceOver to read this as "Zoom in - button"
      */
					link.setAttribute('role', 'button');
					link.setAttribute('aria-label', title);

					disableClickPropagation(link);
					on(link, 'click', stop);
					on(link, 'click', fn, this);
					on(link, 'click', this._refocusOnMap, this);

					return link;
				},

				_updateDisabled: function _updateDisabled() {
					var map = this._map,
					    className = 'leaflet-disabled';

					removeClass(this._zoomInButton, className);
					removeClass(this._zoomOutButton, className);

					if (this._disabled || map._zoom === map.getMinZoom()) {
						addClass(this._zoomOutButton, className);
					}
					if (this._disabled || map._zoom === map.getMaxZoom()) {
						addClass(this._zoomInButton, className);
					}
				}
			});

			// @namespace Map
			// @section Control options
			// @option zoomControl: Boolean = true
			// Whether a [zoom control](#control-zoom) is added to the map by default.
			Map.mergeOptions({
				zoomControl: true
			});

			Map.addInitHook(function () {
				if (this.options.zoomControl) {
					this.zoomControl = new Zoom();
					this.addControl(this.zoomControl);
				}
			});

			// @namespace Control.Zoom
			// @factory L.control.zoom(options: Control.Zoom options)
			// Creates a zoom control
			var zoom = function zoom(options) {
				return new Zoom(options);
			};

			/*
    * @class Control.Scale
    * @aka L.Control.Scale
    * @inherits Control
    *
    * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
    *
    * @example
    *
    * ```js
    * L.control.scale().addTo(map);
    * ```
    */

			var Scale = Control.extend({
				// @section
				// @aka Control.Scale options
				options: {
					position: 'bottomleft',

					// @option maxWidth: Number = 100
					// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
					maxWidth: 100,

					// @option metric: Boolean = True
					// Whether to show the metric scale line (m/km).
					metric: true,

					// @option imperial: Boolean = True
					// Whether to show the imperial scale line (mi/ft).
					imperial: true

					// @option updateWhenIdle: Boolean = false
					// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
				},

				onAdd: function onAdd(map) {
					var className = 'leaflet-control-scale',
					    container = create$1('div', className),
					    options = this.options;

					this._addScales(options, className + '-line', container);

					map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
					map.whenReady(this._update, this);

					return container;
				},

				onRemove: function onRemove(map) {
					map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
				},

				_addScales: function _addScales(options, className, container) {
					if (options.metric) {
						this._mScale = create$1('div', className, container);
					}
					if (options.imperial) {
						this._iScale = create$1('div', className, container);
					}
				},

				_update: function _update() {
					var map = this._map,
					    y = map.getSize().y / 2;

					var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

					this._updateScales(maxMeters);
				},

				_updateScales: function _updateScales(maxMeters) {
					if (this.options.metric && maxMeters) {
						this._updateMetric(maxMeters);
					}
					if (this.options.imperial && maxMeters) {
						this._updateImperial(maxMeters);
					}
				},

				_updateMetric: function _updateMetric(maxMeters) {
					var meters = this._getRoundNum(maxMeters),
					    label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

					this._updateScale(this._mScale, label, meters / maxMeters);
				},

				_updateImperial: function _updateImperial(maxMeters) {
					var maxFeet = maxMeters * 3.2808399,
					    maxMiles,
					    miles,
					    feet;

					if (maxFeet > 5280) {
						maxMiles = maxFeet / 5280;
						miles = this._getRoundNum(maxMiles);
						this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
					} else {
						feet = this._getRoundNum(maxFeet);
						this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
					}
				},

				_updateScale: function _updateScale(scale, text, ratio) {
					scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
					scale.innerHTML = text;
				},

				_getRoundNum: function _getRoundNum(num) {
					var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
					    d = num / pow10;

					d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

					return pow10 * d;
				}
			});

			// @factory L.control.scale(options?: Control.Scale options)
			// Creates an scale control with the given options.
			var scale = function scale(options) {
				return new Scale(options);
			};

			/*
    * @class Control.Attribution
    * @aka L.Control.Attribution
    * @inherits Control
    *
    * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
    */

			var Attribution = Control.extend({
				// @section
				// @aka Control.Attribution options
				options: {
					position: 'bottomright',

					// @option prefix: String = 'Leaflet'
					// The HTML text shown before the attributions. Pass `false` to disable.
					prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
				},

				initialize: function initialize(options) {
					setOptions(this, options);

					this._attributions = {};
				},

				onAdd: function onAdd(map) {
					map.attributionControl = this;
					this._container = create$1('div', 'leaflet-control-attribution');
					disableClickPropagation(this._container);

					// TODO ugly, refactor
					for (var i in map._layers) {
						if (map._layers[i].getAttribution) {
							this.addAttribution(map._layers[i].getAttribution());
						}
					}

					this._update();

					return this._container;
				},

				// @method setPrefix(prefix: String): this
				// Sets the text before the attributions.
				setPrefix: function setPrefix(prefix) {
					this.options.prefix = prefix;
					this._update();
					return this;
				},

				// @method addAttribution(text: String): this
				// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
				addAttribution: function addAttribution(text) {
					if (!text) {
						return this;
					}

					if (!this._attributions[text]) {
						this._attributions[text] = 0;
					}
					this._attributions[text]++;

					this._update();

					return this;
				},

				// @method removeAttribution(text: String): this
				// Removes an attribution text.
				removeAttribution: function removeAttribution(text) {
					if (!text) {
						return this;
					}

					if (this._attributions[text]) {
						this._attributions[text]--;
						this._update();
					}

					return this;
				},

				_update: function _update() {
					if (!this._map) {
						return;
					}

					var attribs = [];

					for (var i in this._attributions) {
						if (this._attributions[i]) {
							attribs.push(i);
						}
					}

					var prefixAndAttribs = [];

					if (this.options.prefix) {
						prefixAndAttribs.push(this.options.prefix);
					}
					if (attribs.length) {
						prefixAndAttribs.push(attribs.join(', '));
					}

					this._container.innerHTML = prefixAndAttribs.join(' | ');
				}
			});

			// @namespace Map
			// @section Control options
			// @option attributionControl: Boolean = true
			// Whether a [attribution control](#control-attribution) is added to the map by default.
			Map.mergeOptions({
				attributionControl: true
			});

			Map.addInitHook(function () {
				if (this.options.attributionControl) {
					new Attribution().addTo(this);
				}
			});

			// @namespace Control.Attribution
			// @factory L.control.attribution(options: Control.Attribution options)
			// Creates an attribution control.
			var attribution = function attribution(options) {
				return new Attribution(options);
			};

			Control.Layers = Layers;
			Control.Zoom = Zoom;
			Control.Scale = Scale;
			Control.Attribution = Attribution;

			control.layers = layers;
			control.zoom = zoom;
			control.scale = scale;
			control.attribution = attribution;

			/*
   	L.Handler is a base class for handler classes that are used internally to inject
   	interaction features like dragging to classes like Map and Marker.
   */

			// @class Handler
			// @aka L.Handler
			// Abstract class for map interaction handlers

			var Handler = Class.extend({
				initialize: function initialize(map) {
					this._map = map;
				},

				// @method enable(): this
				// Enables the handler
				enable: function enable() {
					if (this._enabled) {
						return this;
					}

					this._enabled = true;
					this.addHooks();
					return this;
				},

				// @method disable(): this
				// Disables the handler
				disable: function disable() {
					if (!this._enabled) {
						return this;
					}

					this._enabled = false;
					this.removeHooks();
					return this;
				},

				// @method enabled(): Boolean
				// Returns `true` if the handler is enabled
				enabled: function enabled() {
					return !!this._enabled;
				}

				// @section Extension methods
				// Classes inheriting from `Handler` must implement the two following methods:
				// @method addHooks()
				// Called when the handler is enabled, should add event hooks.
				// @method removeHooks()
				// Called when the handler is disabled, should remove the event hooks added previously.
			});

			// @section There is static function which can be called without instantiating L.Handler:
			// @function addTo(map: Map, name: String): this
			// Adds a new Handler to the given map with the given name.
			Handler.addTo = function (map, name) {
				map.addHandler(name, this);
				return this;
			};

			var Mixin = { Events: Events };

			/*
    * @class Draggable
    * @aka L.Draggable
    * @inherits Evented
    *
    * A class for making DOM elements draggable (including touch support).
    * Used internally for map and marker dragging. Only works for elements
    * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
    *
    * @example
    * ```js
    * var draggable = new L.Draggable(elementToDrag);
    * draggable.enable();
    * ```
    */

			var START = touch ? 'touchstart mousedown' : 'mousedown';
			var END = {
				mousedown: 'mouseup',
				touchstart: 'touchend',
				pointerdown: 'touchend',
				MSPointerDown: 'touchend'
			};
			var MOVE = {
				mousedown: 'mousemove',
				touchstart: 'touchmove',
				pointerdown: 'touchmove',
				MSPointerDown: 'touchmove'
			};

			var Draggable = Evented.extend({

				options: {
					// @section
					// @aka Draggable options
					// @option clickTolerance: Number = 3
					// The max number of pixels a user can shift the mouse pointer during a click
					// for it to be considered a valid click (as opposed to a mouse drag).
					clickTolerance: 3
				},

				// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
				// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
				initialize: function initialize(element, dragStartTarget, preventOutline$$1, options) {
					setOptions(this, options);

					this._element = element;
					this._dragStartTarget = dragStartTarget || element;
					this._preventOutline = preventOutline$$1;
				},

				// @method enable()
				// Enables the dragging ability
				enable: function enable() {
					if (this._enabled) {
						return;
					}

					on(this._dragStartTarget, START, this._onDown, this);

					this._enabled = true;
				},

				// @method disable()
				// Disables the dragging ability
				disable: function disable() {
					if (!this._enabled) {
						return;
					}

					// If we're currently dragging this draggable,
					// disabling it counts as first ending the drag.
					if (Draggable._dragging === this) {
						this.finishDrag();
					}

					off(this._dragStartTarget, START, this._onDown, this);

					this._enabled = false;
					this._moved = false;
				},

				_onDown: function _onDown(e) {
					// Ignore simulated events, since we handle both touch and
					// mouse explicitly; otherwise we risk getting duplicates of
					// touch events, see #4315.
					// Also ignore the event if disabled; this happens in IE11
					// under some circumstances, see #3666.
					if (e._simulated || !this._enabled) {
						return;
					}

					this._moved = false;

					if (hasClass(this._element, 'leaflet-zoom-anim')) {
						return;
					}

					if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
						return;
					}
					Draggable._dragging = this; // Prevent dragging multiple objects at once.

					if (this._preventOutline) {
						preventOutline(this._element);
					}

					disableImageDrag();
					disableTextSelection();

					if (this._moving) {
						return;
					}

					// @event down: Event
					// Fired when a drag is about to start.
					this.fire('down');

					var first = e.touches ? e.touches[0] : e,
					    sizedParent = getSizedParentNode(this._element);

					this._startPoint = new Point(first.clientX, first.clientY);

					// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
					this._parentScale = getScale(sizedParent);

					on(document, MOVE[e.type], this._onMove, this);
					on(document, END[e.type], this._onUp, this);
				},

				_onMove: function _onMove(e) {
					// Ignore simulated events, since we handle both touch and
					// mouse explicitly; otherwise we risk getting duplicates of
					// touch events, see #4315.
					// Also ignore the event if disabled; this happens in IE11
					// under some circumstances, see #3666.
					if (e._simulated || !this._enabled) {
						return;
					}

					if (e.touches && e.touches.length > 1) {
						this._moved = true;
						return;
					}

					var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
					    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

					if (!offset.x && !offset.y) {
						return;
					}
					if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
						return;
					}

					// We assume that the parent container's position, border and scale do not change for the duration of the drag.
					// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
					// and we can use the cached value for the scale.
					offset.x /= this._parentScale.x;
					offset.y /= this._parentScale.y;

					preventDefault(e);

					if (!this._moved) {
						// @event dragstart: Event
						// Fired when a drag starts
						this.fire('dragstart');

						this._moved = true;
						this._startPos = getPosition(this._element).subtract(offset);

						addClass(document.body, 'leaflet-dragging');

						this._lastTarget = e.target || e.srcElement;
						// IE and Edge do not give the <use> element, so fetch it
						// if necessary
						if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
							this._lastTarget = this._lastTarget.correspondingUseElement;
						}
						addClass(this._lastTarget, 'leaflet-drag-target');
					}

					this._newPos = this._startPos.add(offset);
					this._moving = true;

					cancelAnimFrame(this._animRequest);
					this._lastEvent = e;
					this._animRequest = requestAnimFrame(this._updatePosition, this, true);
				},

				_updatePosition: function _updatePosition() {
					var e = { originalEvent: this._lastEvent };

					// @event predrag: Event
					// Fired continuously during dragging *before* each corresponding
					// update of the element's position.
					this.fire('predrag', e);
					setPosition(this._element, this._newPos);

					// @event drag: Event
					// Fired continuously during dragging.
					this.fire('drag', e);
				},

				_onUp: function _onUp(e) {
					// Ignore simulated events, since we handle both touch and
					// mouse explicitly; otherwise we risk getting duplicates of
					// touch events, see #4315.
					// Also ignore the event if disabled; this happens in IE11
					// under some circumstances, see #3666.
					if (e._simulated || !this._enabled) {
						return;
					}
					this.finishDrag();
				},

				finishDrag: function finishDrag() {
					removeClass(document.body, 'leaflet-dragging');

					if (this._lastTarget) {
						removeClass(this._lastTarget, 'leaflet-drag-target');
						this._lastTarget = null;
					}

					for (var i in MOVE) {
						off(document, MOVE[i], this._onMove, this);
						off(document, END[i], this._onUp, this);
					}

					enableImageDrag();
					enableTextSelection();

					if (this._moved && this._moving) {
						// ensure drag is not fired after dragend
						cancelAnimFrame(this._animRequest);

						// @event dragend: DragEndEvent
						// Fired when the drag ends.
						this.fire('dragend', {
							distance: this._newPos.distanceTo(this._startPos)
						});
					}

					this._moving = false;
					Draggable._dragging = false;
				}

			});

			/*
    * @namespace LineUtil
    *
    * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
    */

			// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
			// Improves rendering performance dramatically by lessening the number of points to draw.

			// @function simplify(points: Point[], tolerance: Number): Point[]
			// Dramatically reduces the number of points in a polyline while retaining
			// its shape and returns a new array of simplified points, using the
			// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
			// Used for a huge performance boost when processing/displaying Leaflet polylines for
			// each zoom level and also reducing visual noise. tolerance affects the amount of
			// simplification (lesser value means higher quality but slower and with more points).
			// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
			function simplify(points, tolerance) {
				if (!tolerance || !points.length) {
					return points.slice();
				}

				var sqTolerance = tolerance * tolerance;

				// stage 1: vertex reduction
				points = _reducePoints(points, sqTolerance);

				// stage 2: Douglas-Peucker simplification
				points = _simplifyDP(points, sqTolerance);

				return points;
			}

			// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
			// Returns the distance between point `p` and segment `p1` to `p2`.
			function pointToSegmentDistance(p, p1, p2) {
				return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
			}

			// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
			// Returns the closest point from a point `p` on a segment `p1` to `p2`.
			function closestPointOnSegment(p, p1, p2) {
				return _sqClosestPointOnSegment(p, p1, p2);
			}

			// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
			function _simplifyDP(points, sqTolerance) {

				var len = points.length,
				    ArrayConstructor = (typeof Uint8Array === 'undefined' ? 'undefined' : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,
				    markers = new ArrayConstructor(len);

				markers[0] = markers[len - 1] = 1;

				_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

				var i,
				    newPoints = [];

				for (i = 0; i < len; i++) {
					if (markers[i]) {
						newPoints.push(points[i]);
					}
				}

				return newPoints;
			}

			function _simplifyDPStep(points, markers, sqTolerance, first, last) {

				var maxSqDist = 0,
				    index,
				    i,
				    sqDist;

				for (i = first + 1; i <= last - 1; i++) {
					sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

					if (sqDist > maxSqDist) {
						index = i;
						maxSqDist = sqDist;
					}
				}

				if (maxSqDist > sqTolerance) {
					markers[index] = 1;

					_simplifyDPStep(points, markers, sqTolerance, first, index);
					_simplifyDPStep(points, markers, sqTolerance, index, last);
				}
			}

			// reduce points that are too close to each other to a single point
			function _reducePoints(points, sqTolerance) {
				var reducedPoints = [points[0]];

				for (var i = 1, prev = 0, len = points.length; i < len; i++) {
					if (_sqDist(points[i], points[prev]) > sqTolerance) {
						reducedPoints.push(points[i]);
						prev = i;
					}
				}
				if (prev < len - 1) {
					reducedPoints.push(points[len - 1]);
				}
				return reducedPoints;
			}

			var _lastCode;

			// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
			// Clips the segment a to b by rectangular bounds with the
			// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
			// (modifying the segment points directly!). Used by Leaflet to only show polyline
			// points that are on the screen or near, increasing performance.
			function clipSegment(a, b, bounds, useLastCode, round) {
				var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
				    codeB = _getBitCode(b, bounds),
				    codeOut,
				    p,
				    newCode;

				// save 2nd code to avoid calculating it on the next segment
				_lastCode = codeB;

				while (true) {
					// if a,b is inside the clip window (trivial accept)
					if (!(codeA | codeB)) {
						return [a, b];
					}

					// if a,b is outside the clip window (trivial reject)
					if (codeA & codeB) {
						return false;
					}

					// other cases
					codeOut = codeA || codeB;
					p = _getEdgeIntersection(a, b, codeOut, bounds, round);
					newCode = _getBitCode(p, bounds);

					if (codeOut === codeA) {
						a = p;
						codeA = newCode;
					} else {
						b = p;
						codeB = newCode;
					}
				}
			}

			function _getEdgeIntersection(a, b, code, bounds, round) {
				var dx = b.x - a.x,
				    dy = b.y - a.y,
				    min = bounds.min,
				    max = bounds.max,
				    x,
				    y;

				if (code & 8) {
					// top
					x = a.x + dx * (max.y - a.y) / dy;
					y = max.y;
				} else if (code & 4) {
					// bottom
					x = a.x + dx * (min.y - a.y) / dy;
					y = min.y;
				} else if (code & 2) {
					// right
					x = max.x;
					y = a.y + dy * (max.x - a.x) / dx;
				} else if (code & 1) {
					// left
					x = min.x;
					y = a.y + dy * (min.x - a.x) / dx;
				}

				return new Point(x, y, round);
			}

			function _getBitCode(p, bounds) {
				var code = 0;

				if (p.x < bounds.min.x) {
					// left
					code |= 1;
				} else if (p.x > bounds.max.x) {
					// right
					code |= 2;
				}

				if (p.y < bounds.min.y) {
					// bottom
					code |= 4;
				} else if (p.y > bounds.max.y) {
					// top
					code |= 8;
				}

				return code;
			}

			// square distance (to avoid unnecessary Math.sqrt calls)
			function _sqDist(p1, p2) {
				var dx = p2.x - p1.x,
				    dy = p2.y - p1.y;
				return dx * dx + dy * dy;
			}

			// return closest point on segment or distance to that point
			function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
				var x = p1.x,
				    y = p1.y,
				    dx = p2.x - x,
				    dy = p2.y - y,
				    dot = dx * dx + dy * dy,
				    t;

				if (dot > 0) {
					t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

					if (t > 1) {
						x = p2.x;
						y = p2.y;
					} else if (t > 0) {
						x += dx * t;
						y += dy * t;
					}
				}

				dx = p.x - x;
				dy = p.y - y;

				return sqDist ? dx * dx + dy * dy : new Point(x, y);
			}

			// @function isFlat(latlngs: LatLng[]): Boolean
			// Returns true if `latlngs` is a flat array, false is nested.
			function isFlat(latlngs) {
				return !isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';
			}

			function _flat(latlngs) {
				console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
				return isFlat(latlngs);
			}

			var LineUtil = (Object.freeze || Object)({
				simplify: simplify,
				pointToSegmentDistance: pointToSegmentDistance,
				closestPointOnSegment: closestPointOnSegment,
				clipSegment: clipSegment,
				_getEdgeIntersection: _getEdgeIntersection,
				_getBitCode: _getBitCode,
				_sqClosestPointOnSegment: _sqClosestPointOnSegment,
				isFlat: isFlat,
				_flat: _flat
			});

			/*
    * @namespace PolyUtil
    * Various utility functions for polygon geometries.
    */

			/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
    * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
    * Used by Leaflet to only show polygon points that are on the screen or near, increasing
    * performance. Note that polygon points needs different algorithm for clipping
    * than polyline, so there's a separate method for it.
    */
			function clipPolygon(points, bounds, round) {
				var clippedPoints,
				    edges = [1, 4, 2, 8],
				    i,
				    j,
				    k,
				    a,
				    b,
				    len,
				    edge,
				    p;

				for (i = 0, len = points.length; i < len; i++) {
					points[i]._code = _getBitCode(points[i], bounds);
				}

				// for each edge (left, bottom, right, top)
				for (k = 0; k < 4; k++) {
					edge = edges[k];
					clippedPoints = [];

					for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
						a = points[i];
						b = points[j];

						// if a is inside the clip window
						if (!(a._code & edge)) {
							// if b is outside the clip window (a->b goes out of screen)
							if (b._code & edge) {
								p = _getEdgeIntersection(b, a, edge, bounds, round);
								p._code = _getBitCode(p, bounds);
								clippedPoints.push(p);
							}
							clippedPoints.push(a);

							// else if b is inside the clip window (a->b enters the screen)
						} else if (!(b._code & edge)) {
							p = _getEdgeIntersection(b, a, edge, bounds, round);
							p._code = _getBitCode(p, bounds);
							clippedPoints.push(p);
						}
					}
					points = clippedPoints;
				}

				return points;
			}

			var PolyUtil = (Object.freeze || Object)({
				clipPolygon: clipPolygon
			});

			/*
    * @namespace Projection
    * @section
    * Leaflet comes with a set of already defined Projections out of the box:
    *
    * @projection L.Projection.LonLat
    *
    * Equirectangular, or Plate Carree projection — the most simple projection,
    * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
    * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
    * `EPSG:4326` and `Simple` CRS.
    */

			var LonLat = {
				project: function project(latlng) {
					return new Point(latlng.lng, latlng.lat);
				},

				unproject: function unproject(point) {
					return new LatLng(point.y, point.x);
				},

				bounds: new Bounds([-180, -90], [180, 90])
			};

			/*
    * @namespace Projection
    * @projection L.Projection.Mercator
    *
    * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
    */

			var Mercator = {
				R: 6378137,
				R_MINOR: 6356752.314245179,

				bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

				project: function project(latlng) {
					var d = Math.PI / 180,
					    r = this.R,
					    y = latlng.lat * d,
					    tmp = this.R_MINOR / r,
					    e = Math.sqrt(1 - tmp * tmp),
					    con = e * Math.sin(y);

					var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
					y = -r * Math.log(Math.max(ts, 1E-10));

					return new Point(latlng.lng * d * r, y);
				},

				unproject: function unproject(point) {
					var d = 180 / Math.PI,
					    r = this.R,
					    tmp = this.R_MINOR / r,
					    e = Math.sqrt(1 - tmp * tmp),
					    ts = Math.exp(-point.y / r),
					    phi = Math.PI / 2 - 2 * Math.atan(ts);

					for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
						con = e * Math.sin(phi);
						con = Math.pow((1 - con) / (1 + con), e / 2);
						dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
						phi += dphi;
					}

					return new LatLng(phi * d, point.x * d / r);
				}
			};

			/*
    * @class Projection
   
    * An object with methods for projecting geographical coordinates of the world onto
    * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).
   
    * @property bounds: Bounds
    * The bounds (specified in CRS units) where the projection is valid
   
    * @method project(latlng: LatLng): Point
    * Projects geographical coordinates into a 2D point.
    * Only accepts actual `L.LatLng` instances, not arrays.
   
    * @method unproject(point: Point): LatLng
    * The inverse of `project`. Projects a 2D point into a geographical location.
    * Only accepts actual `L.Point` instances, not arrays.
   
    * Note that the projection instances do not inherit from Leafet's `Class` object,
    * and can't be instantiated. Also, new classes can't inherit from them,
    * and methods can't be added to them with the `include` function.
   
    */

			var index = (Object.freeze || Object)({
				LonLat: LonLat,
				Mercator: Mercator,
				SphericalMercator: SphericalMercator
			});

			/*
    * @namespace CRS
    * @crs L.CRS.EPSG3395
    *
    * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
    */
			var EPSG3395 = extend({}, Earth, {
				code: 'EPSG:3395',
				projection: Mercator,

				transformation: function () {
					var scale = 0.5 / (Math.PI * Mercator.R);
					return toTransformation(scale, 0.5, -scale, 0.5);
				}()
			});

			/*
    * @namespace CRS
    * @crs L.CRS.EPSG4326
    *
    * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
    *
    * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
    * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
    * with this CRS, ensure that there are two 256x256 pixel tiles covering the
    * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
    * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
    */

			var EPSG4326 = extend({}, Earth, {
				code: 'EPSG:4326',
				projection: LonLat,
				transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
			});

			/*
    * @namespace CRS
    * @crs L.CRS.Simple
    *
    * A simple CRS that maps longitude and latitude into `x` and `y` directly.
    * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
    * axis should still be inverted (going from bottom to top). `distance()` returns
    * simple euclidean distance.
    */

			var Simple = extend({}, CRS, {
				projection: LonLat,
				transformation: toTransformation(1, 0, -1, 0),

				scale: function scale(zoom) {
					return Math.pow(2, zoom);
				},

				zoom: function zoom(scale) {
					return Math.log(scale) / Math.LN2;
				},

				distance: function distance(latlng1, latlng2) {
					var dx = latlng2.lng - latlng1.lng,
					    dy = latlng2.lat - latlng1.lat;

					return Math.sqrt(dx * dx + dy * dy);
				},

				infinite: true
			});

			CRS.Earth = Earth;
			CRS.EPSG3395 = EPSG3395;
			CRS.EPSG3857 = EPSG3857;
			CRS.EPSG900913 = EPSG900913;
			CRS.EPSG4326 = EPSG4326;
			CRS.Simple = Simple;

			/*
    * @class Layer
    * @inherits Evented
    * @aka L.Layer
    * @aka ILayer
    *
    * A set of methods from the Layer base class that all Leaflet layers use.
    * Inherits all methods, options and events from `L.Evented`.
    *
    * @example
    *
    * ```js
    * var layer = L.Marker(latlng).addTo(map);
    * layer.addTo(map);
    * layer.remove();
    * ```
    *
    * @event add: Event
    * Fired after the layer is added to a map
    *
    * @event remove: Event
    * Fired after the layer is removed from a map
    */

			var Layer = Evented.extend({

				// Classes extending `L.Layer` will inherit the following options:
				options: {
					// @option pane: String = 'overlayPane'
					// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
					pane: 'overlayPane',

					// @option attribution: String = null
					// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
					attribution: null,

					bubblingMouseEvents: true
				},

				/* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
				addTo: function addTo(map) {
					map.addLayer(this);
					return this;
				},

				// @method remove: this
				// Removes the layer from the map it is currently active on.
				remove: function remove() {
					return this.removeFrom(this._map || this._mapToAdd);
				},

				// @method removeFrom(map: Map): this
				// Removes the layer from the given map
				removeFrom: function removeFrom(obj) {
					if (obj) {
						obj.removeLayer(this);
					}
					return this;
				},

				// @method getPane(name? : String): HTMLElement
				// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
				getPane: function getPane(name) {
					return this._map.getPane(name ? this.options[name] || name : this.options.pane);
				},

				addInteractiveTarget: function addInteractiveTarget(targetEl) {
					this._map._targets[stamp(targetEl)] = this;
					return this;
				},

				removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
					delete this._map._targets[stamp(targetEl)];
					return this;
				},

				// @method getAttribution: String
				// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
				getAttribution: function getAttribution() {
					return this.options.attribution;
				},

				_layerAdd: function _layerAdd(e) {
					var map = e.target;

					// check in case layer gets added and then removed before the map is ready
					if (!map.hasLayer(this)) {
						return;
					}

					this._map = map;
					this._zoomAnimated = map._zoomAnimated;

					if (this.getEvents) {
						var events = this.getEvents();
						map.on(events, this);
						this.once('remove', function () {
							map.off(events, this);
						}, this);
					}

					this.onAdd(map);

					if (this.getAttribution && map.attributionControl) {
						map.attributionControl.addAttribution(this.getAttribution());
					}

					this.fire('add');
					map.fire('layeradd', { layer: this });
				}
			});

			/* @section Extension methods
    * @uninheritable
    *
    * Every layer should extend from `L.Layer` and (re-)implement the following methods.
    *
    * @method onAdd(map: Map): this
    * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
    *
    * @method onRemove(map: Map): this
    * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
    *
    * @method getEvents(): Object
    * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
    *
    * @method getAttribution(): String
    * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
    *
    * @method beforeAdd(map: Map): this
    * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
    */

			/* @namespace Map
    * @section Layer events
    *
    * @event layeradd: LayerEvent
    * Fired when a new layer is added to the map.
    *
    * @event layerremove: LayerEvent
    * Fired when some layer is removed from the map
    *
    * @section Methods for Layers and Controls
    */
			Map.include({
				// @method addLayer(layer: Layer): this
				// Adds the given layer to the map
				addLayer: function addLayer(layer) {
					if (!layer._layerAdd) {
						throw new Error('The provided object is not a Layer.');
					}

					var id = stamp(layer);
					if (this._layers[id]) {
						return this;
					}
					this._layers[id] = layer;

					layer._mapToAdd = this;

					if (layer.beforeAdd) {
						layer.beforeAdd(this);
					}

					this.whenReady(layer._layerAdd, layer);

					return this;
				},

				// @method removeLayer(layer: Layer): this
				// Removes the given layer from the map.
				removeLayer: function removeLayer(layer) {
					var id = stamp(layer);

					if (!this._layers[id]) {
						return this;
					}

					if (this._loaded) {
						layer.onRemove(this);
					}

					if (layer.getAttribution && this.attributionControl) {
						this.attributionControl.removeAttribution(layer.getAttribution());
					}

					delete this._layers[id];

					if (this._loaded) {
						this.fire('layerremove', { layer: layer });
						layer.fire('remove');
					}

					layer._map = layer._mapToAdd = null;

					return this;
				},

				// @method hasLayer(layer: Layer): Boolean
				// Returns `true` if the given layer is currently added to the map
				hasLayer: function hasLayer(layer) {
					return !!layer && stamp(layer) in this._layers;
				},

				/* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
				eachLayer: function eachLayer(method, context) {
					for (var i in this._layers) {
						method.call(context, this._layers[i]);
					}
					return this;
				},

				_addLayers: function _addLayers(layers) {
					layers = layers ? isArray(layers) ? layers : [layers] : [];

					for (var i = 0, len = layers.length; i < len; i++) {
						this.addLayer(layers[i]);
					}
				},

				_addZoomLimit: function _addZoomLimit(layer) {
					if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
						this._zoomBoundLayers[stamp(layer)] = layer;
						this._updateZoomLevels();
					}
				},

				_removeZoomLimit: function _removeZoomLimit(layer) {
					var id = stamp(layer);

					if (this._zoomBoundLayers[id]) {
						delete this._zoomBoundLayers[id];
						this._updateZoomLevels();
					}
				},

				_updateZoomLevels: function _updateZoomLevels() {
					var minZoom = Infinity,
					    maxZoom = -Infinity,
					    oldZoomSpan = this._getZoomSpan();

					for (var i in this._zoomBoundLayers) {
						var options = this._zoomBoundLayers[i].options;

						minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
						maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
					}

					this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
					this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

					// @section Map state change events
					// @event zoomlevelschange: Event
					// Fired when the number of zoomlevels on the map is changed due
					// to adding or removing a layer.
					if (oldZoomSpan !== this._getZoomSpan()) {
						this.fire('zoomlevelschange');
					}

					if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
						this.setZoom(this._layersMaxZoom);
					}
					if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
						this.setZoom(this._layersMinZoom);
					}
				}
			});

			/*
    * @class LayerGroup
    * @aka L.LayerGroup
    * @inherits Layer
    *
    * Used to group several layers and handle them as one. If you add it to the map,
    * any layers added or removed from the group will be added/removed on the map as
    * well. Extends `Layer`.
    *
    * @example
    *
    * ```js
    * L.layerGroup([marker1, marker2])
    * 	.addLayer(polyline)
    * 	.addTo(map);
    * ```
    */

			var LayerGroup = Layer.extend({

				initialize: function initialize(layers, options) {
					setOptions(this, options);

					this._layers = {};

					var i, len;

					if (layers) {
						for (i = 0, len = layers.length; i < len; i++) {
							this.addLayer(layers[i]);
						}
					}
				},

				// @method addLayer(layer: Layer): this
				// Adds the given layer to the group.
				addLayer: function addLayer(layer) {
					var id = this.getLayerId(layer);

					this._layers[id] = layer;

					if (this._map) {
						this._map.addLayer(layer);
					}

					return this;
				},

				// @method removeLayer(layer: Layer): this
				// Removes the given layer from the group.
				// @alternative
				// @method removeLayer(id: Number): this
				// Removes the layer with the given internal ID from the group.
				removeLayer: function removeLayer(layer) {
					var id = layer in this._layers ? layer : this.getLayerId(layer);

					if (this._map && this._layers[id]) {
						this._map.removeLayer(this._layers[id]);
					}

					delete this._layers[id];

					return this;
				},

				// @method hasLayer(layer: Layer): Boolean
				// Returns `true` if the given layer is currently added to the group.
				// @alternative
				// @method hasLayer(id: Number): Boolean
				// Returns `true` if the given internal ID is currently added to the group.
				hasLayer: function hasLayer(layer) {
					return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
				},

				// @method clearLayers(): this
				// Removes all the layers from the group.
				clearLayers: function clearLayers() {
					return this.eachLayer(this.removeLayer, this);
				},

				// @method invoke(methodName: String, …): this
				// Calls `methodName` on every layer contained in this group, passing any
				// additional parameters. Has no effect if the layers contained do not
				// implement `methodName`.
				invoke: function invoke(methodName) {
					var args = Array.prototype.slice.call(arguments, 1),
					    i,
					    layer;

					for (i in this._layers) {
						layer = this._layers[i];

						if (layer[methodName]) {
							layer[methodName].apply(layer, args);
						}
					}

					return this;
				},

				onAdd: function onAdd(map) {
					this.eachLayer(map.addLayer, map);
				},

				onRemove: function onRemove(map) {
					this.eachLayer(map.removeLayer, map);
				},

				// @method eachLayer(fn: Function, context?: Object): this
				// Iterates over the layers of the group, optionally specifying context of the iterator function.
				// ```js
				// group.eachLayer(function (layer) {
				// 	layer.bindPopup('Hello');
				// });
				// ```
				eachLayer: function eachLayer(method, context) {
					for (var i in this._layers) {
						method.call(context, this._layers[i]);
					}
					return this;
				},

				// @method getLayer(id: Number): Layer
				// Returns the layer with the given internal ID.
				getLayer: function getLayer(id) {
					return this._layers[id];
				},

				// @method getLayers(): Layer[]
				// Returns an array of all the layers added to the group.
				getLayers: function getLayers() {
					var layers = [];
					this.eachLayer(layers.push, layers);
					return layers;
				},

				// @method setZIndex(zIndex: Number): this
				// Calls `setZIndex` on every layer contained in this group, passing the z-index.
				setZIndex: function setZIndex(zIndex) {
					return this.invoke('setZIndex', zIndex);
				},

				// @method getLayerId(layer: Layer): Number
				// Returns the internal ID for a layer
				getLayerId: function getLayerId(layer) {
					return stamp(layer);
				}
			});

			// @factory L.layerGroup(layers?: Layer[], options?: Object)
			// Create a layer group, optionally given an initial set of layers and an `options` object.
			var layerGroup = function layerGroup(layers, options) {
				return new LayerGroup(layers, options);
			};

			/*
    * @class FeatureGroup
    * @aka L.FeatureGroup
    * @inherits LayerGroup
    *
    * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
    *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
    *  * Events are propagated to the `FeatureGroup`, so if the group has an event
    * handler, it will handle events from any of the layers. This includes mouse events
    * and custom events.
    *  * Has `layeradd` and `layerremove` events
    *
    * @example
    *
    * ```js
    * L.featureGroup([marker1, marker2, polyline])
    * 	.bindPopup('Hello world!')
    * 	.on('click', function() { alert('Clicked on a member of the group!'); })
    * 	.addTo(map);
    * ```
    */

			var FeatureGroup = LayerGroup.extend({

				addLayer: function addLayer(layer) {
					if (this.hasLayer(layer)) {
						return this;
					}

					layer.addEventParent(this);

					LayerGroup.prototype.addLayer.call(this, layer);

					// @event layeradd: LayerEvent
					// Fired when a layer is added to this `FeatureGroup`
					return this.fire('layeradd', { layer: layer });
				},

				removeLayer: function removeLayer(layer) {
					if (!this.hasLayer(layer)) {
						return this;
					}
					if (layer in this._layers) {
						layer = this._layers[layer];
					}

					layer.removeEventParent(this);

					LayerGroup.prototype.removeLayer.call(this, layer);

					// @event layerremove: LayerEvent
					// Fired when a layer is removed from this `FeatureGroup`
					return this.fire('layerremove', { layer: layer });
				},

				// @method setStyle(style: Path options): this
				// Sets the given path options to each layer of the group that has a `setStyle` method.
				setStyle: function setStyle(style) {
					return this.invoke('setStyle', style);
				},

				// @method bringToFront(): this
				// Brings the layer group to the top of all other layers
				bringToFront: function bringToFront() {
					return this.invoke('bringToFront');
				},

				// @method bringToBack(): this
				// Brings the layer group to the back of all other layers
				bringToBack: function bringToBack() {
					return this.invoke('bringToBack');
				},

				// @method getBounds(): LatLngBounds
				// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
				getBounds: function getBounds() {
					var bounds = new LatLngBounds();

					for (var id in this._layers) {
						var layer = this._layers[id];
						bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
					}
					return bounds;
				}
			});

			// @factory L.featureGroup(layers: Layer[])
			// Create a feature group, optionally given an initial set of layers.
			var featureGroup = function featureGroup(layers) {
				return new FeatureGroup(layers);
			};

			/*
    * @class Icon
    * @aka L.Icon
    *
    * Represents an icon to provide when creating a marker.
    *
    * @example
    *
    * ```js
    * var myIcon = L.icon({
    *     iconUrl: 'my-icon.png',
    *     iconRetinaUrl: 'my-icon@2x.png',
    *     iconSize: [38, 95],
    *     iconAnchor: [22, 94],
    *     popupAnchor: [-3, -76],
    *     shadowUrl: 'my-icon-shadow.png',
    *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
    *     shadowSize: [68, 95],
    *     shadowAnchor: [22, 94]
    * });
    *
    * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
    * ```
    *
    * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
    *
    */

			var Icon = Class.extend({

				/* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */

				options: {
					popupAnchor: [0, 0],
					tooltipAnchor: [0, 0]
				},

				initialize: function initialize(options) {
					setOptions(this, options);
				},

				// @method createIcon(oldIcon?: HTMLElement): HTMLElement
				// Called internally when the icon has to be shown, returns a `<img>` HTML element
				// styled according to the options.
				createIcon: function createIcon(oldIcon) {
					return this._createIcon('icon', oldIcon);
				},

				// @method createShadow(oldIcon?: HTMLElement): HTMLElement
				// As `createIcon`, but for the shadow beneath it.
				createShadow: function createShadow(oldIcon) {
					return this._createIcon('shadow', oldIcon);
				},

				_createIcon: function _createIcon(name, oldIcon) {
					var src = this._getIconUrl(name);

					if (!src) {
						if (name === 'icon') {
							throw new Error('iconUrl not set in Icon options (see the docs).');
						}
						return null;
					}

					var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
					this._setIconStyles(img, name);

					return img;
				},

				_setIconStyles: function _setIconStyles(img, name) {
					var options = this.options;
					var sizeOption = options[name + 'Size'];

					if (typeof sizeOption === 'number') {
						sizeOption = [sizeOption, sizeOption];
					}

					var size = toPoint(sizeOption),
					    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));

					img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

					if (anchor) {
						img.style.marginLeft = -anchor.x + 'px';
						img.style.marginTop = -anchor.y + 'px';
					}

					if (size) {
						img.style.width = size.x + 'px';
						img.style.height = size.y + 'px';
					}
				},

				_createImg: function _createImg(src, el) {
					el = el || document.createElement('img');
					el.src = src;
					return el;
				},

				_getIconUrl: function _getIconUrl(name) {
					return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
				}
			});

			// @factory L.icon(options: Icon options)
			// Creates an icon instance with the given options.
			function icon(options) {
				return new Icon(options);
			}

			/*
    * @miniclass Icon.Default (Icon)
    * @aka L.Icon.Default
    * @section
    *
    * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
    * no icon is specified. Points to the blue marker image distributed with Leaflet
    * releases.
    *
    * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
    * (which is a set of `Icon options`).
    *
    * If you want to _completely_ replace the default icon, override the
    * `L.Marker.prototype.options.icon` with your own icon instead.
    */

			var IconDefault = Icon.extend({

				options: {
					iconUrl: 'marker-icon.png',
					iconRetinaUrl: 'marker-icon-2x.png',
					shadowUrl: 'marker-shadow.png',
					iconSize: [25, 41],
					iconAnchor: [12, 41],
					popupAnchor: [1, -34],
					tooltipAnchor: [16, -28],
					shadowSize: [41, 41]
				},

				_getIconUrl: function _getIconUrl(name) {
					if (!IconDefault.imagePath) {
						// Deprecated, backwards-compatibility only
						IconDefault.imagePath = this._detectIconPath();
					}

					// @option imagePath: String
					// `Icon.Default` will try to auto-detect the location of the
					// blue icon images. If you are placing these images in a non-standard
					// way, set this option to point to the right path.
					return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
				},

				_detectIconPath: function _detectIconPath() {
					var el = create$1('div', 'leaflet-default-icon-path', document.body);
					var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

					document.body.removeChild(el);

					if (path === null || path.indexOf('url') !== 0) {
						path = '';
					} else {
						path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
					}

					return path;
				}
			});

			/*
    * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
    */

			/* @namespace Marker
    * @section Interaction handlers
    *
    * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
    *
    * ```js
    * marker.dragging.disable();
    * ```
    *
    * @property dragging: Handler
    * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
    */

			var MarkerDrag = Handler.extend({
				initialize: function initialize(marker) {
					this._marker = marker;
				},

				addHooks: function addHooks() {
					var icon = this._marker._icon;

					if (!this._draggable) {
						this._draggable = new Draggable(icon, icon, true);
					}

					this._draggable.on({
						dragstart: this._onDragStart,
						predrag: this._onPreDrag,
						drag: this._onDrag,
						dragend: this._onDragEnd
					}, this).enable();

					addClass(icon, 'leaflet-marker-draggable');
				},

				removeHooks: function removeHooks() {
					this._draggable.off({
						dragstart: this._onDragStart,
						predrag: this._onPreDrag,
						drag: this._onDrag,
						dragend: this._onDragEnd
					}, this).disable();

					if (this._marker._icon) {
						removeClass(this._marker._icon, 'leaflet-marker-draggable');
					}
				},

				moved: function moved() {
					return this._draggable && this._draggable._moved;
				},

				_adjustPan: function _adjustPan(e) {
					var marker = this._marker,
					    map = marker._map,
					    speed = this._marker.options.autoPanSpeed,
					    padding = this._marker.options.autoPanPadding,
					    iconPos = getPosition(marker._icon),
					    bounds = map.getPixelBounds(),
					    origin = map.getPixelOrigin();

					var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));

					if (!panBounds.contains(iconPos)) {
						// Compute incremental movement
						var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);

						map.panBy(movement, { animate: false });

						this._draggable._newPos._add(movement);
						this._draggable._startPos._add(movement);

						setPosition(marker._icon, this._draggable._newPos);
						this._onDrag(e);

						this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
					}
				},

				_onDragStart: function _onDragStart() {
					// @section Dragging events
					// @event dragstart: Event
					// Fired when the user starts dragging the marker.

					// @event movestart: Event
					// Fired when the marker starts moving (because of dragging).

					this._oldLatLng = this._marker.getLatLng();
					this._marker.closePopup().fire('movestart').fire('dragstart');
				},

				_onPreDrag: function _onPreDrag(e) {
					if (this._marker.options.autoPan) {
						cancelAnimFrame(this._panRequest);
						this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
					}
				},

				_onDrag: function _onDrag(e) {
					var marker = this._marker,
					    shadow = marker._shadow,
					    iconPos = getPosition(marker._icon),
					    latlng = marker._map.layerPointToLatLng(iconPos);

					// update shadow position
					if (shadow) {
						setPosition(shadow, iconPos);
					}

					marker._latlng = latlng;
					e.latlng = latlng;
					e.oldLatLng = this._oldLatLng;

					// @event drag: Event
					// Fired repeatedly while the user drags the marker.
					marker.fire('move', e).fire('drag', e);
				},

				_onDragEnd: function _onDragEnd(e) {
					// @event dragend: DragEndEvent
					// Fired when the user stops dragging the marker.

					cancelAnimFrame(this._panRequest);

					// @event moveend: Event
					// Fired when the marker stops moving (because of dragging).
					delete this._oldLatLng;
					this._marker.fire('moveend').fire('dragend', e);
				}
			});

			/*
    * @class Marker
    * @inherits Interactive layer
    * @aka L.Marker
    * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
    *
    * @example
    *
    * ```js
    * L.marker([50.5, 30.5]).addTo(map);
    * ```
    */

			var Marker = Layer.extend({

				// @section
				// @aka Marker options
				options: {
					// @option icon: Icon = *
					// Icon instance to use for rendering the marker.
					// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
					// If not specified, a common instance of `L.Icon.Default` is used.
					icon: new IconDefault(),

					// Option inherited from "Interactive layer" abstract class
					interactive: true,

					// @option draggable: Boolean = false
					// Whether the marker is draggable with mouse/touch or not.
					draggable: false,

					// @option autoPan: Boolean = false
					// Set it to `true` if you want the map to do panning animation when marker hits the edges.
					autoPan: false,

					// @option autoPanPadding: Point = Point(50, 50)
					// Equivalent of setting both top left and bottom right autopan padding to the same value.
					autoPanPadding: [50, 50],

					// @option autoPanSpeed: Number = 10
					// Number of pixels the map should move by.
					autoPanSpeed: 10,

					// @option keyboard: Boolean = true
					// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
					keyboard: true,

					// @option title: String = ''
					// Text for the browser tooltip that appear on marker hover (no tooltip by default).
					title: '',

					// @option alt: String = ''
					// Text for the `alt` attribute of the icon image (useful for accessibility).
					alt: '',

					// @option zIndexOffset: Number = 0
					// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
					zIndexOffset: 0,

					// @option opacity: Number = 1.0
					// The opacity of the marker.
					opacity: 1,

					// @option riseOnHover: Boolean = false
					// If `true`, the marker will get on top of others when you hover the mouse over it.
					riseOnHover: false,

					// @option riseOffset: Number = 250
					// The z-index offset used for the `riseOnHover` feature.
					riseOffset: 250,

					// @option pane: String = 'markerPane'
					// `Map pane` where the markers icon will be added.
					pane: 'markerPane',

					// @option bubblingMouseEvents: Boolean = false
					// When `true`, a mouse event on this marker will trigger the same event on the map
					// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
					bubblingMouseEvents: false
				},

				/* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */

				initialize: function initialize(latlng, options) {
					setOptions(this, options);
					this._latlng = toLatLng(latlng);
				},

				onAdd: function onAdd(map) {
					this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

					if (this._zoomAnimated) {
						map.on('zoomanim', this._animateZoom, this);
					}

					this._initIcon();
					this.update();
				},

				onRemove: function onRemove(map) {
					if (this.dragging && this.dragging.enabled()) {
						this.options.draggable = true;
						this.dragging.removeHooks();
					}
					delete this.dragging;

					if (this._zoomAnimated) {
						map.off('zoomanim', this._animateZoom, this);
					}

					this._removeIcon();
					this._removeShadow();
				},

				getEvents: function getEvents() {
					return {
						zoom: this.update,
						viewreset: this.update
					};
				},

				// @method getLatLng: LatLng
				// Returns the current geographical position of the marker.
				getLatLng: function getLatLng() {
					return this._latlng;
				},

				// @method setLatLng(latlng: LatLng): this
				// Changes the marker position to the given point.
				setLatLng: function setLatLng(latlng) {
					var oldLatLng = this._latlng;
					this._latlng = toLatLng(latlng);
					this.update();

					// @event move: Event
					// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
					return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
				},

				// @method setZIndexOffset(offset: Number): this
				// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
				setZIndexOffset: function setZIndexOffset(offset) {
					this.options.zIndexOffset = offset;
					return this.update();
				},

				// @method setIcon(icon: Icon): this
				// Changes the marker icon.
				setIcon: function setIcon(icon) {

					this.options.icon = icon;

					if (this._map) {
						this._initIcon();
						this.update();
					}

					if (this._popup) {
						this.bindPopup(this._popup, this._popup.options);
					}

					return this;
				},

				getElement: function getElement() {
					return this._icon;
				},

				update: function update() {

					if (this._icon && this._map) {
						var pos = this._map.latLngToLayerPoint(this._latlng).round();
						this._setPos(pos);
					}

					return this;
				},

				_initIcon: function _initIcon() {
					var options = this.options,
					    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

					var icon = options.icon.createIcon(this._icon),
					    addIcon = false;

					// if we're not reusing the icon, remove the old one and init new one
					if (icon !== this._icon) {
						if (this._icon) {
							this._removeIcon();
						}
						addIcon = true;

						if (options.title) {
							icon.title = options.title;
						}

						if (icon.tagName === 'IMG') {
							icon.alt = options.alt || '';
						}
					}

					addClass(icon, classToAdd);

					if (options.keyboard) {
						icon.tabIndex = '0';
					}

					this._icon = icon;

					if (options.riseOnHover) {
						this.on({
							mouseover: this._bringToFront,
							mouseout: this._resetZIndex
						});
					}

					var newShadow = options.icon.createShadow(this._shadow),
					    addShadow = false;

					if (newShadow !== this._shadow) {
						this._removeShadow();
						addShadow = true;
					}

					if (newShadow) {
						addClass(newShadow, classToAdd);
						newShadow.alt = '';
					}
					this._shadow = newShadow;

					if (options.opacity < 1) {
						this._updateOpacity();
					}

					if (addIcon) {
						this.getPane().appendChild(this._icon);
					}
					this._initInteraction();
					if (newShadow && addShadow) {
						this.getPane('shadowPane').appendChild(this._shadow);
					}
				},

				_removeIcon: function _removeIcon() {
					if (this.options.riseOnHover) {
						this.off({
							mouseover: this._bringToFront,
							mouseout: this._resetZIndex
						});
					}

					_remove(this._icon);
					this.removeInteractiveTarget(this._icon);

					this._icon = null;
				},

				_removeShadow: function _removeShadow() {
					if (this._shadow) {
						_remove(this._shadow);
					}
					this._shadow = null;
				},

				_setPos: function _setPos(pos) {
					setPosition(this._icon, pos);

					if (this._shadow) {
						setPosition(this._shadow, pos);
					}

					this._zIndex = pos.y + this.options.zIndexOffset;

					this._resetZIndex();
				},

				_updateZIndex: function _updateZIndex(offset) {
					this._icon.style.zIndex = this._zIndex + offset;
				},

				_animateZoom: function _animateZoom(opt) {
					var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

					this._setPos(pos);
				},

				_initInteraction: function _initInteraction() {

					if (!this.options.interactive) {
						return;
					}

					addClass(this._icon, 'leaflet-interactive');

					this.addInteractiveTarget(this._icon);

					if (MarkerDrag) {
						var draggable = this.options.draggable;
						if (this.dragging) {
							draggable = this.dragging.enabled();
							this.dragging.disable();
						}

						this.dragging = new MarkerDrag(this);

						if (draggable) {
							this.dragging.enable();
						}
					}
				},

				// @method setOpacity(opacity: Number): this
				// Changes the opacity of the marker.
				setOpacity: function setOpacity(opacity) {
					this.options.opacity = opacity;
					if (this._map) {
						this._updateOpacity();
					}

					return this;
				},

				_updateOpacity: function _updateOpacity() {
					var opacity = this.options.opacity;

					_setOpacity(this._icon, opacity);

					if (this._shadow) {
						_setOpacity(this._shadow, opacity);
					}
				},

				_bringToFront: function _bringToFront() {
					this._updateZIndex(this.options.riseOffset);
				},

				_resetZIndex: function _resetZIndex() {
					this._updateZIndex(0);
				},

				_getPopupAnchor: function _getPopupAnchor() {
					return this.options.icon.options.popupAnchor;
				},

				_getTooltipAnchor: function _getTooltipAnchor() {
					return this.options.icon.options.tooltipAnchor;
				}
			});

			// factory L.marker(latlng: LatLng, options? : Marker options)

			// @factory L.marker(latlng: LatLng, options? : Marker options)
			// Instantiates a Marker object given a geographical point and optionally an options object.
			function marker(latlng, options) {
				return new Marker(latlng, options);
			}

			/*
    * @class Path
    * @aka L.Path
    * @inherits Interactive layer
    *
    * An abstract class that contains options and constants shared between vector
    * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
    */

			var Path = Layer.extend({

				// @section
				// @aka Path options
				options: {
					// @option stroke: Boolean = true
					// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
					stroke: true,

					// @option color: String = '#3388ff'
					// Stroke color
					color: '#3388ff',

					// @option weight: Number = 3
					// Stroke width in pixels
					weight: 3,

					// @option opacity: Number = 1.0
					// Stroke opacity
					opacity: 1,

					// @option lineCap: String= 'round'
					// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
					lineCap: 'round',

					// @option lineJoin: String = 'round'
					// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
					lineJoin: 'round',

					// @option dashArray: String = null
					// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
					dashArray: null,

					// @option dashOffset: String = null
					// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
					dashOffset: null,

					// @option fill: Boolean = depends
					// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
					fill: false,

					// @option fillColor: String = *
					// Fill color. Defaults to the value of the [`color`](#path-color) option
					fillColor: null,

					// @option fillOpacity: Number = 0.2
					// Fill opacity.
					fillOpacity: 0.2,

					// @option fillRule: String = 'evenodd'
					// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
					fillRule: 'evenodd',

					// className: '',

					// Option inherited from "Interactive layer" abstract class
					interactive: true,

					// @option bubblingMouseEvents: Boolean = true
					// When `true`, a mouse event on this path will trigger the same event on the map
					// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
					bubblingMouseEvents: true
				},

				beforeAdd: function beforeAdd(map) {
					// Renderer is set here because we need to call renderer.getEvents
					// before this.getEvents.
					this._renderer = map.getRenderer(this);
				},

				onAdd: function onAdd() {
					this._renderer._initPath(this);
					this._reset();
					this._renderer._addPath(this);
				},

				onRemove: function onRemove() {
					this._renderer._removePath(this);
				},

				// @method redraw(): this
				// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
				redraw: function redraw() {
					if (this._map) {
						this._renderer._updatePath(this);
					}
					return this;
				},

				// @method setStyle(style: Path options): this
				// Changes the appearance of a Path based on the options in the `Path options` object.
				setStyle: function setStyle(style) {
					setOptions(this, style);
					if (this._renderer) {
						this._renderer._updateStyle(this);
					}
					return this;
				},

				// @method bringToFront(): this
				// Brings the layer to the top of all path layers.
				bringToFront: function bringToFront() {
					if (this._renderer) {
						this._renderer._bringToFront(this);
					}
					return this;
				},

				// @method bringToBack(): this
				// Brings the layer to the bottom of all path layers.
				bringToBack: function bringToBack() {
					if (this._renderer) {
						this._renderer._bringToBack(this);
					}
					return this;
				},

				getElement: function getElement() {
					return this._path;
				},

				_reset: function _reset() {
					// defined in child classes
					this._project();
					this._update();
				},

				_clickTolerance: function _clickTolerance() {
					// used when doing hit detection for Canvas layers
					return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
				}
			});

			/*
    * @class CircleMarker
    * @aka L.CircleMarker
    * @inherits Path
    *
    * A circle of a fixed size with radius specified in pixels. Extends `Path`.
    */

			var CircleMarker = Path.extend({

				// @section
				// @aka CircleMarker options
				options: {
					fill: true,

					// @option radius: Number = 10
					// Radius of the circle marker, in pixels
					radius: 10
				},

				initialize: function initialize(latlng, options) {
					setOptions(this, options);
					this._latlng = toLatLng(latlng);
					this._radius = this.options.radius;
				},

				// @method setLatLng(latLng: LatLng): this
				// Sets the position of a circle marker to a new location.
				setLatLng: function setLatLng(latlng) {
					this._latlng = toLatLng(latlng);
					this.redraw();
					return this.fire('move', { latlng: this._latlng });
				},

				// @method getLatLng(): LatLng
				// Returns the current geographical position of the circle marker
				getLatLng: function getLatLng() {
					return this._latlng;
				},

				// @method setRadius(radius: Number): this
				// Sets the radius of a circle marker. Units are in pixels.
				setRadius: function setRadius(radius) {
					this.options.radius = this._radius = radius;
					return this.redraw();
				},

				// @method getRadius(): Number
				// Returns the current radius of the circle
				getRadius: function getRadius() {
					return this._radius;
				},

				setStyle: function setStyle(options) {
					var radius = options && options.radius || this._radius;
					Path.prototype.setStyle.call(this, options);
					this.setRadius(radius);
					return this;
				},

				_project: function _project() {
					this._point = this._map.latLngToLayerPoint(this._latlng);
					this._updateBounds();
				},

				_updateBounds: function _updateBounds() {
					var r = this._radius,
					    r2 = this._radiusY || r,
					    w = this._clickTolerance(),
					    p = [r + w, r2 + w];
					this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
				},

				_update: function _update() {
					if (this._map) {
						this._updatePath();
					}
				},

				_updatePath: function _updatePath() {
					this._renderer._updateCircle(this);
				},

				_empty: function _empty() {
					return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
				},

				// Needed by the `Canvas` renderer for interactivity
				_containsPoint: function _containsPoint(p) {
					return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
				}
			});

			// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
			// Instantiates a circle marker object given a geographical point, and an optional options object.
			function circleMarker(latlng, options) {
				return new CircleMarker(latlng, options);
			}

			/*
    * @class Circle
    * @aka L.Circle
    * @inherits CircleMarker
    *
    * A class for drawing circle overlays on a map. Extends `CircleMarker`.
    *
    * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
    *
    * @example
    *
    * ```js
    * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
    * ```
    */

			var Circle = CircleMarker.extend({

				initialize: function initialize(latlng, options, legacyOptions) {
					if (typeof options === 'number') {
						// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
						options = extend({}, legacyOptions, { radius: options });
					}
					setOptions(this, options);
					this._latlng = toLatLng(latlng);

					if (isNaN(this.options.radius)) {
						throw new Error('Circle radius cannot be NaN');
					}

					// @section
					// @aka Circle options
					// @option radius: Number; Radius of the circle, in meters.
					this._mRadius = this.options.radius;
				},

				// @method setRadius(radius: Number): this
				// Sets the radius of a circle. Units are in meters.
				setRadius: function setRadius(radius) {
					this._mRadius = radius;
					return this.redraw();
				},

				// @method getRadius(): Number
				// Returns the current radius of a circle. Units are in meters.
				getRadius: function getRadius() {
					return this._mRadius;
				},

				// @method getBounds(): LatLngBounds
				// Returns the `LatLngBounds` of the path.
				getBounds: function getBounds() {
					var half = [this._radius, this._radiusY || this._radius];

					return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
				},

				setStyle: Path.prototype.setStyle,

				_project: function _project() {

					var lng = this._latlng.lng,
					    lat = this._latlng.lat,
					    map = this._map,
					    crs = map.options.crs;

					if (crs.distance === Earth.distance) {
						var d = Math.PI / 180,
						    latR = this._mRadius / Earth.R / d,
						    top = map.project([lat + latR, lng]),
						    bottom = map.project([lat - latR, lng]),
						    p = top.add(bottom).divideBy(2),
						    lat2 = map.unproject(p).lat,
						    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

						if (isNaN(lngR) || lngR === 0) {
							lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
						}

						this._point = p.subtract(map.getPixelOrigin());
						this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
						this._radiusY = p.y - top.y;
					} else {
						var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

						this._point = map.latLngToLayerPoint(this._latlng);
						this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
					}

					this._updateBounds();
				}
			});

			// @factory L.circle(latlng: LatLng, options?: Circle options)
			// Instantiates a circle object given a geographical point, and an options object
			// which contains the circle radius.
			// @alternative
			// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
			// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
			// Do not use in new applications or plugins.
			function circle(latlng, options, legacyOptions) {
				return new Circle(latlng, options, legacyOptions);
			}

			/*
    * @class Polyline
    * @aka L.Polyline
    * @inherits Path
    *
    * A class for drawing polyline overlays on a map. Extends `Path`.
    *
    * @example
    *
    * ```js
    * // create a red polyline from an array of LatLng points
    * var latlngs = [
    * 	[45.51, -122.68],
    * 	[37.77, -122.43],
    * 	[34.04, -118.2]
    * ];
    *
    * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
    *
    * // zoom the map to the polyline
    * map.fitBounds(polyline.getBounds());
    * ```
    *
    * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
    *
    * ```js
    * // create a red polyline from an array of arrays of LatLng points
    * var latlngs = [
    * 	[[45.51, -122.68],
    * 	 [37.77, -122.43],
    * 	 [34.04, -118.2]],
    * 	[[40.78, -73.91],
    * 	 [41.83, -87.62],
    * 	 [32.76, -96.72]]
    * ];
    * ```
    */

			var Polyline = Path.extend({

				// @section
				// @aka Polyline options
				options: {
					// @option smoothFactor: Number = 1.0
					// How much to simplify the polyline on each zoom level. More means
					// better performance and smoother look, and less means more accurate representation.
					smoothFactor: 1.0,

					// @option noClip: Boolean = false
					// Disable polyline clipping.
					noClip: false
				},

				initialize: function initialize(latlngs, options) {
					setOptions(this, options);
					this._setLatLngs(latlngs);
				},

				// @method getLatLngs(): LatLng[]
				// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
				getLatLngs: function getLatLngs() {
					return this._latlngs;
				},

				// @method setLatLngs(latlngs: LatLng[]): this
				// Replaces all the points in the polyline with the given array of geographical points.
				setLatLngs: function setLatLngs(latlngs) {
					this._setLatLngs(latlngs);
					return this.redraw();
				},

				// @method isEmpty(): Boolean
				// Returns `true` if the Polyline has no LatLngs.
				isEmpty: function isEmpty() {
					return !this._latlngs.length;
				},

				// @method closestLayerPoint(p: Point): Point
				// Returns the point closest to `p` on the Polyline.
				closestLayerPoint: function closestLayerPoint(p) {
					var minDistance = Infinity,
					    minPoint = null,
					    closest = _sqClosestPointOnSegment,
					    p1,
					    p2;

					for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
						var points = this._parts[j];

						for (var i = 1, len = points.length; i < len; i++) {
							p1 = points[i - 1];
							p2 = points[i];

							var sqDist = closest(p, p1, p2, true);

							if (sqDist < minDistance) {
								minDistance = sqDist;
								minPoint = closest(p, p1, p2);
							}
						}
					}
					if (minPoint) {
						minPoint.distance = Math.sqrt(minDistance);
					}
					return minPoint;
				},

				// @method getCenter(): LatLng
				// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
				getCenter: function getCenter() {
					// throws error when not yet added to map as this center calculation requires projected coordinates
					if (!this._map) {
						throw new Error('Must add layer to map before using getCenter()');
					}

					var i,
					    halfDist,
					    segDist,
					    dist,
					    p1,
					    p2,
					    ratio,
					    points = this._rings[0],
					    len = points.length;

					if (!len) {
						return null;
					}

					// polyline centroid algorithm; only uses the first ring if there are multiple

					for (i = 0, halfDist = 0; i < len - 1; i++) {
						halfDist += points[i].distanceTo(points[i + 1]) / 2;
					}

					// The line is so small in the current view that all points are on the same pixel.
					if (halfDist === 0) {
						return this._map.layerPointToLatLng(points[0]);
					}

					for (i = 0, dist = 0; i < len - 1; i++) {
						p1 = points[i];
						p2 = points[i + 1];
						segDist = p1.distanceTo(p2);
						dist += segDist;

						if (dist > halfDist) {
							ratio = (dist - halfDist) / segDist;
							return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
						}
					}
				},

				// @method getBounds(): LatLngBounds
				// Returns the `LatLngBounds` of the path.
				getBounds: function getBounds() {
					return this._bounds;
				},

				// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
				// Adds a given point to the polyline. By default, adds to the first ring of
				// the polyline in case of a multi-polyline, but can be overridden by passing
				// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
				addLatLng: function addLatLng(latlng, latlngs) {
					latlngs = latlngs || this._defaultShape();
					latlng = toLatLng(latlng);
					latlngs.push(latlng);
					this._bounds.extend(latlng);
					return this.redraw();
				},

				_setLatLngs: function _setLatLngs(latlngs) {
					this._bounds = new LatLngBounds();
					this._latlngs = this._convertLatLngs(latlngs);
				},

				_defaultShape: function _defaultShape() {
					return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
				},

				// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
				_convertLatLngs: function _convertLatLngs(latlngs) {
					var result = [],
					    flat = isFlat(latlngs);

					for (var i = 0, len = latlngs.length; i < len; i++) {
						if (flat) {
							result[i] = toLatLng(latlngs[i]);
							this._bounds.extend(result[i]);
						} else {
							result[i] = this._convertLatLngs(latlngs[i]);
						}
					}

					return result;
				},

				_project: function _project() {
					var pxBounds = new Bounds();
					this._rings = [];
					this._projectLatlngs(this._latlngs, this._rings, pxBounds);

					var w = this._clickTolerance(),
					    p = new Point(w, w);

					if (this._bounds.isValid() && pxBounds.isValid()) {
						pxBounds.min._subtract(p);
						pxBounds.max._add(p);
						this._pxBounds = pxBounds;
					}
				},

				// recursively turns latlngs into a set of rings with projected coordinates
				_projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
					var flat = latlngs[0] instanceof LatLng,
					    len = latlngs.length,
					    i,
					    ring;

					if (flat) {
						ring = [];
						for (i = 0; i < len; i++) {
							ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
							projectedBounds.extend(ring[i]);
						}
						result.push(ring);
					} else {
						for (i = 0; i < len; i++) {
							this._projectLatlngs(latlngs[i], result, projectedBounds);
						}
					}
				},

				// clip polyline by renderer bounds so that we have less to render for performance
				_clipPoints: function _clipPoints() {
					var bounds = this._renderer._bounds;

					this._parts = [];
					if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
						return;
					}

					if (this.options.noClip) {
						this._parts = this._rings;
						return;
					}

					var parts = this._parts,
					    i,
					    j,
					    k,
					    len,
					    len2,
					    segment,
					    points;

					for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
						points = this._rings[i];

						for (j = 0, len2 = points.length; j < len2 - 1; j++) {
							segment = clipSegment(points[j], points[j + 1], bounds, j, true);

							if (!segment) {
								continue;
							}

							parts[k] = parts[k] || [];
							parts[k].push(segment[0]);

							// if segment goes out of screen, or it's the last one, it's the end of the line part
							if (segment[1] !== points[j + 1] || j === len2 - 2) {
								parts[k].push(segment[1]);
								k++;
							}
						}
					}
				},

				// simplify each clipped part of the polyline for performance
				_simplifyPoints: function _simplifyPoints() {
					var parts = this._parts,
					    tolerance = this.options.smoothFactor;

					for (var i = 0, len = parts.length; i < len; i++) {
						parts[i] = simplify(parts[i], tolerance);
					}
				},

				_update: function _update() {
					if (!this._map) {
						return;
					}

					this._clipPoints();
					this._simplifyPoints();
					this._updatePath();
				},

				_updatePath: function _updatePath() {
					this._renderer._updatePoly(this);
				},

				// Needed by the `Canvas` renderer for interactivity
				_containsPoint: function _containsPoint(p, closed) {
					var i,
					    j,
					    k,
					    len,
					    len2,
					    part,
					    w = this._clickTolerance();

					if (!this._pxBounds || !this._pxBounds.contains(p)) {
						return false;
					}

					// hit detection for polylines
					for (i = 0, len = this._parts.length; i < len; i++) {
						part = this._parts[i];

						for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
							if (!closed && j === 0) {
								continue;
							}

							if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
								return true;
							}
						}
					}
					return false;
				}
			});

			// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
			// Instantiates a polyline object given an array of geographical points and
			// optionally an options object. You can create a `Polyline` object with
			// multiple separate lines (`MultiPolyline`) by passing an array of arrays
			// of geographic points.
			function polyline(latlngs, options) {
				return new Polyline(latlngs, options);
			}

			// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
			Polyline._flat = _flat;

			/*
    * @class Polygon
    * @aka L.Polygon
    * @inherits Polyline
    *
    * A class for drawing polygon overlays on a map. Extends `Polyline`.
    *
    * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
    *
    *
    * @example
    *
    * ```js
    * // create a red polygon from an array of LatLng points
    * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
    *
    * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
    *
    * // zoom the map to the polygon
    * map.fitBounds(polygon.getBounds());
    * ```
    *
    * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
    *
    * ```js
    * var latlngs = [
    *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
    *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
    * ];
    * ```
    *
    * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
    *
    * ```js
    * var latlngs = [
    *   [ // first polygon
    *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
    *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
    *   ],
    *   [ // second polygon
    *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
    *   ]
    * ];
    * ```
    */

			var Polygon = Polyline.extend({

				options: {
					fill: true
				},

				isEmpty: function isEmpty() {
					return !this._latlngs.length || !this._latlngs[0].length;
				},

				getCenter: function getCenter() {
					// throws error when not yet added to map as this center calculation requires projected coordinates
					if (!this._map) {
						throw new Error('Must add layer to map before using getCenter()');
					}

					var i,
					    j,
					    p1,
					    p2,
					    f,
					    area,
					    x,
					    y,
					    center,
					    points = this._rings[0],
					    len = points.length;

					if (!len) {
						return null;
					}

					// polygon centroid algorithm; only uses the first ring if there are multiple

					area = x = y = 0;

					for (i = 0, j = len - 1; i < len; j = i++) {
						p1 = points[i];
						p2 = points[j];

						f = p1.y * p2.x - p2.y * p1.x;
						x += (p1.x + p2.x) * f;
						y += (p1.y + p2.y) * f;
						area += f * 3;
					}

					if (area === 0) {
						// Polygon is so small that all points are on same pixel.
						center = points[0];
					} else {
						center = [x / area, y / area];
					}
					return this._map.layerPointToLatLng(center);
				},

				_convertLatLngs: function _convertLatLngs(latlngs) {
					var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
					    len = result.length;

					// remove last point if it equals first one
					if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
						result.pop();
					}
					return result;
				},

				_setLatLngs: function _setLatLngs(latlngs) {
					Polyline.prototype._setLatLngs.call(this, latlngs);
					if (isFlat(this._latlngs)) {
						this._latlngs = [this._latlngs];
					}
				},

				_defaultShape: function _defaultShape() {
					return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
				},

				_clipPoints: function _clipPoints() {
					// polygons need a different clipping algorithm so we redefine that

					var bounds = this._renderer._bounds,
					    w = this.options.weight,
					    p = new Point(w, w);

					// increase clip padding by stroke width to avoid stroke on clip edges
					bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

					this._parts = [];
					if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
						return;
					}

					if (this.options.noClip) {
						this._parts = this._rings;
						return;
					}

					for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
						clipped = clipPolygon(this._rings[i], bounds, true);
						if (clipped.length) {
							this._parts.push(clipped);
						}
					}
				},

				_updatePath: function _updatePath() {
					this._renderer._updatePoly(this, true);
				},

				// Needed by the `Canvas` renderer for interactivity
				_containsPoint: function _containsPoint(p) {
					var inside = false,
					    part,
					    p1,
					    p2,
					    i,
					    j,
					    k,
					    len,
					    len2;

					if (!this._pxBounds || !this._pxBounds.contains(p)) {
						return false;
					}

					// ray casting algorithm for detecting if point is in polygon
					for (i = 0, len = this._parts.length; i < len; i++) {
						part = this._parts[i];

						for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
							p1 = part[j];
							p2 = part[k];

							if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
								inside = !inside;
							}
						}
					}

					// also check if it's on polygon stroke
					return inside || Polyline.prototype._containsPoint.call(this, p, true);
				}

			});

			// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
			function polygon(latlngs, options) {
				return new Polygon(latlngs, options);
			}

			/*
    * @class GeoJSON
    * @aka L.GeoJSON
    * @inherits FeatureGroup
    *
    * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
    * GeoJSON data and display it on the map. Extends `FeatureGroup`.
    *
    * @example
    *
    * ```js
    * L.geoJSON(data, {
    * 	style: function (feature) {
    * 		return {color: feature.properties.color};
    * 	}
    * }).bindPopup(function (layer) {
    * 	return layer.feature.properties.description;
    * }).addTo(map);
    * ```
    */

			var GeoJSON = FeatureGroup.extend({

				/* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     */

				initialize: function initialize(geojson, options) {
					setOptions(this, options);

					this._layers = {};

					if (geojson) {
						this.addData(geojson);
					}
				},

				// @method addData( <GeoJSON> data ): this
				// Adds a GeoJSON object to the layer.
				addData: function addData(geojson) {
					var features = isArray(geojson) ? geojson : geojson.features,
					    i,
					    len,
					    feature;

					if (features) {
						for (i = 0, len = features.length; i < len; i++) {
							// only add this if geometry or geometries are set and not null
							feature = features[i];
							if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
								this.addData(feature);
							}
						}
						return this;
					}

					var options = this.options;

					if (options.filter && !options.filter(geojson)) {
						return this;
					}

					var layer = geometryToLayer(geojson, options);
					if (!layer) {
						return this;
					}
					layer.feature = asFeature(geojson);

					layer.defaultOptions = layer.options;
					this.resetStyle(layer);

					if (options.onEachFeature) {
						options.onEachFeature(geojson, layer);
					}

					return this.addLayer(layer);
				},

				// @method resetStyle( <Path> layer ): this
				// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
				resetStyle: function resetStyle(layer) {
					// reset any custom styles
					layer.options = extend({}, layer.defaultOptions);
					this._setLayerStyle(layer, this.options.style);
					return this;
				},

				// @method setStyle( <Function> style ): this
				// Changes styles of GeoJSON vector layers with the given style function.
				setStyle: function setStyle(style) {
					return this.eachLayer(function (layer) {
						this._setLayerStyle(layer, style);
					}, this);
				},

				_setLayerStyle: function _setLayerStyle(layer, style) {
					if (typeof style === 'function') {
						style = style(layer.feature);
					}
					if (layer.setStyle) {
						layer.setStyle(style);
					}
				}
			});

			// @section
			// There are several static functions which can be called without instantiating L.GeoJSON:

			// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
			// Creates a `Layer` from a given GeoJSON feature. Can use a custom
			// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
			// functions if provided as options.
			function geometryToLayer(geojson, options) {

				var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
				    coords = geometry ? geometry.coordinates : null,
				    layers = [],
				    pointToLayer = options && options.pointToLayer,
				    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
				    latlng,
				    latlngs,
				    i,
				    len;

				if (!coords && !geometry) {
					return null;
				}

				switch (geometry.type) {
					case 'Point':
						latlng = _coordsToLatLng(coords);
						return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

					case 'MultiPoint':
						for (i = 0, len = coords.length; i < len; i++) {
							latlng = _coordsToLatLng(coords[i]);
							layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
						}
						return new FeatureGroup(layers);

					case 'LineString':
					case 'MultiLineString':
						latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
						return new Polyline(latlngs, options);

					case 'Polygon':
					case 'MultiPolygon':
						latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
						return new Polygon(latlngs, options);

					case 'GeometryCollection':
						for (i = 0, len = geometry.geometries.length; i < len; i++) {
							var layer = geometryToLayer({
								geometry: geometry.geometries[i],
								type: 'Feature',
								properties: geojson.properties
							}, options);

							if (layer) {
								layers.push(layer);
							}
						}
						return new FeatureGroup(layers);

					default:
						throw new Error('Invalid GeoJSON object.');
				}
			}

			// @function coordsToLatLng(coords: Array): LatLng
			// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
			// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
			function coordsToLatLng(coords) {
				return new LatLng(coords[1], coords[0], coords[2]);
			}

			// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
			// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
			// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
			// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
			function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
				var latlngs = [];

				for (var i = 0, len = coords.length, latlng; i < len; i++) {
					latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);

					latlngs.push(latlng);
				}

				return latlngs;
			}

			// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
			// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
			function latLngToCoords(latlng, precision) {
				precision = typeof precision === 'number' ? precision : 6;
				return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
			}

			// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
			// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
			// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
			function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
				var coords = [];

				for (var i = 0, len = latlngs.length; i < len; i++) {
					coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
				}

				if (!levelsDeep && closed) {
					coords.push(coords[0]);
				}

				return coords;
			}

			function getFeature(layer, newGeometry) {
				return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
			}

			// @function asFeature(geojson: Object): Object
			// Normalize GeoJSON geometries/features into GeoJSON features.
			function asFeature(geojson) {
				if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
					return geojson;
				}

				return {
					type: 'Feature',
					properties: {},
					geometry: geojson
				};
			}

			var PointToGeoJSON = {
				toGeoJSON: function toGeoJSON(precision) {
					return getFeature(this, {
						type: 'Point',
						coordinates: latLngToCoords(this.getLatLng(), precision)
					});
				}
			};

			// @namespace Marker
			// @method toGeoJSON(): Object
			// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
			Marker.include(PointToGeoJSON);

			// @namespace CircleMarker
			// @method toGeoJSON(): Object
			// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
			Circle.include(PointToGeoJSON);
			CircleMarker.include(PointToGeoJSON);

			// @namespace Polyline
			// @method toGeoJSON(): Object
			// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
			Polyline.include({
				toGeoJSON: function toGeoJSON(precision) {
					var multi = !isFlat(this._latlngs);

					var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

					return getFeature(this, {
						type: (multi ? 'Multi' : '') + 'LineString',
						coordinates: coords
					});
				}
			});

			// @namespace Polygon
			// @method toGeoJSON(): Object
			// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
			Polygon.include({
				toGeoJSON: function toGeoJSON(precision) {
					var holes = !isFlat(this._latlngs),
					    multi = holes && !isFlat(this._latlngs[0]);

					var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

					if (!holes) {
						coords = [coords];
					}

					return getFeature(this, {
						type: (multi ? 'Multi' : '') + 'Polygon',
						coordinates: coords
					});
				}
			});

			// @namespace LayerGroup
			LayerGroup.include({
				toMultiPoint: function toMultiPoint(precision) {
					var coords = [];

					this.eachLayer(function (layer) {
						coords.push(layer.toGeoJSON(precision).geometry.coordinates);
					});

					return getFeature(this, {
						type: 'MultiPoint',
						coordinates: coords
					});
				},

				// @method toGeoJSON(): Object
				// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
				toGeoJSON: function toGeoJSON(precision) {

					var type = this.feature && this.feature.geometry && this.feature.geometry.type;

					if (type === 'MultiPoint') {
						return this.toMultiPoint(precision);
					}

					var isGeometryCollection = type === 'GeometryCollection',
					    jsons = [];

					this.eachLayer(function (layer) {
						if (layer.toGeoJSON) {
							var json = layer.toGeoJSON(precision);
							if (isGeometryCollection) {
								jsons.push(json.geometry);
							} else {
								var feature = asFeature(json);
								// Squash nested feature collections
								if (feature.type === 'FeatureCollection') {
									jsons.push.apply(jsons, feature.features);
								} else {
									jsons.push(feature);
								}
							}
						}
					});

					if (isGeometryCollection) {
						return getFeature(this, {
							geometries: jsons,
							type: 'GeometryCollection'
						});
					}

					return {
						type: 'FeatureCollection',
						features: jsons
					};
				}
			});

			// @namespace GeoJSON
			// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
			// Creates a GeoJSON layer. Optionally accepts an object in
			// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
			// (you can alternatively add it later with `addData` method) and an `options` object.
			function geoJSON(geojson, options) {
				return new GeoJSON(geojson, options);
			}

			// Backward compatibility.
			var geoJson = geoJSON;

			/*
    * @class ImageOverlay
    * @aka L.ImageOverlay
    * @inherits Interactive layer
    *
    * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
    *
    * @example
    *
    * ```js
    * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
    * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
    * L.imageOverlay(imageUrl, imageBounds).addTo(map);
    * ```
    */

			var ImageOverlay = Layer.extend({

				// @section
				// @aka ImageOverlay options
				options: {
					// @option opacity: Number = 1.0
					// The opacity of the image overlay.
					opacity: 1,

					// @option alt: String = ''
					// Text for the `alt` attribute of the image (useful for accessibility).
					alt: '',

					// @option interactive: Boolean = false
					// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
					interactive: false,

					// @option crossOrigin: Boolean|String = false
					// Whether the crossOrigin attribute will be added to the image.
					// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
					// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
					crossOrigin: false,

					// @option errorOverlayUrl: String = ''
					// URL to the overlay image to show in place of the overlay that failed to load.
					errorOverlayUrl: '',

					// @option zIndex: Number = 1
					// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
					zIndex: 1,

					// @option className: String = ''
					// A custom class name to assign to the image. Empty by default.
					className: ''
				},

				initialize: function initialize(url, bounds, options) {
					// (String, LatLngBounds, Object)
					this._url = url;
					this._bounds = toLatLngBounds(bounds);

					setOptions(this, options);
				},

				onAdd: function onAdd() {
					if (!this._image) {
						this._initImage();

						if (this.options.opacity < 1) {
							this._updateOpacity();
						}
					}

					if (this.options.interactive) {
						addClass(this._image, 'leaflet-interactive');
						this.addInteractiveTarget(this._image);
					}

					this.getPane().appendChild(this._image);
					this._reset();
				},

				onRemove: function onRemove() {
					_remove(this._image);
					if (this.options.interactive) {
						this.removeInteractiveTarget(this._image);
					}
				},

				// @method setOpacity(opacity: Number): this
				// Sets the opacity of the overlay.
				setOpacity: function setOpacity(opacity) {
					this.options.opacity = opacity;

					if (this._image) {
						this._updateOpacity();
					}
					return this;
				},

				setStyle: function setStyle(styleOpts) {
					if (styleOpts.opacity) {
						this.setOpacity(styleOpts.opacity);
					}
					return this;
				},

				// @method bringToFront(): this
				// Brings the layer to the top of all overlays.
				bringToFront: function bringToFront() {
					if (this._map) {
						toFront(this._image);
					}
					return this;
				},

				// @method bringToBack(): this
				// Brings the layer to the bottom of all overlays.
				bringToBack: function bringToBack() {
					if (this._map) {
						toBack(this._image);
					}
					return this;
				},

				// @method setUrl(url: String): this
				// Changes the URL of the image.
				setUrl: function setUrl(url) {
					this._url = url;

					if (this._image) {
						this._image.src = url;
					}
					return this;
				},

				// @method setBounds(bounds: LatLngBounds): this
				// Update the bounds that this ImageOverlay covers
				setBounds: function setBounds(bounds) {
					this._bounds = toLatLngBounds(bounds);

					if (this._map) {
						this._reset();
					}
					return this;
				},

				getEvents: function getEvents() {
					var events = {
						zoom: this._reset,
						viewreset: this._reset
					};

					if (this._zoomAnimated) {
						events.zoomanim = this._animateZoom;
					}

					return events;
				},

				// @method: setZIndex(value: Number) : this
				// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
				setZIndex: function setZIndex(value) {
					this.options.zIndex = value;
					this._updateZIndex();
					return this;
				},

				// @method getBounds(): LatLngBounds
				// Get the bounds that this ImageOverlay covers
				getBounds: function getBounds() {
					return this._bounds;
				},

				// @method getElement(): HTMLElement
				// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
				// used by this overlay.
				getElement: function getElement() {
					return this._image;
				},

				_initImage: function _initImage() {
					var wasElementSupplied = this._url.tagName === 'IMG';
					var img = this._image = wasElementSupplied ? this._url : create$1('img');

					addClass(img, 'leaflet-image-layer');
					if (this._zoomAnimated) {
						addClass(img, 'leaflet-zoom-animated');
					}
					if (this.options.className) {
						addClass(img, this.options.className);
					}

					img.onselectstart = falseFn;
					img.onmousemove = falseFn;

					// @event load: Event
					// Fired when the ImageOverlay layer has loaded its image
					img.onload = bind(this.fire, this, 'load');
					img.onerror = bind(this._overlayOnError, this, 'error');

					if (this.options.crossOrigin || this.options.crossOrigin === '') {
						img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
					}

					if (this.options.zIndex) {
						this._updateZIndex();
					}

					if (wasElementSupplied) {
						this._url = img.src;
						return;
					}

					img.src = this._url;
					img.alt = this.options.alt;
				},

				_animateZoom: function _animateZoom(e) {
					var scale = this._map.getZoomScale(e.zoom),
					    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

					setTransform(this._image, offset, scale);
				},

				_reset: function _reset() {
					var image = this._image,
					    bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
					    size = bounds.getSize();

					setPosition(image, bounds.min);

					image.style.width = size.x + 'px';
					image.style.height = size.y + 'px';
				},

				_updateOpacity: function _updateOpacity() {
					_setOpacity(this._image, this.options.opacity);
				},

				_updateZIndex: function _updateZIndex() {
					if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
						this._image.style.zIndex = this.options.zIndex;
					}
				},

				_overlayOnError: function _overlayOnError() {
					// @event error: Event
					// Fired when the ImageOverlay layer has loaded its image
					this.fire('error');

					var errorUrl = this.options.errorOverlayUrl;
					if (errorUrl && this._url !== errorUrl) {
						this._url = errorUrl;
						this._image.src = errorUrl;
					}
				}
			});

			// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
			// Instantiates an image overlay object given the URL of the image and the
			// geographical bounds it is tied to.
			var imageOverlay = function imageOverlay(url, bounds, options) {
				return new ImageOverlay(url, bounds, options);
			};

			/*
    * @class VideoOverlay
    * @aka L.VideoOverlay
    * @inherits ImageOverlay
    *
    * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
    *
    * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
    * HTML5 element.
    *
    * @example
    *
    * ```js
    * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
    * 	videoBounds = [[ 32, -130], [ 13, -100]];
    * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
    * ```
    */

			var VideoOverlay = ImageOverlay.extend({

				// @section
				// @aka VideoOverlay options
				options: {
					// @option autoplay: Boolean = true
					// Whether the video starts playing automatically when loaded.
					autoplay: true,

					// @option loop: Boolean = true
					// Whether the video will loop back to the beginning when played.
					loop: true
				},

				_initImage: function _initImage() {
					var wasElementSupplied = this._url.tagName === 'VIDEO';
					var vid = this._image = wasElementSupplied ? this._url : create$1('video');

					addClass(vid, 'leaflet-image-layer');
					if (this._zoomAnimated) {
						addClass(vid, 'leaflet-zoom-animated');
					}

					vid.onselectstart = falseFn;
					vid.onmousemove = falseFn;

					// @event load: Event
					// Fired when the video has finished loading the first frame
					vid.onloadeddata = bind(this.fire, this, 'load');

					if (wasElementSupplied) {
						var sourceElements = vid.getElementsByTagName('source');
						var sources = [];
						for (var j = 0; j < sourceElements.length; j++) {
							sources.push(sourceElements[j].src);
						}

						this._url = sourceElements.length > 0 ? sources : [vid.src];
						return;
					}

					if (!isArray(this._url)) {
						this._url = [this._url];
					}

					vid.autoplay = !!this.options.autoplay;
					vid.loop = !!this.options.loop;
					for (var i = 0; i < this._url.length; i++) {
						var source = create$1('source');
						source.src = this._url[i];
						vid.appendChild(source);
					}
				}

				// @method getElement(): HTMLVideoElement
				// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
				// used by this overlay.
			});

			// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
			// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
			// geographical bounds it is tied to.

			function videoOverlay(video, bounds, options) {
				return new VideoOverlay(video, bounds, options);
			}

			/*
    * @class DivOverlay
    * @inherits Layer
    * @aka L.DivOverlay
    * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
    */

			// @namespace DivOverlay
			var DivOverlay = Layer.extend({

				// @section
				// @aka DivOverlay options
				options: {
					// @option offset: Point = Point(0, 7)
					// The offset of the popup position. Useful to control the anchor
					// of the popup when opening it on some overlays.
					offset: [0, 7],

					// @option className: String = ''
					// A custom CSS class name to assign to the popup.
					className: '',

					// @option pane: String = 'popupPane'
					// `Map pane` where the popup will be added.
					pane: 'popupPane'
				},

				initialize: function initialize(options, source) {
					setOptions(this, options);

					this._source = source;
				},

				onAdd: function onAdd(map) {
					this._zoomAnimated = map._zoomAnimated;

					if (!this._container) {
						this._initLayout();
					}

					if (map._fadeAnimated) {
						_setOpacity(this._container, 0);
					}

					clearTimeout(this._removeTimeout);
					this.getPane().appendChild(this._container);
					this.update();

					if (map._fadeAnimated) {
						_setOpacity(this._container, 1);
					}

					this.bringToFront();
				},

				onRemove: function onRemove(map) {
					if (map._fadeAnimated) {
						_setOpacity(this._container, 0);
						this._removeTimeout = setTimeout(bind(_remove, undefined, this._container), 200);
					} else {
						_remove(this._container);
					}
				},

				// @namespace Popup
				// @method getLatLng: LatLng
				// Returns the geographical point of popup.
				getLatLng: function getLatLng() {
					return this._latlng;
				},

				// @method setLatLng(latlng: LatLng): this
				// Sets the geographical point where the popup will open.
				setLatLng: function setLatLng(latlng) {
					this._latlng = toLatLng(latlng);
					if (this._map) {
						this._updatePosition();
						this._adjustPan();
					}
					return this;
				},

				// @method getContent: String|HTMLElement
				// Returns the content of the popup.
				getContent: function getContent() {
					return this._content;
				},

				// @method setContent(htmlContent: String|HTMLElement|Function): this
				// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
				setContent: function setContent(content) {
					this._content = content;
					this.update();
					return this;
				},

				// @method getElement: String|HTMLElement
				// Alias for [getContent()](#popup-getcontent)
				getElement: function getElement() {
					return this._container;
				},

				// @method update: null
				// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
				update: function update() {
					if (!this._map) {
						return;
					}

					this._container.style.visibility = 'hidden';

					this._updateContent();
					this._updateLayout();
					this._updatePosition();

					this._container.style.visibility = '';

					this._adjustPan();
				},

				getEvents: function getEvents() {
					var events = {
						zoom: this._updatePosition,
						viewreset: this._updatePosition
					};

					if (this._zoomAnimated) {
						events.zoomanim = this._animateZoom;
					}
					return events;
				},

				// @method isOpen: Boolean
				// Returns `true` when the popup is visible on the map.
				isOpen: function isOpen() {
					return !!this._map && this._map.hasLayer(this);
				},

				// @method bringToFront: this
				// Brings this popup in front of other popups (in the same map pane).
				bringToFront: function bringToFront() {
					if (this._map) {
						toFront(this._container);
					}
					return this;
				},

				// @method bringToBack: this
				// Brings this popup to the back of other popups (in the same map pane).
				bringToBack: function bringToBack() {
					if (this._map) {
						toBack(this._container);
					}
					return this;
				},

				_updateContent: function _updateContent() {
					if (!this._content) {
						return;
					}

					var node = this._contentNode;
					var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

					if (typeof content === 'string') {
						node.innerHTML = content;
					} else {
						while (node.hasChildNodes()) {
							node.removeChild(node.firstChild);
						}
						node.appendChild(content);
					}
					this.fire('contentupdate');
				},

				_updatePosition: function _updatePosition() {
					if (!this._map) {
						return;
					}

					var pos = this._map.latLngToLayerPoint(this._latlng),
					    offset = toPoint(this.options.offset),
					    anchor = this._getAnchor();

					if (this._zoomAnimated) {
						setPosition(this._container, pos.add(anchor));
					} else {
						offset = offset.add(pos).add(anchor);
					}

					var bottom = this._containerBottom = -offset.y,
					    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

					// bottom position the popup in case the height of the popup changes (images loading etc)
					this._container.style.bottom = bottom + 'px';
					this._container.style.left = left + 'px';
				},

				_getAnchor: function _getAnchor() {
					return [0, 0];
				}

			});

			/*
    * @class Popup
    * @inherits DivOverlay
    * @aka L.Popup
    * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
    * open popups while making sure that only one popup is open at one time
    * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
    *
    * @example
    *
    * If you want to just bind a popup to marker click and then open it, it's really easy:
    *
    * ```js
    * marker.bindPopup(popupContent).openPopup();
    * ```
    * Path overlays like polylines also have a `bindPopup` method.
    * Here's a more complicated way to open a popup on a map:
    *
    * ```js
    * var popup = L.popup()
    * 	.setLatLng(latlng)
    * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
    * 	.openOn(map);
    * ```
    */

			// @namespace Popup
			var Popup = DivOverlay.extend({

				// @section
				// @aka Popup options
				options: {
					// @option maxWidth: Number = 300
					// Max width of the popup, in pixels.
					maxWidth: 300,

					// @option minWidth: Number = 50
					// Min width of the popup, in pixels.
					minWidth: 50,

					// @option maxHeight: Number = null
					// If set, creates a scrollable container of the given height
					// inside a popup if its content exceeds it.
					maxHeight: null,

					// @option autoPan: Boolean = true
					// Set it to `false` if you don't want the map to do panning animation
					// to fit the opened popup.
					autoPan: true,

					// @option autoPanPaddingTopLeft: Point = null
					// The margin between the popup and the top left corner of the map
					// view after autopanning was performed.
					autoPanPaddingTopLeft: null,

					// @option autoPanPaddingBottomRight: Point = null
					// The margin between the popup and the bottom right corner of the map
					// view after autopanning was performed.
					autoPanPaddingBottomRight: null,

					// @option autoPanPadding: Point = Point(5, 5)
					// Equivalent of setting both top left and bottom right autopan padding to the same value.
					autoPanPadding: [5, 5],

					// @option keepInView: Boolean = false
					// Set it to `true` if you want to prevent users from panning the popup
					// off of the screen while it is open.
					keepInView: false,

					// @option closeButton: Boolean = true
					// Controls the presence of a close button in the popup.
					closeButton: true,

					// @option autoClose: Boolean = true
					// Set it to `false` if you want to override the default behavior of
					// the popup closing when another popup is opened.
					autoClose: true,

					// @option closeOnEscapeKey: Boolean = true
					// Set it to `false` if you want to override the default behavior of
					// the ESC key for closing of the popup.
					closeOnEscapeKey: true,

					// @option closeOnClick: Boolean = *
					// Set it if you want to override the default behavior of the popup closing when user clicks
					// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

					// @option className: String = ''
					// A custom CSS class name to assign to the popup.
					className: ''
				},

				// @namespace Popup
				// @method openOn(map: Map): this
				// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
				openOn: function openOn(map) {
					map.openPopup(this);
					return this;
				},

				onAdd: function onAdd(map) {
					DivOverlay.prototype.onAdd.call(this, map);

					// @namespace Map
					// @section Popup events
					// @event popupopen: PopupEvent
					// Fired when a popup is opened in the map
					map.fire('popupopen', { popup: this });

					if (this._source) {
						// @namespace Layer
						// @section Popup events
						// @event popupopen: PopupEvent
						// Fired when a popup bound to this layer is opened
						this._source.fire('popupopen', { popup: this }, true);
						// For non-path layers, we toggle the popup when clicking
						// again the layer, so prevent the map to reopen it.
						if (!(this._source instanceof Path)) {
							this._source.on('preclick', stopPropagation);
						}
					}
				},

				onRemove: function onRemove(map) {
					DivOverlay.prototype.onRemove.call(this, map);

					// @namespace Map
					// @section Popup events
					// @event popupclose: PopupEvent
					// Fired when a popup in the map is closed
					map.fire('popupclose', { popup: this });

					if (this._source) {
						// @namespace Layer
						// @section Popup events
						// @event popupclose: PopupEvent
						// Fired when a popup bound to this layer is closed
						this._source.fire('popupclose', { popup: this }, true);
						if (!(this._source instanceof Path)) {
							this._source.off('preclick', stopPropagation);
						}
					}
				},

				getEvents: function getEvents() {
					var events = DivOverlay.prototype.getEvents.call(this);

					if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
						events.preclick = this._close;
					}

					if (this.options.keepInView) {
						events.moveend = this._adjustPan;
					}

					return events;
				},

				_close: function _close() {
					if (this._map) {
						this._map.closePopup(this);
					}
				},

				_initLayout: function _initLayout() {
					var prefix = 'leaflet-popup',
					    container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');

					var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
					this._contentNode = create$1('div', prefix + '-content', wrapper);

					disableClickPropagation(wrapper);
					disableScrollPropagation(this._contentNode);
					on(wrapper, 'contextmenu', stopPropagation);

					this._tipContainer = create$1('div', prefix + '-tip-container', container);
					this._tip = create$1('div', prefix + '-tip', this._tipContainer);

					if (this.options.closeButton) {
						var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
						closeButton.href = '#close';
						closeButton.innerHTML = '&#215;';

						on(closeButton, 'click', this._onCloseButtonClick, this);
					}
				},

				_updateLayout: function _updateLayout() {
					var container = this._contentNode,
					    style = container.style;

					style.width = '';
					style.whiteSpace = 'nowrap';

					var width = container.offsetWidth;
					width = Math.min(width, this.options.maxWidth);
					width = Math.max(width, this.options.minWidth);

					style.width = width + 1 + 'px';
					style.whiteSpace = '';

					style.height = '';

					var height = container.offsetHeight,
					    maxHeight = this.options.maxHeight,
					    scrolledClass = 'leaflet-popup-scrolled';

					if (maxHeight && height > maxHeight) {
						style.height = maxHeight + 'px';
						addClass(container, scrolledClass);
					} else {
						removeClass(container, scrolledClass);
					}

					this._containerWidth = this._container.offsetWidth;
				},

				_animateZoom: function _animateZoom(e) {
					var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
					    anchor = this._getAnchor();
					setPosition(this._container, pos.add(anchor));
				},

				_adjustPan: function _adjustPan() {
					if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
						return;
					}

					var map = this._map,
					    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
					    containerHeight = this._container.offsetHeight + marginBottom,
					    containerWidth = this._containerWidth,
					    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

					layerPos._add(getPosition(this._container));

					var containerPos = map.layerPointToContainerPoint(layerPos),
					    padding = toPoint(this.options.autoPanPadding),
					    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
					    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
					    size = map.getSize(),
					    dx = 0,
					    dy = 0;

					if (containerPos.x + containerWidth + paddingBR.x > size.x) {
						// right
						dx = containerPos.x + containerWidth - size.x + paddingBR.x;
					}
					if (containerPos.x - dx - paddingTL.x < 0) {
						// left
						dx = containerPos.x - paddingTL.x;
					}
					if (containerPos.y + containerHeight + paddingBR.y > size.y) {
						// bottom
						dy = containerPos.y + containerHeight - size.y + paddingBR.y;
					}
					if (containerPos.y - dy - paddingTL.y < 0) {
						// top
						dy = containerPos.y - paddingTL.y;
					}

					// @namespace Map
					// @section Popup events
					// @event autopanstart: Event
					// Fired when the map starts autopanning when opening a popup.
					if (dx || dy) {
						map.fire('autopanstart').panBy([dx, dy]);
					}
				},

				_onCloseButtonClick: function _onCloseButtonClick(e) {
					this._close();
					stop(e);
				},

				_getAnchor: function _getAnchor() {
					// Where should we anchor the popup on the source layer?
					return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
				}

			});

			// @namespace Popup
			// @factory L.popup(options?: Popup options, source?: Layer)
			// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
			var popup = function popup(options, source) {
				return new Popup(options, source);
			};

			/* @namespace Map
    * @section Interaction Options
    * @option closePopupOnClick: Boolean = true
    * Set it to `false` if you don't want popups to close when user clicks the map.
    */
			Map.mergeOptions({
				closePopupOnClick: true
			});

			// @namespace Map
			// @section Methods for Layers and Controls
			Map.include({
				// @method openPopup(popup: Popup): this
				// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
				// @alternative
				// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
				// Creates a popup with the specified content and options and opens it in the given point on a map.
				openPopup: function openPopup(popup, latlng, options) {
					if (!(popup instanceof Popup)) {
						popup = new Popup(options).setContent(popup);
					}

					if (latlng) {
						popup.setLatLng(latlng);
					}

					if (this.hasLayer(popup)) {
						return this;
					}

					if (this._popup && this._popup.options.autoClose) {
						this.closePopup();
					}

					this._popup = popup;
					return this.addLayer(popup);
				},

				// @method closePopup(popup?: Popup): this
				// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
				closePopup: function closePopup(popup) {
					if (!popup || popup === this._popup) {
						popup = this._popup;
						this._popup = null;
					}
					if (popup) {
						this.removeLayer(popup);
					}
					return this;
				}
			});

			/*
    * @namespace Layer
    * @section Popup methods example
    *
    * All layers share a set of methods convenient for binding popups to it.
    *
    * ```js
    * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
    * layer.openPopup();
    * layer.closePopup();
    * ```
    *
    * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
    */

			// @section Popup methods
			Layer.include({

				// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
				// Binds a popup to the layer with the passed `content` and sets up the
				// necessary event listeners. If a `Function` is passed it will receive
				// the layer as the first argument and should return a `String` or `HTMLElement`.
				bindPopup: function bindPopup(content, options) {

					if (content instanceof Popup) {
						setOptions(content, options);
						this._popup = content;
						content._source = this;
					} else {
						if (!this._popup || options) {
							this._popup = new Popup(options, this);
						}
						this._popup.setContent(content);
					}

					if (!this._popupHandlersAdded) {
						this.on({
							click: this._openPopup,
							keypress: this._onKeyPress,
							remove: this.closePopup,
							move: this._movePopup
						});
						this._popupHandlersAdded = true;
					}

					return this;
				},

				// @method unbindPopup(): this
				// Removes the popup previously bound with `bindPopup`.
				unbindPopup: function unbindPopup() {
					if (this._popup) {
						this.off({
							click: this._openPopup,
							keypress: this._onKeyPress,
							remove: this.closePopup,
							move: this._movePopup
						});
						this._popupHandlersAdded = false;
						this._popup = null;
					}
					return this;
				},

				// @method openPopup(latlng?: LatLng): this
				// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
				openPopup: function openPopup(layer, latlng) {
					if (!(layer instanceof Layer)) {
						latlng = layer;
						layer = this;
					}

					if (layer instanceof FeatureGroup) {
						for (var id in this._layers) {
							layer = this._layers[id];
							break;
						}
					}

					if (!latlng) {
						latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
					}

					if (this._popup && this._map) {
						// set popup source to this layer
						this._popup._source = layer;

						// update the popup (content, layout, ect...)
						this._popup.update();

						// open the popup on the map
						this._map.openPopup(this._popup, latlng);
					}

					return this;
				},

				// @method closePopup(): this
				// Closes the popup bound to this layer if it is open.
				closePopup: function closePopup() {
					if (this._popup) {
						this._popup._close();
					}
					return this;
				},

				// @method togglePopup(): this
				// Opens or closes the popup bound to this layer depending on its current state.
				togglePopup: function togglePopup(target) {
					if (this._popup) {
						if (this._popup._map) {
							this.closePopup();
						} else {
							this.openPopup(target);
						}
					}
					return this;
				},

				// @method isPopupOpen(): boolean
				// Returns `true` if the popup bound to this layer is currently open.
				isPopupOpen: function isPopupOpen() {
					return this._popup ? this._popup.isOpen() : false;
				},

				// @method setPopupContent(content: String|HTMLElement|Popup): this
				// Sets the content of the popup bound to this layer.
				setPopupContent: function setPopupContent(content) {
					if (this._popup) {
						this._popup.setContent(content);
					}
					return this;
				},

				// @method getPopup(): Popup
				// Returns the popup bound to this layer.
				getPopup: function getPopup() {
					return this._popup;
				},

				_openPopup: function _openPopup(e) {
					var layer = e.layer || e.target;

					if (!this._popup) {
						return;
					}

					if (!this._map) {
						return;
					}

					// prevent map click
					stop(e);

					// if this inherits from Path its a vector and we can just
					// open the popup at the new location
					if (layer instanceof Path) {
						this.openPopup(e.layer || e.target, e.latlng);
						return;
					}

					// otherwise treat it like a marker and figure out
					// if we should toggle it open/closed
					if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
						this.closePopup();
					} else {
						this.openPopup(layer, e.latlng);
					}
				},

				_movePopup: function _movePopup(e) {
					this._popup.setLatLng(e.latlng);
				},

				_onKeyPress: function _onKeyPress(e) {
					if (e.originalEvent.keyCode === 13) {
						this._openPopup(e);
					}
				}
			});

			/*
    * @class Tooltip
    * @inherits DivOverlay
    * @aka L.Tooltip
    * Used to display small texts on top of map layers.
    *
    * @example
    *
    * ```js
    * marker.bindTooltip("my tooltip text").openTooltip();
    * ```
    * Note about tooltip offset. Leaflet takes two options in consideration
    * for computing tooltip offsetting:
    * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
    *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
    *   move it to the bottom. Negatives will move to the left and top.
    * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
    *   should adapt this value if you use a custom icon.
    */

			// @namespace Tooltip
			var Tooltip = DivOverlay.extend({

				// @section
				// @aka Tooltip options
				options: {
					// @option pane: String = 'tooltipPane'
					// `Map pane` where the tooltip will be added.
					pane: 'tooltipPane',

					// @option offset: Point = Point(0, 0)
					// Optional offset of the tooltip position.
					offset: [0, 0],

					// @option direction: String = 'auto'
					// Direction where to open the tooltip. Possible values are: `right`, `left`,
					// `top`, `bottom`, `center`, `auto`.
					// `auto` will dynamically switch between `right` and `left` according to the tooltip
					// position on the map.
					direction: 'auto',

					// @option permanent: Boolean = false
					// Whether to open the tooltip permanently or only on mouseover.
					permanent: false,

					// @option sticky: Boolean = false
					// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
					sticky: false,

					// @option interactive: Boolean = false
					// If true, the tooltip will listen to the feature events.
					interactive: false,

					// @option opacity: Number = 0.9
					// Tooltip container opacity.
					opacity: 0.9
				},

				onAdd: function onAdd(map) {
					DivOverlay.prototype.onAdd.call(this, map);
					this.setOpacity(this.options.opacity);

					// @namespace Map
					// @section Tooltip events
					// @event tooltipopen: TooltipEvent
					// Fired when a tooltip is opened in the map.
					map.fire('tooltipopen', { tooltip: this });

					if (this._source) {
						// @namespace Layer
						// @section Tooltip events
						// @event tooltipopen: TooltipEvent
						// Fired when a tooltip bound to this layer is opened.
						this._source.fire('tooltipopen', { tooltip: this }, true);
					}
				},

				onRemove: function onRemove(map) {
					DivOverlay.prototype.onRemove.call(this, map);

					// @namespace Map
					// @section Tooltip events
					// @event tooltipclose: TooltipEvent
					// Fired when a tooltip in the map is closed.
					map.fire('tooltipclose', { tooltip: this });

					if (this._source) {
						// @namespace Layer
						// @section Tooltip events
						// @event tooltipclose: TooltipEvent
						// Fired when a tooltip bound to this layer is closed.
						this._source.fire('tooltipclose', { tooltip: this }, true);
					}
				},

				getEvents: function getEvents() {
					var events = DivOverlay.prototype.getEvents.call(this);

					if (touch && !this.options.permanent) {
						events.preclick = this._close;
					}

					return events;
				},

				_close: function _close() {
					if (this._map) {
						this._map.closeTooltip(this);
					}
				},

				_initLayout: function _initLayout() {
					var prefix = 'leaflet-tooltip',
					    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

					this._contentNode = this._container = create$1('div', className);
				},

				_updateLayout: function _updateLayout() {},

				_adjustPan: function _adjustPan() {},

				_setPosition: function _setPosition(pos) {
					var map = this._map,
					    container = this._container,
					    centerPoint = map.latLngToContainerPoint(map.getCenter()),
					    tooltipPoint = map.layerPointToContainerPoint(pos),
					    direction = this.options.direction,
					    tooltipWidth = container.offsetWidth,
					    tooltipHeight = container.offsetHeight,
					    offset = toPoint(this.options.offset),
					    anchor = this._getAnchor();

					if (direction === 'top') {
						pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
					} else if (direction === 'bottom') {
						pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
					} else if (direction === 'center') {
						pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
					} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
						direction = 'right';
						pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
					} else {
						direction = 'left';
						pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
					}

					removeClass(container, 'leaflet-tooltip-right');
					removeClass(container, 'leaflet-tooltip-left');
					removeClass(container, 'leaflet-tooltip-top');
					removeClass(container, 'leaflet-tooltip-bottom');
					addClass(container, 'leaflet-tooltip-' + direction);
					setPosition(container, pos);
				},

				_updatePosition: function _updatePosition() {
					var pos = this._map.latLngToLayerPoint(this._latlng);
					this._setPosition(pos);
				},

				setOpacity: function setOpacity(opacity) {
					this.options.opacity = opacity;

					if (this._container) {
						_setOpacity(this._container, opacity);
					}
				},

				_animateZoom: function _animateZoom(e) {
					var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
					this._setPosition(pos);
				},

				_getAnchor: function _getAnchor() {
					// Where should we anchor the tooltip on the source layer?
					return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
				}

			});

			// @namespace Tooltip
			// @factory L.tooltip(options?: Tooltip options, source?: Layer)
			// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
			var tooltip = function tooltip(options, source) {
				return new Tooltip(options, source);
			};

			// @namespace Map
			// @section Methods for Layers and Controls
			Map.include({

				// @method openTooltip(tooltip: Tooltip): this
				// Opens the specified tooltip.
				// @alternative
				// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
				// Creates a tooltip with the specified content and options and open it.
				openTooltip: function openTooltip(tooltip, latlng, options) {
					if (!(tooltip instanceof Tooltip)) {
						tooltip = new Tooltip(options).setContent(tooltip);
					}

					if (latlng) {
						tooltip.setLatLng(latlng);
					}

					if (this.hasLayer(tooltip)) {
						return this;
					}

					return this.addLayer(tooltip);
				},

				// @method closeTooltip(tooltip?: Tooltip): this
				// Closes the tooltip given as parameter.
				closeTooltip: function closeTooltip(tooltip) {
					if (tooltip) {
						this.removeLayer(tooltip);
					}
					return this;
				}

			});

			/*
    * @namespace Layer
    * @section Tooltip methods example
    *
    * All layers share a set of methods convenient for binding tooltips to it.
    *
    * ```js
    * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
    * layer.openTooltip();
    * layer.closeTooltip();
    * ```
    */

			// @section Tooltip methods
			Layer.include({

				// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
				// Binds a tooltip to the layer with the passed `content` and sets up the
				// necessary event listeners. If a `Function` is passed it will receive
				// the layer as the first argument and should return a `String` or `HTMLElement`.
				bindTooltip: function bindTooltip(content, options) {

					if (content instanceof Tooltip) {
						setOptions(content, options);
						this._tooltip = content;
						content._source = this;
					} else {
						if (!this._tooltip || options) {
							this._tooltip = new Tooltip(options, this);
						}
						this._tooltip.setContent(content);
					}

					this._initTooltipInteractions();

					if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
						this.openTooltip();
					}

					return this;
				},

				// @method unbindTooltip(): this
				// Removes the tooltip previously bound with `bindTooltip`.
				unbindTooltip: function unbindTooltip() {
					if (this._tooltip) {
						this._initTooltipInteractions(true);
						this.closeTooltip();
						this._tooltip = null;
					}
					return this;
				},

				_initTooltipInteractions: function _initTooltipInteractions(remove$$1) {
					if (!remove$$1 && this._tooltipHandlersAdded) {
						return;
					}
					var onOff = remove$$1 ? 'off' : 'on',
					    events = {
						remove: this.closeTooltip,
						move: this._moveTooltip
					};
					if (!this._tooltip.options.permanent) {
						events.mouseover = this._openTooltip;
						events.mouseout = this.closeTooltip;
						if (this._tooltip.options.sticky) {
							events.mousemove = this._moveTooltip;
						}
						if (touch) {
							events.click = this._openTooltip;
						}
					} else {
						events.add = this._openTooltip;
					}
					this[onOff](events);
					this._tooltipHandlersAdded = !remove$$1;
				},

				// @method openTooltip(latlng?: LatLng): this
				// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
				openTooltip: function openTooltip(layer, latlng) {
					if (!(layer instanceof Layer)) {
						latlng = layer;
						layer = this;
					}

					if (layer instanceof FeatureGroup) {
						for (var id in this._layers) {
							layer = this._layers[id];
							break;
						}
					}

					if (!latlng) {
						latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
					}

					if (this._tooltip && this._map) {

						// set tooltip source to this layer
						this._tooltip._source = layer;

						// update the tooltip (content, layout, ect...)
						this._tooltip.update();

						// open the tooltip on the map
						this._map.openTooltip(this._tooltip, latlng);

						// Tooltip container may not be defined if not permanent and never
						// opened.
						if (this._tooltip.options.interactive && this._tooltip._container) {
							addClass(this._tooltip._container, 'leaflet-clickable');
							this.addInteractiveTarget(this._tooltip._container);
						}
					}

					return this;
				},

				// @method closeTooltip(): this
				// Closes the tooltip bound to this layer if it is open.
				closeTooltip: function closeTooltip() {
					if (this._tooltip) {
						this._tooltip._close();
						if (this._tooltip.options.interactive && this._tooltip._container) {
							removeClass(this._tooltip._container, 'leaflet-clickable');
							this.removeInteractiveTarget(this._tooltip._container);
						}
					}
					return this;
				},

				// @method toggleTooltip(): this
				// Opens or closes the tooltip bound to this layer depending on its current state.
				toggleTooltip: function toggleTooltip(target) {
					if (this._tooltip) {
						if (this._tooltip._map) {
							this.closeTooltip();
						} else {
							this.openTooltip(target);
						}
					}
					return this;
				},

				// @method isTooltipOpen(): boolean
				// Returns `true` if the tooltip bound to this layer is currently open.
				isTooltipOpen: function isTooltipOpen() {
					return this._tooltip.isOpen();
				},

				// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
				// Sets the content of the tooltip bound to this layer.
				setTooltipContent: function setTooltipContent(content) {
					if (this._tooltip) {
						this._tooltip.setContent(content);
					}
					return this;
				},

				// @method getTooltip(): Tooltip
				// Returns the tooltip bound to this layer.
				getTooltip: function getTooltip() {
					return this._tooltip;
				},

				_openTooltip: function _openTooltip(e) {
					var layer = e.layer || e.target;

					if (!this._tooltip || !this._map) {
						return;
					}
					this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
				},

				_moveTooltip: function _moveTooltip(e) {
					var latlng = e.latlng,
					    containerPoint,
					    layerPoint;
					if (this._tooltip.options.sticky && e.originalEvent) {
						containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
						layerPoint = this._map.containerPointToLayerPoint(containerPoint);
						latlng = this._map.layerPointToLatLng(layerPoint);
					}
					this._tooltip.setLatLng(latlng);
				}
			});

			/*
    * @class DivIcon
    * @aka L.DivIcon
    * @inherits Icon
    *
    * Represents a lightweight icon for markers that uses a simple `<div>`
    * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
    *
    * @example
    * ```js
    * var myIcon = L.divIcon({className: 'my-div-icon'});
    * // you can set .my-div-icon styles in CSS
    *
    * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
    * ```
    *
    * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
    */

			var DivIcon = Icon.extend({
				options: {
					// @section
					// @aka DivIcon options
					iconSize: [12, 12], // also can be set through CSS

					// iconAnchor: (Point),
					// popupAnchor: (Point),

					// @option html: String = ''
					// Custom HTML code to put inside the div element, empty by default.
					html: false,

					// @option bgPos: Point = [0, 0]
					// Optional relative position of the background, in pixels
					bgPos: null,

					className: 'leaflet-div-icon'
				},

				createIcon: function createIcon(oldIcon) {
					var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
					    options = this.options;

					div.innerHTML = options.html !== false ? options.html : '';

					if (options.bgPos) {
						var bgPos = toPoint(options.bgPos);
						div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
					}
					this._setIconStyles(div, 'icon');

					return div;
				},

				createShadow: function createShadow() {
					return null;
				}
			});

			// @factory L.divIcon(options: DivIcon options)
			// Creates a `DivIcon` instance with the given options.
			function divIcon(options) {
				return new DivIcon(options);
			}

			Icon.Default = IconDefault;

			/*
    * @class GridLayer
    * @inherits Layer
    * @aka L.GridLayer
    *
    * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
    * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
    *
    *
    * @section Synchronous usage
    * @example
    *
    * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
    *
    * ```js
    * var CanvasLayer = L.GridLayer.extend({
    *     createTile: function(coords){
    *         // create a <canvas> element for drawing
    *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
    *
    *         // setup tile width and height according to the options
    *         var size = this.getTileSize();
    *         tile.width = size.x;
    *         tile.height = size.y;
    *
    *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
    *         var ctx = tile.getContext('2d');
    *
    *         // return the tile so it can be rendered on screen
    *         return tile;
    *     }
    * });
    * ```
    *
    * @section Asynchronous usage
    * @example
    *
    * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
    *
    * ```js
    * var CanvasLayer = L.GridLayer.extend({
    *     createTile: function(coords, done){
    *         var error;
    *
    *         // create a <canvas> element for drawing
    *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
    *
    *         // setup tile width and height according to the options
    *         var size = this.getTileSize();
    *         tile.width = size.x;
    *         tile.height = size.y;
    *
    *         // draw something asynchronously and pass the tile to the done() callback
    *         setTimeout(function() {
    *             done(error, tile);
    *         }, 1000);
    *
    *         return tile;
    *     }
    * });
    * ```
    *
    * @section
    */

			var GridLayer = Layer.extend({

				// @section
				// @aka GridLayer options
				options: {
					// @option tileSize: Number|Point = 256
					// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
					tileSize: 256,

					// @option opacity: Number = 1.0
					// Opacity of the tiles. Can be used in the `createTile()` function.
					opacity: 1,

					// @option updateWhenIdle: Boolean = (depends)
					// Load new tiles only when panning ends.
					// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
					// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
					// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
					updateWhenIdle: mobile,

					// @option updateWhenZooming: Boolean = true
					// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
					updateWhenZooming: true,

					// @option updateInterval: Number = 200
					// Tiles will not update more than once every `updateInterval` milliseconds when panning.
					updateInterval: 200,

					// @option zIndex: Number = 1
					// The explicit zIndex of the tile layer.
					zIndex: 1,

					// @option bounds: LatLngBounds = undefined
					// If set, tiles will only be loaded inside the set `LatLngBounds`.
					bounds: null,

					// @option minZoom: Number = 0
					// The minimum zoom level down to which this layer will be displayed (inclusive).
					minZoom: 0,

					// @option maxZoom: Number = undefined
					// The maximum zoom level up to which this layer will be displayed (inclusive).
					maxZoom: undefined,

					// @option maxNativeZoom: Number = undefined
					// Maximum zoom number the tile source has available. If it is specified,
					// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
					// from `maxNativeZoom` level and auto-scaled.
					maxNativeZoom: undefined,

					// @option minNativeZoom: Number = undefined
					// Minimum zoom number the tile source has available. If it is specified,
					// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
					// from `minNativeZoom` level and auto-scaled.
					minNativeZoom: undefined,

					// @option noWrap: Boolean = false
					// Whether the layer is wrapped around the antimeridian. If `true`, the
					// GridLayer will only be displayed once at low zoom levels. Has no
					// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
					// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
					// tiles outside the CRS limits.
					noWrap: false,

					// @option pane: String = 'tilePane'
					// `Map pane` where the grid layer will be added.
					pane: 'tilePane',

					// @option className: String = ''
					// A custom class name to assign to the tile layer. Empty by default.
					className: '',

					// @option keepBuffer: Number = 2
					// When panning the map, keep this many rows and columns of tiles before unloading them.
					keepBuffer: 2
				},

				initialize: function initialize(options) {
					setOptions(this, options);
				},

				onAdd: function onAdd() {
					this._initContainer();

					this._levels = {};
					this._tiles = {};

					this._resetView();
					this._update();
				},

				beforeAdd: function beforeAdd(map) {
					map._addZoomLimit(this);
				},

				onRemove: function onRemove(map) {
					this._removeAllTiles();
					_remove(this._container);
					map._removeZoomLimit(this);
					this._container = null;
					this._tileZoom = undefined;
				},

				// @method bringToFront: this
				// Brings the tile layer to the top of all tile layers.
				bringToFront: function bringToFront() {
					if (this._map) {
						toFront(this._container);
						this._setAutoZIndex(Math.max);
					}
					return this;
				},

				// @method bringToBack: this
				// Brings the tile layer to the bottom of all tile layers.
				bringToBack: function bringToBack() {
					if (this._map) {
						toBack(this._container);
						this._setAutoZIndex(Math.min);
					}
					return this;
				},

				// @method getContainer: HTMLElement
				// Returns the HTML element that contains the tiles for this layer.
				getContainer: function getContainer() {
					return this._container;
				},

				// @method setOpacity(opacity: Number): this
				// Changes the [opacity](#gridlayer-opacity) of the grid layer.
				setOpacity: function setOpacity(opacity) {
					this.options.opacity = opacity;
					this._updateOpacity();
					return this;
				},

				// @method setZIndex(zIndex: Number): this
				// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
				setZIndex: function setZIndex(zIndex) {
					this.options.zIndex = zIndex;
					this._updateZIndex();

					return this;
				},

				// @method isLoading: Boolean
				// Returns `true` if any tile in the grid layer has not finished loading.
				isLoading: function isLoading() {
					return this._loading;
				},

				// @method redraw: this
				// Causes the layer to clear all the tiles and request them again.
				redraw: function redraw() {
					if (this._map) {
						this._removeAllTiles();
						this._update();
					}
					return this;
				},

				getEvents: function getEvents() {
					var events = {
						viewprereset: this._invalidateAll,
						viewreset: this._resetView,
						zoom: this._resetView,
						moveend: this._onMoveEnd
					};

					if (!this.options.updateWhenIdle) {
						// update tiles on move, but not more often than once per given interval
						if (!this._onMove) {
							this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
						}

						events.move = this._onMove;
					}

					if (this._zoomAnimated) {
						events.zoomanim = this._animateZoom;
					}

					return events;
				},

				// @section Extension methods
				// Layers extending `GridLayer` shall reimplement the following method.
				// @method createTile(coords: Object, done?: Function): HTMLElement
				// Called only internally, must be overridden by classes extending `GridLayer`.
				// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
				// is specified, it must be called when the tile has finished loading and drawing.
				createTile: function createTile() {
					return document.createElement('div');
				},

				// @section
				// @method getTileSize: Point
				// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
				getTileSize: function getTileSize() {
					var s = this.options.tileSize;
					return s instanceof Point ? s : new Point(s, s);
				},

				_updateZIndex: function _updateZIndex() {
					if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
						this._container.style.zIndex = this.options.zIndex;
					}
				},

				_setAutoZIndex: function _setAutoZIndex(compare) {
					// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

					var layers = this.getPane().children,
					    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

					for (var i = 0, len = layers.length, zIndex; i < len; i++) {

						zIndex = layers[i].style.zIndex;

						if (layers[i] !== this._container && zIndex) {
							edgeZIndex = compare(edgeZIndex, +zIndex);
						}
					}

					if (isFinite(edgeZIndex)) {
						this.options.zIndex = edgeZIndex + compare(-1, 1);
						this._updateZIndex();
					}
				},

				_updateOpacity: function _updateOpacity() {
					if (!this._map) {
						return;
					}

					// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
					if (ielt9) {
						return;
					}

					_setOpacity(this._container, this.options.opacity);

					var now = +new Date(),
					    nextFrame = false,
					    willPrune = false;

					for (var key in this._tiles) {
						var tile = this._tiles[key];
						if (!tile.current || !tile.loaded) {
							continue;
						}

						var fade = Math.min(1, (now - tile.loaded) / 200);

						_setOpacity(tile.el, fade);
						if (fade < 1) {
							nextFrame = true;
						} else {
							if (tile.active) {
								willPrune = true;
							} else {
								this._onOpaqueTile(tile);
							}
							tile.active = true;
						}
					}

					if (willPrune && !this._noPrune) {
						this._pruneTiles();
					}

					if (nextFrame) {
						cancelAnimFrame(this._fadeFrame);
						this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
					}
				},

				_onOpaqueTile: falseFn,

				_initContainer: function _initContainer() {
					if (this._container) {
						return;
					}

					this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
					this._updateZIndex();

					if (this.options.opacity < 1) {
						this._updateOpacity();
					}

					this.getPane().appendChild(this._container);
				},

				_updateLevels: function _updateLevels() {

					var zoom = this._tileZoom,
					    maxZoom = this.options.maxZoom;

					if (zoom === undefined) {
						return undefined;
					}

					for (var z in this._levels) {
						if (this._levels[z].el.children.length || z === zoom) {
							this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
							this._onUpdateLevel(z);
						} else {
							_remove(this._levels[z].el);
							this._removeTilesAtZoom(z);
							this._onRemoveLevel(z);
							delete this._levels[z];
						}
					}

					var level = this._levels[zoom],
					    map = this._map;

					if (!level) {
						level = this._levels[zoom] = {};

						level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
						level.el.style.zIndex = maxZoom;

						level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
						level.zoom = zoom;

						this._setZoomTransform(level, map.getCenter(), map.getZoom());

						// force the browser to consider the newly added element for transition
						falseFn(level.el.offsetWidth);

						this._onCreateLevel(level);
					}

					this._level = level;

					return level;
				},

				_onUpdateLevel: falseFn,

				_onRemoveLevel: falseFn,

				_onCreateLevel: falseFn,

				_pruneTiles: function _pruneTiles() {
					if (!this._map) {
						return;
					}

					var key, tile;

					var zoom = this._map.getZoom();
					if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
						this._removeAllTiles();
						return;
					}

					for (key in this._tiles) {
						tile = this._tiles[key];
						tile.retain = tile.current;
					}

					for (key in this._tiles) {
						tile = this._tiles[key];
						if (tile.current && !tile.active) {
							var coords = tile.coords;
							if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
								this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
							}
						}
					}

					for (key in this._tiles) {
						if (!this._tiles[key].retain) {
							this._removeTile(key);
						}
					}
				},

				_removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
					for (var key in this._tiles) {
						if (this._tiles[key].coords.z !== zoom) {
							continue;
						}
						this._removeTile(key);
					}
				},

				_removeAllTiles: function _removeAllTiles() {
					for (var key in this._tiles) {
						this._removeTile(key);
					}
				},

				_invalidateAll: function _invalidateAll() {
					for (var z in this._levels) {
						_remove(this._levels[z].el);
						this._onRemoveLevel(z);
						delete this._levels[z];
					}
					this._removeAllTiles();

					this._tileZoom = undefined;
				},

				_retainParent: function _retainParent(x, y, z, minZoom) {
					var x2 = Math.floor(x / 2),
					    y2 = Math.floor(y / 2),
					    z2 = z - 1,
					    coords2 = new Point(+x2, +y2);
					coords2.z = +z2;

					var key = this._tileCoordsToKey(coords2),
					    tile = this._tiles[key];

					if (tile && tile.active) {
						tile.retain = true;
						return true;
					} else if (tile && tile.loaded) {
						tile.retain = true;
					}

					if (z2 > minZoom) {
						return this._retainParent(x2, y2, z2, minZoom);
					}

					return false;
				},

				_retainChildren: function _retainChildren(x, y, z, maxZoom) {

					for (var i = 2 * x; i < 2 * x + 2; i++) {
						for (var j = 2 * y; j < 2 * y + 2; j++) {

							var coords = new Point(i, j);
							coords.z = z + 1;

							var key = this._tileCoordsToKey(coords),
							    tile = this._tiles[key];

							if (tile && tile.active) {
								tile.retain = true;
								continue;
							} else if (tile && tile.loaded) {
								tile.retain = true;
							}

							if (z + 1 < maxZoom) {
								this._retainChildren(i, j, z + 1, maxZoom);
							}
						}
					}
				},

				_resetView: function _resetView(e) {
					var animating = e && (e.pinch || e.flyTo);
					this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
				},

				_animateZoom: function _animateZoom(e) {
					this._setView(e.center, e.zoom, true, e.noUpdate);
				},

				_clampZoom: function _clampZoom(zoom) {
					var options = this.options;

					if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
						return options.minNativeZoom;
					}

					if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
						return options.maxNativeZoom;
					}

					return zoom;
				},

				_setView: function _setView(center, zoom, noPrune, noUpdate) {
					var tileZoom = this._clampZoom(Math.round(zoom));
					if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
						tileZoom = undefined;
					}

					var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

					if (!noUpdate || tileZoomChanged) {

						this._tileZoom = tileZoom;

						if (this._abortLoading) {
							this._abortLoading();
						}

						this._updateLevels();
						this._resetGrid();

						if (tileZoom !== undefined) {
							this._update(center);
						}

						if (!noPrune) {
							this._pruneTiles();
						}

						// Flag to prevent _updateOpacity from pruning tiles during
						// a zoom anim or a pinch gesture
						this._noPrune = !!noPrune;
					}

					this._setZoomTransforms(center, zoom);
				},

				_setZoomTransforms: function _setZoomTransforms(center, zoom) {
					for (var i in this._levels) {
						this._setZoomTransform(this._levels[i], center, zoom);
					}
				},

				_setZoomTransform: function _setZoomTransform(level, center, zoom) {
					var scale = this._map.getZoomScale(zoom, level.zoom),
					    translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

					if (any3d) {
						setTransform(level.el, translate, scale);
					} else {
						setPosition(level.el, translate);
					}
				},

				_resetGrid: function _resetGrid() {
					var map = this._map,
					    crs = map.options.crs,
					    tileSize = this._tileSize = this.getTileSize(),
					    tileZoom = this._tileZoom;

					var bounds = this._map.getPixelWorldBounds(this._tileZoom);
					if (bounds) {
						this._globalTileRange = this._pxBoundsToTileRange(bounds);
					}

					this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
					this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
				},

				_onMoveEnd: function _onMoveEnd() {
					if (!this._map || this._map._animatingZoom) {
						return;
					}

					this._update();
				},

				_getTiledPixelBounds: function _getTiledPixelBounds(center) {
					var map = this._map,
					    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
					    scale = map.getZoomScale(mapZoom, this._tileZoom),
					    pixelCenter = map.project(center, this._tileZoom).floor(),
					    halfSize = map.getSize().divideBy(scale * 2);

					return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
				},

				// Private method to load tiles in the grid's active zoom level according to map bounds
				_update: function _update(center) {
					var map = this._map;
					if (!map) {
						return;
					}
					var zoom = this._clampZoom(map.getZoom());

					if (center === undefined) {
						center = map.getCenter();
					}
					if (this._tileZoom === undefined) {
						return;
					} // if out of minzoom/maxzoom

					var pixelBounds = this._getTiledPixelBounds(center),
					    tileRange = this._pxBoundsToTileRange(pixelBounds),
					    tileCenter = tileRange.getCenter(),
					    queue = [],
					    margin = this.options.keepBuffer,
					    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

					// Sanity check: panic if the tile range contains Infinity somewhere.
					if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
						throw new Error('Attempted to load an infinite number of tiles');
					}

					for (var key in this._tiles) {
						var c = this._tiles[key].coords;
						if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
							this._tiles[key].current = false;
						}
					}

					// _update just loads more tiles. If the tile zoom level differs too much
					// from the map's, let _setView reset levels and prune old tiles.
					if (Math.abs(zoom - this._tileZoom) > 1) {
						this._setView(center, zoom);return;
					}

					// create a queue of coordinates to load tiles from
					for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
						for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
							var coords = new Point(i, j);
							coords.z = this._tileZoom;

							if (!this._isValidTile(coords)) {
								continue;
							}

							var tile = this._tiles[this._tileCoordsToKey(coords)];
							if (tile) {
								tile.current = true;
							} else {
								queue.push(coords);
							}
						}
					}

					// sort tile queue to load tiles in order of their distance to center
					queue.sort(function (a, b) {
						return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
					});

					if (queue.length !== 0) {
						// if it's the first batch of tiles to load
						if (!this._loading) {
							this._loading = true;
							// @event loading: Event
							// Fired when the grid layer starts loading tiles.
							this.fire('loading');
						}

						// create DOM fragment to append tiles in one batch
						var fragment = document.createDocumentFragment();

						for (i = 0; i < queue.length; i++) {
							this._addTile(queue[i], fragment);
						}

						this._level.el.appendChild(fragment);
					}
				},

				_isValidTile: function _isValidTile(coords) {
					var crs = this._map.options.crs;

					if (!crs.infinite) {
						// don't load tile if it's out of bounds and not wrapped
						var bounds = this._globalTileRange;
						if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
							return false;
						}
					}

					if (!this.options.bounds) {
						return true;
					}

					// don't load tile if it doesn't intersect the bounds in options
					var tileBounds = this._tileCoordsToBounds(coords);
					return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
				},

				_keyToBounds: function _keyToBounds(key) {
					return this._tileCoordsToBounds(this._keyToTileCoords(key));
				},

				_tileCoordsToNwSe: function _tileCoordsToNwSe(coords) {
					var map = this._map,
					    tileSize = this.getTileSize(),
					    nwPoint = coords.scaleBy(tileSize),
					    sePoint = nwPoint.add(tileSize),
					    nw = map.unproject(nwPoint, coords.z),
					    se = map.unproject(sePoint, coords.z);
					return [nw, se];
				},

				// converts tile coordinates to its geographical bounds
				_tileCoordsToBounds: function _tileCoordsToBounds(coords) {
					var bp = this._tileCoordsToNwSe(coords),
					    bounds = new LatLngBounds(bp[0], bp[1]);

					if (!this.options.noWrap) {
						bounds = this._map.wrapLatLngBounds(bounds);
					}
					return bounds;
				},
				// converts tile coordinates to key for the tile cache
				_tileCoordsToKey: function _tileCoordsToKey(coords) {
					return coords.x + ':' + coords.y + ':' + coords.z;
				},

				// converts tile cache key to coordinates
				_keyToTileCoords: function _keyToTileCoords(key) {
					var k = key.split(':'),
					    coords = new Point(+k[0], +k[1]);
					coords.z = +k[2];
					return coords;
				},

				_removeTile: function _removeTile(key) {
					var tile = this._tiles[key];
					if (!tile) {
						return;
					}

					// Cancels any pending http requests associated with the tile
					// unless we're on Android's stock browser,
					// see https://github.com/Leaflet/Leaflet/issues/137
					if (!androidStock) {
						tile.el.setAttribute('src', emptyImageUrl);
					}
					_remove(tile.el);

					delete this._tiles[key];

					// @event tileunload: TileEvent
					// Fired when a tile is removed (e.g. when a tile goes off the screen).
					this.fire('tileunload', {
						tile: tile.el,
						coords: this._keyToTileCoords(key)
					});
				},

				_initTile: function _initTile(tile) {
					addClass(tile, 'leaflet-tile');

					var tileSize = this.getTileSize();
					tile.style.width = tileSize.x + 'px';
					tile.style.height = tileSize.y + 'px';

					tile.onselectstart = falseFn;
					tile.onmousemove = falseFn;

					// update opacity on tiles in IE7-8 because of filter inheritance problems
					if (ielt9 && this.options.opacity < 1) {
						_setOpacity(tile, this.options.opacity);
					}

					// without this hack, tiles disappear after zoom on Chrome for Android
					// https://github.com/Leaflet/Leaflet/issues/2078
					if (android && !android23) {
						tile.style.WebkitBackfaceVisibility = 'hidden';
					}
				},

				_addTile: function _addTile(coords, container) {
					var tilePos = this._getTilePos(coords),
					    key = this._tileCoordsToKey(coords);

					var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

					this._initTile(tile);

					// if createTile is defined with a second argument ("done" callback),
					// we know that tile is async and will be ready later; otherwise
					if (this.createTile.length < 2) {
						// mark tile as ready, but delay one frame for opacity animation to happen
						requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
					}

					setPosition(tile, tilePos);

					// save tile in cache
					this._tiles[key] = {
						el: tile,
						coords: coords,
						current: true
					};

					container.appendChild(tile);
					// @event tileloadstart: TileEvent
					// Fired when a tile is requested and starts loading.
					this.fire('tileloadstart', {
						tile: tile,
						coords: coords
					});
				},

				_tileReady: function _tileReady(coords, err, tile) {
					if (!this._map || tile.getAttribute('src') === emptyImageUrl) {
						return;
					}

					if (err) {
						// @event tileerror: TileErrorEvent
						// Fired when there is an error loading a tile.
						this.fire('tileerror', {
							error: err,
							tile: tile,
							coords: coords
						});
					}

					var key = this._tileCoordsToKey(coords);

					tile = this._tiles[key];
					if (!tile) {
						return;
					}

					tile.loaded = +new Date();
					if (this._map._fadeAnimated) {
						_setOpacity(tile.el, 0);
						cancelAnimFrame(this._fadeFrame);
						this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
					} else {
						tile.active = true;
						this._pruneTiles();
					}

					if (!err) {
						addClass(tile.el, 'leaflet-tile-loaded');

						// @event tileload: TileEvent
						// Fired when a tile loads.
						this.fire('tileload', {
							tile: tile.el,
							coords: coords
						});
					}

					if (this._noTilesToLoad()) {
						this._loading = false;
						// @event load: Event
						// Fired when the grid layer loaded all visible tiles.
						this.fire('load');

						if (ielt9 || !this._map._fadeAnimated) {
							requestAnimFrame(this._pruneTiles, this);
						} else {
							// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
							// to trigger a pruning.
							setTimeout(bind(this._pruneTiles, this), 250);
						}
					}
				},

				_getTilePos: function _getTilePos(coords) {
					return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
				},

				_wrapCoords: function _wrapCoords(coords) {
					var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
					newCoords.z = coords.z;
					return newCoords;
				},

				_pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
					var tileSize = this.getTileSize();
					return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
				},

				_noTilesToLoad: function _noTilesToLoad() {
					for (var key in this._tiles) {
						if (!this._tiles[key].loaded) {
							return false;
						}
					}
					return true;
				}
			});

			// @factory L.gridLayer(options?: GridLayer options)
			// Creates a new instance of GridLayer with the supplied options.
			function gridLayer(options) {
				return new GridLayer(options);
			}

			/*
    * @class TileLayer
    * @inherits GridLayer
    * @aka L.TileLayer
    * Used to load and display tile layers on the map. Extends `GridLayer`.
    *
    * @example
    *
    * ```js
    * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
    * ```
    *
    * @section URL template
    * @example
    *
    * A string of the following form:
    *
    * ```
    * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
    * ```
    *
    * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
    *
    * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
    *
    * ```
    * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
    * ```
    */

			var TileLayer = GridLayer.extend({

				// @section
				// @aka TileLayer options
				options: {
					// @option minZoom: Number = 0
					// The minimum zoom level down to which this layer will be displayed (inclusive).
					minZoom: 0,

					// @option maxZoom: Number = 18
					// The maximum zoom level up to which this layer will be displayed (inclusive).
					maxZoom: 18,

					// @option subdomains: String|String[] = 'abc'
					// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
					subdomains: 'abc',

					// @option errorTileUrl: String = ''
					// URL to the tile image to show in place of the tile that failed to load.
					errorTileUrl: '',

					// @option zoomOffset: Number = 0
					// The zoom number used in tile URLs will be offset with this value.
					zoomOffset: 0,

					// @option tms: Boolean = false
					// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
					tms: false,

					// @option zoomReverse: Boolean = false
					// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
					zoomReverse: false,

					// @option detectRetina: Boolean = false
					// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
					detectRetina: false,

					// @option crossOrigin: Boolean|String = false
					// Whether the crossOrigin attribute will be added to the tiles.
					// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
					// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
					crossOrigin: false
				},

				initialize: function initialize(url, options) {

					this._url = url;

					options = setOptions(this, options);

					// detecting retina displays, adjusting tileSize and zoom levels
					if (options.detectRetina && retina && options.maxZoom > 0) {

						options.tileSize = Math.floor(options.tileSize / 2);

						if (!options.zoomReverse) {
							options.zoomOffset++;
							options.maxZoom--;
						} else {
							options.zoomOffset--;
							options.minZoom++;
						}

						options.minZoom = Math.max(0, options.minZoom);
					}

					if (typeof options.subdomains === 'string') {
						options.subdomains = options.subdomains.split('');
					}

					// for https://github.com/Leaflet/Leaflet/issues/137
					if (!android) {
						this.on('tileunload', this._onTileRemove);
					}
				},

				// @method setUrl(url: String, noRedraw?: Boolean): this
				// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
				setUrl: function setUrl(url, noRedraw) {
					this._url = url;

					if (!noRedraw) {
						this.redraw();
					}
					return this;
				},

				// @method createTile(coords: Object, done?: Function): HTMLElement
				// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
				// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
				// callback is called when the tile has been loaded.
				createTile: function createTile(coords, done) {
					var tile = document.createElement('img');

					on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
					on(tile, 'error', bind(this._tileOnError, this, done, tile));

					if (this.options.crossOrigin || this.options.crossOrigin === '') {
						tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
					}

					/*
      Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
      http://www.w3.org/TR/WCAG20-TECHS/H67
     */
					tile.alt = '';

					/*
      Set role="presentation" to force screen readers to ignore this
      https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
     */
					tile.setAttribute('role', 'presentation');

					tile.src = this.getTileUrl(coords);

					return tile;
				},

				// @section Extension methods
				// @uninheritable
				// Layers extending `TileLayer` might reimplement the following method.
				// @method getTileUrl(coords: Object): String
				// Called only internally, returns the URL for a tile given its coordinates.
				// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
				getTileUrl: function getTileUrl(coords) {
					var data = {
						r: retina ? '@2x' : '',
						s: this._getSubdomain(coords),
						x: coords.x,
						y: coords.y,
						z: this._getZoomForUrl()
					};
					if (this._map && !this._map.options.crs.infinite) {
						var invertedY = this._globalTileRange.max.y - coords.y;
						if (this.options.tms) {
							data['y'] = invertedY;
						}
						data['-y'] = invertedY;
					}

					return template(this._url, extend(data, this.options));
				},

				_tileOnLoad: function _tileOnLoad(done, tile) {
					// For https://github.com/Leaflet/Leaflet/issues/3332
					if (ielt9) {
						setTimeout(bind(done, this, null, tile), 0);
					} else {
						done(null, tile);
					}
				},

				_tileOnError: function _tileOnError(done, tile, e) {
					var errorUrl = this.options.errorTileUrl;
					if (errorUrl && tile.getAttribute('src') !== errorUrl) {
						tile.src = errorUrl;
					}
					done(e, tile);
				},

				_onTileRemove: function _onTileRemove(e) {
					e.tile.onload = null;
				},

				_getZoomForUrl: function _getZoomForUrl() {
					var zoom = this._tileZoom,
					    maxZoom = this.options.maxZoom,
					    zoomReverse = this.options.zoomReverse,
					    zoomOffset = this.options.zoomOffset;

					if (zoomReverse) {
						zoom = maxZoom - zoom;
					}

					return zoom + zoomOffset;
				},

				_getSubdomain: function _getSubdomain(tilePoint) {
					var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
					return this.options.subdomains[index];
				},

				// stops loading all tiles in the background layer
				_abortLoading: function _abortLoading() {
					var i, tile;
					for (i in this._tiles) {
						if (this._tiles[i].coords.z !== this._tileZoom) {
							tile = this._tiles[i].el;

							tile.onload = falseFn;
							tile.onerror = falseFn;

							if (!tile.complete) {
								tile.src = emptyImageUrl;
								_remove(tile);
								delete this._tiles[i];
							}
						}
					}
				}
			});

			// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
			// Instantiates a tile layer object given a `URL template` and optionally an options object.

			function tileLayer(url, options) {
				return new TileLayer(url, options);
			}

			/*
    * @class TileLayer.WMS
    * @inherits TileLayer
    * @aka L.TileLayer.WMS
    * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
    *
    * @example
    *
    * ```js
    * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
    * 	layers: 'nexrad-n0r-900913',
    * 	format: 'image/png',
    * 	transparent: true,
    * 	attribution: "Weather data © 2012 IEM Nexrad"
    * });
    * ```
    */

			var TileLayerWMS = TileLayer.extend({

				// @section
				// @aka TileLayer.WMS options
				// If any custom options not documented here are used, they will be sent to the
				// WMS server as extra parameters in each request URL. This can be useful for
				// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
				defaultWmsParams: {
					service: 'WMS',
					request: 'GetMap',

					// @option layers: String = ''
					// **(required)** Comma-separated list of WMS layers to show.
					layers: '',

					// @option styles: String = ''
					// Comma-separated list of WMS styles.
					styles: '',

					// @option format: String = 'image/jpeg'
					// WMS image format (use `'image/png'` for layers with transparency).
					format: 'image/jpeg',

					// @option transparent: Boolean = false
					// If `true`, the WMS service will return images with transparency.
					transparent: false,

					// @option version: String = '1.1.1'
					// Version of the WMS service to use
					version: '1.1.1'
				},

				options: {
					// @option crs: CRS = null
					// Coordinate Reference System to use for the WMS requests, defaults to
					// map CRS. Don't change this if you're not sure what it means.
					crs: null,

					// @option uppercase: Boolean = false
					// If `true`, WMS request parameter keys will be uppercase.
					uppercase: false
				},

				initialize: function initialize(url, options) {

					this._url = url;

					var wmsParams = extend({}, this.defaultWmsParams);

					// all keys that are not TileLayer options go to WMS params
					for (var i in options) {
						if (!(i in this.options)) {
							wmsParams[i] = options[i];
						}
					}

					options = setOptions(this, options);

					var realRetina = options.detectRetina && retina ? 2 : 1;
					var tileSize = this.getTileSize();
					wmsParams.width = tileSize.x * realRetina;
					wmsParams.height = tileSize.y * realRetina;

					this.wmsParams = wmsParams;
				},

				onAdd: function onAdd(map) {

					this._crs = this.options.crs || map.options.crs;
					this._wmsVersion = parseFloat(this.wmsParams.version);

					var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
					this.wmsParams[projectionKey] = this._crs.code;

					TileLayer.prototype.onAdd.call(this, map);
				},

				getTileUrl: function getTileUrl(coords) {

					var tileBounds = this._tileCoordsToNwSe(coords),
					    crs = this._crs,
					    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
					    min = bounds.min,
					    max = bounds.max,
					    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
					    url = TileLayer.prototype.getTileUrl.call(this, coords);
					return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
				},

				// @method setParams(params: Object, noRedraw?: Boolean): this
				// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
				setParams: function setParams(params, noRedraw) {

					extend(this.wmsParams, params);

					if (!noRedraw) {
						this.redraw();
					}

					return this;
				}
			});

			// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
			// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
			function tileLayerWMS(url, options) {
				return new TileLayerWMS(url, options);
			}

			TileLayer.WMS = TileLayerWMS;
			tileLayer.wms = tileLayerWMS;

			/*
    * @class Renderer
    * @inherits Layer
    * @aka L.Renderer
    *
    * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
    * DOM container of the renderer, its bounds, and its zoom animation.
    *
    * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
    * itself can be added or removed to the map. All paths use a renderer, which can
    * be implicit (the map will decide the type of renderer and use it automatically)
    * or explicit (using the [`renderer`](#path-renderer) option of the path).
    *
    * Do not use this class directly, use `SVG` and `Canvas` instead.
    *
    * @event update: Event
    * Fired when the renderer updates its bounds, center and zoom, for example when
    * its map has moved
    */

			var Renderer = Layer.extend({

				// @section
				// @aka Renderer options
				options: {
					// @option padding: Number = 0.1
					// How much to extend the clip area around the map view (relative to its size)
					// e.g. 0.1 would be 10% of map view in each direction
					padding: 0.1,

					// @option tolerance: Number = 0
					// How much to extend click tolerance round a path/object on the map
					tolerance: 0
				},

				initialize: function initialize(options) {
					setOptions(this, options);
					stamp(this);
					this._layers = this._layers || {};
				},

				onAdd: function onAdd() {
					if (!this._container) {
						this._initContainer(); // defined by renderer implementations

						if (this._zoomAnimated) {
							addClass(this._container, 'leaflet-zoom-animated');
						}
					}

					this.getPane().appendChild(this._container);
					this._update();
					this.on('update', this._updatePaths, this);
				},

				onRemove: function onRemove() {
					this.off('update', this._updatePaths, this);
					this._destroyContainer();
				},

				getEvents: function getEvents() {
					var events = {
						viewreset: this._reset,
						zoom: this._onZoom,
						moveend: this._update,
						zoomend: this._onZoomEnd
					};
					if (this._zoomAnimated) {
						events.zoomanim = this._onAnimZoom;
					}
					return events;
				},

				_onAnimZoom: function _onAnimZoom(ev) {
					this._updateTransform(ev.center, ev.zoom);
				},

				_onZoom: function _onZoom() {
					this._updateTransform(this._map.getCenter(), this._map.getZoom());
				},

				_updateTransform: function _updateTransform(center, zoom) {
					var scale = this._map.getZoomScale(zoom, this._zoom),
					    position = getPosition(this._container),
					    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
					    currentCenterPoint = this._map.project(this._center, zoom),
					    destCenterPoint = this._map.project(center, zoom),
					    centerOffset = destCenterPoint.subtract(currentCenterPoint),
					    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

					if (any3d) {
						setTransform(this._container, topLeftOffset, scale);
					} else {
						setPosition(this._container, topLeftOffset);
					}
				},

				_reset: function _reset() {
					this._update();
					this._updateTransform(this._center, this._zoom);

					for (var id in this._layers) {
						this._layers[id]._reset();
					}
				},

				_onZoomEnd: function _onZoomEnd() {
					for (var id in this._layers) {
						this._layers[id]._project();
					}
				},

				_updatePaths: function _updatePaths() {
					for (var id in this._layers) {
						this._layers[id]._update();
					}
				},

				_update: function _update() {
					// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
					// Subclasses are responsible of firing the 'update' event.
					var p = this.options.padding,
					    size = this._map.getSize(),
					    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

					this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

					this._center = this._map.getCenter();
					this._zoom = this._map.getZoom();
				}
			});

			/*
    * @class Canvas
    * @inherits Renderer
    * @aka L.Canvas
    *
    * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
    * Inherits `Renderer`.
    *
    * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
    * available in all web browsers, notably IE8, and overlapping geometries might
    * not display properly in some edge cases.
    *
    * @example
    *
    * Use Canvas by default for all paths in the map:
    *
    * ```js
    * var map = L.map('map', {
    * 	renderer: L.canvas()
    * });
    * ```
    *
    * Use a Canvas renderer with extra padding for specific vector geometries:
    *
    * ```js
    * var map = L.map('map');
    * var myRenderer = L.canvas({ padding: 0.5 });
    * var line = L.polyline( coordinates, { renderer: myRenderer } );
    * var circle = L.circle( center, { renderer: myRenderer } );
    * ```
    */

			var Canvas = Renderer.extend({
				getEvents: function getEvents() {
					var events = Renderer.prototype.getEvents.call(this);
					events.viewprereset = this._onViewPreReset;
					return events;
				},

				_onViewPreReset: function _onViewPreReset() {
					// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
					this._postponeUpdatePaths = true;
				},

				onAdd: function onAdd() {
					Renderer.prototype.onAdd.call(this);

					// Redraw vectors since canvas is cleared upon removal,
					// in case of removing the renderer itself from the map.
					this._draw();
				},

				_initContainer: function _initContainer() {
					var container = this._container = document.createElement('canvas');

					on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
					on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
					on(container, 'mouseout', this._handleMouseOut, this);

					this._ctx = container.getContext('2d');
				},

				_destroyContainer: function _destroyContainer() {
					cancelAnimFrame(this._redrawRequest);
					delete this._ctx;
					_remove(this._container);
					off(this._container);
					delete this._container;
				},

				_updatePaths: function _updatePaths() {
					if (this._postponeUpdatePaths) {
						return;
					}

					var layer;
					this._redrawBounds = null;
					for (var id in this._layers) {
						layer = this._layers[id];
						layer._update();
					}
					this._redraw();
				},

				_update: function _update() {
					if (this._map._animatingZoom && this._bounds) {
						return;
					}

					this._drawnLayers = {};

					Renderer.prototype._update.call(this);

					var b = this._bounds,
					    container = this._container,
					    size = b.getSize(),
					    m = retina ? 2 : 1;

					setPosition(container, b.min);

					// set canvas size (also clearing it); use double size on retina
					container.width = m * size.x;
					container.height = m * size.y;
					container.style.width = size.x + 'px';
					container.style.height = size.y + 'px';

					if (retina) {
						this._ctx.scale(2, 2);
					}

					// translate so we use the same path coordinates after canvas element moves
					this._ctx.translate(-b.min.x, -b.min.y);

					// Tell paths to redraw themselves
					this.fire('update');
				},

				_reset: function _reset() {
					Renderer.prototype._reset.call(this);

					if (this._postponeUpdatePaths) {
						this._postponeUpdatePaths = false;
						this._updatePaths();
					}
				},

				_initPath: function _initPath(layer) {
					this._updateDashArray(layer);
					this._layers[stamp(layer)] = layer;

					var order = layer._order = {
						layer: layer,
						prev: this._drawLast,
						next: null
					};
					if (this._drawLast) {
						this._drawLast.next = order;
					}
					this._drawLast = order;
					this._drawFirst = this._drawFirst || this._drawLast;
				},

				_addPath: function _addPath(layer) {
					this._requestRedraw(layer);
				},

				_removePath: function _removePath(layer) {
					var order = layer._order;
					var next = order.next;
					var prev = order.prev;

					if (next) {
						next.prev = prev;
					} else {
						this._drawLast = prev;
					}
					if (prev) {
						prev.next = next;
					} else {
						this._drawFirst = next;
					}

					delete this._drawnLayers[layer._leaflet_id];

					delete layer._order;

					delete this._layers[stamp(layer)];

					this._requestRedraw(layer);
				},

				_updatePath: function _updatePath(layer) {
					// Redraw the union of the layer's old pixel
					// bounds and the new pixel bounds.
					this._extendRedrawBounds(layer);
					layer._project();
					layer._update();
					// The redraw will extend the redraw bounds
					// with the new pixel bounds.
					this._requestRedraw(layer);
				},

				_updateStyle: function _updateStyle(layer) {
					this._updateDashArray(layer);
					this._requestRedraw(layer);
				},

				_updateDashArray: function _updateDashArray(layer) {
					if (typeof layer.options.dashArray === 'string') {
						var parts = layer.options.dashArray.split(','),
						    dashArray = [],
						    i;
						for (i = 0; i < parts.length; i++) {
							dashArray.push(Number(parts[i]));
						}
						layer.options._dashArray = dashArray;
					} else {
						layer.options._dashArray = layer.options.dashArray;
					}
				},

				_requestRedraw: function _requestRedraw(layer) {
					if (!this._map) {
						return;
					}

					this._extendRedrawBounds(layer);
					this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
				},

				_extendRedrawBounds: function _extendRedrawBounds(layer) {
					if (layer._pxBounds) {
						var padding = (layer.options.weight || 0) + 1;
						this._redrawBounds = this._redrawBounds || new Bounds();
						this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
						this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
					}
				},

				_redraw: function _redraw() {
					this._redrawRequest = null;

					if (this._redrawBounds) {
						this._redrawBounds.min._floor();
						this._redrawBounds.max._ceil();
					}

					this._clear(); // clear layers in redraw bounds
					this._draw(); // draw layers

					this._redrawBounds = null;
				},

				_clear: function _clear() {
					var bounds = this._redrawBounds;
					if (bounds) {
						var size = bounds.getSize();
						this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
					} else {
						this._ctx.clearRect(0, 0, this._container.width, this._container.height);
					}
				},

				_draw: function _draw() {
					var layer,
					    bounds = this._redrawBounds;
					this._ctx.save();
					if (bounds) {
						var size = bounds.getSize();
						this._ctx.beginPath();
						this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
						this._ctx.clip();
					}

					this._drawing = true;

					for (var order = this._drawFirst; order; order = order.next) {
						layer = order.layer;
						if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
							layer._updatePath();
						}
					}

					this._drawing = false;

					this._ctx.restore(); // Restore state before clipping.
				},

				_updatePoly: function _updatePoly(layer, closed) {
					if (!this._drawing) {
						return;
					}

					var i,
					    j,
					    len2,
					    p,
					    parts = layer._parts,
					    len = parts.length,
					    ctx = this._ctx;

					if (!len) {
						return;
					}

					this._drawnLayers[layer._leaflet_id] = layer;

					ctx.beginPath();

					for (i = 0; i < len; i++) {
						for (j = 0, len2 = parts[i].length; j < len2; j++) {
							p = parts[i][j];
							ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
						}
						if (closed) {
							ctx.closePath();
						}
					}

					this._fillStroke(ctx, layer);

					// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
				},

				_updateCircle: function _updateCircle(layer) {

					if (!this._drawing || layer._empty()) {
						return;
					}

					var p = layer._point,
					    ctx = this._ctx,
					    r = Math.max(Math.round(layer._radius), 1),
					    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

					this._drawnLayers[layer._leaflet_id] = layer;

					if (s !== 1) {
						ctx.save();
						ctx.scale(1, s);
					}

					ctx.beginPath();
					ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

					if (s !== 1) {
						ctx.restore();
					}

					this._fillStroke(ctx, layer);
				},

				_fillStroke: function _fillStroke(ctx, layer) {
					var options = layer.options;

					if (options.fill) {
						ctx.globalAlpha = options.fillOpacity;
						ctx.fillStyle = options.fillColor || options.color;
						ctx.fill(options.fillRule || 'evenodd');
					}

					if (options.stroke && options.weight !== 0) {
						if (ctx.setLineDash) {
							ctx.setLineDash(layer.options && layer.options._dashArray || []);
						}
						ctx.globalAlpha = options.opacity;
						ctx.lineWidth = options.weight;
						ctx.strokeStyle = options.color;
						ctx.lineCap = options.lineCap;
						ctx.lineJoin = options.lineJoin;
						ctx.stroke();
					}
				},

				// Canvas obviously doesn't have mouse events for individual drawn objects,
				// so we emulate that by calculating what's under the mouse on mousemove/click manually

				_onClick: function _onClick(e) {
					var point = this._map.mouseEventToLayerPoint(e),
					    layer,
					    clickedLayer;

					for (var order = this._drawFirst; order; order = order.next) {
						layer = order.layer;
						if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
							clickedLayer = layer;
						}
					}
					if (clickedLayer) {
						fakeStop(e);
						this._fireEvent([clickedLayer], e);
					}
				},

				_onMouseMove: function _onMouseMove(e) {
					if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
						return;
					}

					var point = this._map.mouseEventToLayerPoint(e);
					this._handleMouseHover(e, point);
				},

				_handleMouseOut: function _handleMouseOut(e) {
					var layer = this._hoveredLayer;
					if (layer) {
						// if we're leaving the layer, fire mouseout
						removeClass(this._container, 'leaflet-interactive');
						this._fireEvent([layer], e, 'mouseout');
						this._hoveredLayer = null;
					}
				},

				_handleMouseHover: function _handleMouseHover(e, point) {
					var layer, candidateHoveredLayer;

					for (var order = this._drawFirst; order; order = order.next) {
						layer = order.layer;
						if (layer.options.interactive && layer._containsPoint(point)) {
							candidateHoveredLayer = layer;
						}
					}

					if (candidateHoveredLayer !== this._hoveredLayer) {
						this._handleMouseOut(e);

						if (candidateHoveredLayer) {
							addClass(this._container, 'leaflet-interactive'); // change cursor
							this._fireEvent([candidateHoveredLayer], e, 'mouseover');
							this._hoveredLayer = candidateHoveredLayer;
						}
					}

					if (this._hoveredLayer) {
						this._fireEvent([this._hoveredLayer], e);
					}
				},

				_fireEvent: function _fireEvent(layers, e, type) {
					this._map._fireDOMEvent(e, type || e.type, layers);
				},

				_bringToFront: function _bringToFront(layer) {
					var order = layer._order;
					var next = order.next;
					var prev = order.prev;

					if (next) {
						next.prev = prev;
					} else {
						// Already last
						return;
					}
					if (prev) {
						prev.next = next;
					} else if (next) {
						// Update first entry unless this is the
						// single entry
						this._drawFirst = next;
					}

					order.prev = this._drawLast;
					this._drawLast.next = order;

					order.next = null;
					this._drawLast = order;

					this._requestRedraw(layer);
				},

				_bringToBack: function _bringToBack(layer) {
					var order = layer._order;
					var next = order.next;
					var prev = order.prev;

					if (prev) {
						prev.next = next;
					} else {
						// Already first
						return;
					}
					if (next) {
						next.prev = prev;
					} else if (prev) {
						// Update last entry unless this is the
						// single entry
						this._drawLast = prev;
					}

					order.prev = null;

					order.next = this._drawFirst;
					this._drawFirst.prev = order;
					this._drawFirst = order;

					this._requestRedraw(layer);
				}
			});

			// @factory L.canvas(options?: Renderer options)
			// Creates a Canvas renderer with the given options.
			function canvas$1(options) {
				return canvas ? new Canvas(options) : null;
			}

			/*
    * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
    */

			var vmlCreate = function () {
				try {
					document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
					return function (name) {
						return document.createElement('<lvml:' + name + ' class="lvml">');
					};
				} catch (e) {
					return function (name) {
						return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
					};
				}
			}();

			/*
    * @class SVG
    *
    * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
    *
    * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
    * with old versions of Internet Explorer.
    */

			// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
			var vmlMixin = {

				_initContainer: function _initContainer() {
					this._container = create$1('div', 'leaflet-vml-container');
				},

				_update: function _update() {
					if (this._map._animatingZoom) {
						return;
					}
					Renderer.prototype._update.call(this);
					this.fire('update');
				},

				_initPath: function _initPath(layer) {
					var container = layer._container = vmlCreate('shape');

					addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

					container.coordsize = '1 1';

					layer._path = vmlCreate('path');
					container.appendChild(layer._path);

					this._updateStyle(layer);
					this._layers[stamp(layer)] = layer;
				},

				_addPath: function _addPath(layer) {
					var container = layer._container;
					this._container.appendChild(container);

					if (layer.options.interactive) {
						layer.addInteractiveTarget(container);
					}
				},

				_removePath: function _removePath(layer) {
					var container = layer._container;
					_remove(container);
					layer.removeInteractiveTarget(container);
					delete this._layers[stamp(layer)];
				},

				_updateStyle: function _updateStyle(layer) {
					var stroke = layer._stroke,
					    fill = layer._fill,
					    options = layer.options,
					    container = layer._container;

					container.stroked = !!options.stroke;
					container.filled = !!options.fill;

					if (options.stroke) {
						if (!stroke) {
							stroke = layer._stroke = vmlCreate('stroke');
						}
						container.appendChild(stroke);
						stroke.weight = options.weight + 'px';
						stroke.color = options.color;
						stroke.opacity = options.opacity;

						if (options.dashArray) {
							stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
						} else {
							stroke.dashStyle = '';
						}
						stroke.endcap = options.lineCap.replace('butt', 'flat');
						stroke.joinstyle = options.lineJoin;
					} else if (stroke) {
						container.removeChild(stroke);
						layer._stroke = null;
					}

					if (options.fill) {
						if (!fill) {
							fill = layer._fill = vmlCreate('fill');
						}
						container.appendChild(fill);
						fill.color = options.fillColor || options.color;
						fill.opacity = options.fillOpacity;
					} else if (fill) {
						container.removeChild(fill);
						layer._fill = null;
					}
				},

				_updateCircle: function _updateCircle(layer) {
					var p = layer._point.round(),
					    r = Math.round(layer._radius),
					    r2 = Math.round(layer._radiusY || r);

					this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
				},

				_setPath: function _setPath(layer, path) {
					layer._path.v = path;
				},

				_bringToFront: function _bringToFront(layer) {
					toFront(layer._container);
				},

				_bringToBack: function _bringToBack(layer) {
					toBack(layer._container);
				}
			};

			var create$2 = vml ? vmlCreate : svgCreate;

			/*
    * @class SVG
    * @inherits Renderer
    * @aka L.SVG
    *
    * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
    * Inherits `Renderer`.
    *
    * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
    * available in all web browsers, notably Android 2.x and 3.x.
    *
    * Although SVG is not available on IE7 and IE8, these browsers support
    * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
    * (a now deprecated technology), and the SVG renderer will fall back to VML in
    * this case.
    *
    * @example
    *
    * Use SVG by default for all paths in the map:
    *
    * ```js
    * var map = L.map('map', {
    * 	renderer: L.svg()
    * });
    * ```
    *
    * Use a SVG renderer with extra padding for specific vector geometries:
    *
    * ```js
    * var map = L.map('map');
    * var myRenderer = L.svg({ padding: 0.5 });
    * var line = L.polyline( coordinates, { renderer: myRenderer } );
    * var circle = L.circle( center, { renderer: myRenderer } );
    * ```
    */

			var SVG = Renderer.extend({

				getEvents: function getEvents() {
					var events = Renderer.prototype.getEvents.call(this);
					events.zoomstart = this._onZoomStart;
					return events;
				},

				_initContainer: function _initContainer() {
					this._container = create$2('svg');

					// makes it possible to click through svg root; we'll reset it back in individual paths
					this._container.setAttribute('pointer-events', 'none');

					this._rootGroup = create$2('g');
					this._container.appendChild(this._rootGroup);
				},

				_destroyContainer: function _destroyContainer() {
					_remove(this._container);
					off(this._container);
					delete this._container;
					delete this._rootGroup;
					delete this._svgSize;
				},

				_onZoomStart: function _onZoomStart() {
					// Drag-then-pinch interactions might mess up the center and zoom.
					// In this case, the easiest way to prevent this is re-do the renderer
					//   bounds and padding when the zooming starts.
					this._update();
				},

				_update: function _update() {
					if (this._map._animatingZoom && this._bounds) {
						return;
					}

					Renderer.prototype._update.call(this);

					var b = this._bounds,
					    size = b.getSize(),
					    container = this._container;

					// set size of svg-container if changed
					if (!this._svgSize || !this._svgSize.equals(size)) {
						this._svgSize = size;
						container.setAttribute('width', size.x);
						container.setAttribute('height', size.y);
					}

					// movement: update container viewBox so that we don't have to change coordinates of individual layers
					setPosition(container, b.min);
					container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

					this.fire('update');
				},

				// methods below are called by vector layers implementations

				_initPath: function _initPath(layer) {
					var path = layer._path = create$2('path');

					// @namespace Path
					// @option className: String = null
					// Custom class name set on an element. Only for SVG renderer.
					if (layer.options.className) {
						addClass(path, layer.options.className);
					}

					if (layer.options.interactive) {
						addClass(path, 'leaflet-interactive');
					}

					this._updateStyle(layer);
					this._layers[stamp(layer)] = layer;
				},

				_addPath: function _addPath(layer) {
					if (!this._rootGroup) {
						this._initContainer();
					}
					this._rootGroup.appendChild(layer._path);
					layer.addInteractiveTarget(layer._path);
				},

				_removePath: function _removePath(layer) {
					_remove(layer._path);
					layer.removeInteractiveTarget(layer._path);
					delete this._layers[stamp(layer)];
				},

				_updatePath: function _updatePath(layer) {
					layer._project();
					layer._update();
				},

				_updateStyle: function _updateStyle(layer) {
					var path = layer._path,
					    options = layer.options;

					if (!path) {
						return;
					}

					if (options.stroke) {
						path.setAttribute('stroke', options.color);
						path.setAttribute('stroke-opacity', options.opacity);
						path.setAttribute('stroke-width', options.weight);
						path.setAttribute('stroke-linecap', options.lineCap);
						path.setAttribute('stroke-linejoin', options.lineJoin);

						if (options.dashArray) {
							path.setAttribute('stroke-dasharray', options.dashArray);
						} else {
							path.removeAttribute('stroke-dasharray');
						}

						if (options.dashOffset) {
							path.setAttribute('stroke-dashoffset', options.dashOffset);
						} else {
							path.removeAttribute('stroke-dashoffset');
						}
					} else {
						path.setAttribute('stroke', 'none');
					}

					if (options.fill) {
						path.setAttribute('fill', options.fillColor || options.color);
						path.setAttribute('fill-opacity', options.fillOpacity);
						path.setAttribute('fill-rule', options.fillRule || 'evenodd');
					} else {
						path.setAttribute('fill', 'none');
					}
				},

				_updatePoly: function _updatePoly(layer, closed) {
					this._setPath(layer, pointsToPath(layer._parts, closed));
				},

				_updateCircle: function _updateCircle(layer) {
					var p = layer._point,
					    r = Math.max(Math.round(layer._radius), 1),
					    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
					    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

					// drawing a circle with two half-arcs
					var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

					this._setPath(layer, d);
				},

				_setPath: function _setPath(layer, path) {
					layer._path.setAttribute('d', path);
				},

				// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
				_bringToFront: function _bringToFront(layer) {
					toFront(layer._path);
				},

				_bringToBack: function _bringToBack(layer) {
					toBack(layer._path);
				}
			});

			if (vml) {
				SVG.include(vmlMixin);
			}

			// @namespace SVG
			// @factory L.svg(options?: Renderer options)
			// Creates a SVG renderer with the given options.
			function svg$1(options) {
				return svg || vml ? new SVG(options) : null;
			}

			Map.include({
				// @namespace Map; @method getRenderer(layer: Path): Renderer
				// Returns the instance of `Renderer` that should be used to render the given
				// `Path`. It will ensure that the `renderer` options of the map and paths
				// are respected, and that the renderers do exist on the map.
				getRenderer: function getRenderer(layer) {
					// @namespace Path; @option renderer: Renderer
					// Use this specific instance of `Renderer` for this path. Takes
					// precedence over the map's [default renderer](#map-renderer).
					var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

					if (!renderer) {
						renderer = this._renderer = this._createRenderer();
					}

					if (!this.hasLayer(renderer)) {
						this.addLayer(renderer);
					}
					return renderer;
				},

				_getPaneRenderer: function _getPaneRenderer(name) {
					if (name === 'overlayPane' || name === undefined) {
						return false;
					}

					var renderer = this._paneRenderers[name];
					if (renderer === undefined) {
						renderer = this._createRenderer({ pane: name });
						this._paneRenderers[name] = renderer;
					}
					return renderer;
				},

				_createRenderer: function _createRenderer(options) {
					// @namespace Map; @option preferCanvas: Boolean = false
					// Whether `Path`s should be rendered on a `Canvas` renderer.
					// By default, all `Path`s are rendered in a `SVG` renderer.
					return this.options.preferCanvas && canvas$1(options) || svg$1(options);
				}
			});

			/*
    * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
    */

			/*
    * @class Rectangle
    * @aka L.Rectangle
    * @inherits Polygon
    *
    * A class for drawing rectangle overlays on a map. Extends `Polygon`.
    *
    * @example
    *
    * ```js
    * // define rectangle geographical bounds
    * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
    *
    * // create an orange rectangle
    * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
    *
    * // zoom the map to the rectangle bounds
    * map.fitBounds(bounds);
    * ```
    *
    */

			var Rectangle = Polygon.extend({
				initialize: function initialize(latLngBounds, options) {
					Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
				},

				// @method setBounds(latLngBounds: LatLngBounds): this
				// Redraws the rectangle with the passed bounds.
				setBounds: function setBounds(latLngBounds) {
					return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
				},

				_boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {
					latLngBounds = toLatLngBounds(latLngBounds);
					return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
				}
			});

			// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
			function rectangle(latLngBounds, options) {
				return new Rectangle(latLngBounds, options);
			}

			SVG.create = create$2;
			SVG.pointsToPath = pointsToPath;

			GeoJSON.geometryToLayer = geometryToLayer;
			GeoJSON.coordsToLatLng = coordsToLatLng;
			GeoJSON.coordsToLatLngs = coordsToLatLngs;
			GeoJSON.latLngToCoords = latLngToCoords;
			GeoJSON.latLngsToCoords = latLngsToCoords;
			GeoJSON.getFeature = getFeature;
			GeoJSON.asFeature = asFeature;

			/*
    * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
    * (zoom to a selected bounding box), enabled by default.
    */

			// @namespace Map
			// @section Interaction Options
			Map.mergeOptions({
				// @option boxZoom: Boolean = true
				// Whether the map can be zoomed to a rectangular area specified by
				// dragging the mouse while pressing the shift key.
				boxZoom: true
			});

			var BoxZoom = Handler.extend({
				initialize: function initialize(map) {
					this._map = map;
					this._container = map._container;
					this._pane = map._panes.overlayPane;
					this._resetStateTimeout = 0;
					map.on('unload', this._destroy, this);
				},

				addHooks: function addHooks() {
					on(this._container, 'mousedown', this._onMouseDown, this);
				},

				removeHooks: function removeHooks() {
					off(this._container, 'mousedown', this._onMouseDown, this);
				},

				moved: function moved() {
					return this._moved;
				},

				_destroy: function _destroy() {
					_remove(this._pane);
					delete this._pane;
				},

				_resetState: function _resetState() {
					this._resetStateTimeout = 0;
					this._moved = false;
				},

				_clearDeferredResetState: function _clearDeferredResetState() {
					if (this._resetStateTimeout !== 0) {
						clearTimeout(this._resetStateTimeout);
						this._resetStateTimeout = 0;
					}
				},

				_onMouseDown: function _onMouseDown(e) {
					if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
						return false;
					}

					// Clear the deferred resetState if it hasn't executed yet, otherwise it
					// will interrupt the interaction and orphan a box element in the container.
					this._clearDeferredResetState();
					this._resetState();

					disableTextSelection();
					disableImageDrag();

					this._startPoint = this._map.mouseEventToContainerPoint(e);

					on(document, {
						contextmenu: stop,
						mousemove: this._onMouseMove,
						mouseup: this._onMouseUp,
						keydown: this._onKeyDown
					}, this);
				},

				_onMouseMove: function _onMouseMove(e) {
					if (!this._moved) {
						this._moved = true;

						this._box = create$1('div', 'leaflet-zoom-box', this._container);
						addClass(this._container, 'leaflet-crosshair');

						this._map.fire('boxzoomstart');
					}

					this._point = this._map.mouseEventToContainerPoint(e);

					var bounds = new Bounds(this._point, this._startPoint),
					    size = bounds.getSize();

					setPosition(this._box, bounds.min);

					this._box.style.width = size.x + 'px';
					this._box.style.height = size.y + 'px';
				},

				_finish: function _finish() {
					if (this._moved) {
						_remove(this._box);
						removeClass(this._container, 'leaflet-crosshair');
					}

					enableTextSelection();
					enableImageDrag();

					off(document, {
						contextmenu: stop,
						mousemove: this._onMouseMove,
						mouseup: this._onMouseUp,
						keydown: this._onKeyDown
					}, this);
				},

				_onMouseUp: function _onMouseUp(e) {
					if (e.which !== 1 && e.button !== 1) {
						return;
					}

					this._finish();

					if (!this._moved) {
						return;
					}
					// Postpone to next JS tick so internal click event handling
					// still see it as "moved".
					this._clearDeferredResetState();
					this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

					var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

					this._map.fitBounds(bounds).fire('boxzoomend', { boxZoomBounds: bounds });
				},

				_onKeyDown: function _onKeyDown(e) {
					if (e.keyCode === 27) {
						this._finish();
					}
				}
			});

			// @section Handlers
			// @property boxZoom: Handler
			// Box (shift-drag with mouse) zoom handler.
			Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

			/*
    * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
    */

			// @namespace Map
			// @section Interaction Options

			Map.mergeOptions({
				// @option doubleClickZoom: Boolean|String = true
				// Whether the map can be zoomed in by double clicking on it and
				// zoomed out by double clicking while holding shift. If passed
				// `'center'`, double-click zoom will zoom to the center of the
				//  view regardless of where the mouse was.
				doubleClickZoom: true
			});

			var DoubleClickZoom = Handler.extend({
				addHooks: function addHooks() {
					this._map.on('dblclick', this._onDoubleClick, this);
				},

				removeHooks: function removeHooks() {
					this._map.off('dblclick', this._onDoubleClick, this);
				},

				_onDoubleClick: function _onDoubleClick(e) {
					var map = this._map,
					    oldZoom = map.getZoom(),
					    delta = map.options.zoomDelta,
					    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

					if (map.options.doubleClickZoom === 'center') {
						map.setZoom(zoom);
					} else {
						map.setZoomAround(e.containerPoint, zoom);
					}
				}
			});

			// @section Handlers
			//
			// Map properties include interaction handlers that allow you to control
			// interaction behavior in runtime, enabling or disabling certain features such
			// as dragging or touch zoom (see `Handler` methods). For example:
			//
			// ```js
			// map.doubleClickZoom.disable();
			// ```
			//
			// @property doubleClickZoom: Handler
			// Double click zoom handler.
			Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

			/*
    * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
    */

			// @namespace Map
			// @section Interaction Options
			Map.mergeOptions({
				// @option dragging: Boolean = true
				// Whether the map be draggable with mouse/touch or not.
				dragging: true,

				// @section Panning Inertia Options
				// @option inertia: Boolean = *
				// If enabled, panning of the map will have an inertia effect where
				// the map builds momentum while dragging and continues moving in
				// the same direction for some time. Feels especially nice on touch
				// devices. Enabled by default unless running on old Android devices.
				inertia: !android23,

				// @option inertiaDeceleration: Number = 3000
				// The rate with which the inertial movement slows down, in pixels/second².
				inertiaDeceleration: 3400, // px/s^2

				// @option inertiaMaxSpeed: Number = Infinity
				// Max speed of the inertial movement, in pixels/second.
				inertiaMaxSpeed: Infinity, // px/s

				// @option easeLinearity: Number = 0.2
				easeLinearity: 0.2,

				// TODO refactor, move to CRS
				// @option worldCopyJump: Boolean = false
				// With this option enabled, the map tracks when you pan to another "copy"
				// of the world and seamlessly jumps to the original one so that all overlays
				// like markers and vector layers are still visible.
				worldCopyJump: false,

				// @option maxBoundsViscosity: Number = 0.0
				// If `maxBounds` is set, this option will control how solid the bounds
				// are when dragging the map around. The default value of `0.0` allows the
				// user to drag outside the bounds at normal speed, higher values will
				// slow down map dragging outside bounds, and `1.0` makes the bounds fully
				// solid, preventing the user from dragging outside the bounds.
				maxBoundsViscosity: 0.0
			});

			var Drag = Handler.extend({
				addHooks: function addHooks() {
					if (!this._draggable) {
						var map = this._map;

						this._draggable = new Draggable(map._mapPane, map._container);

						this._draggable.on({
							dragstart: this._onDragStart,
							drag: this._onDrag,
							dragend: this._onDragEnd
						}, this);

						this._draggable.on('predrag', this._onPreDragLimit, this);
						if (map.options.worldCopyJump) {
							this._draggable.on('predrag', this._onPreDragWrap, this);
							map.on('zoomend', this._onZoomEnd, this);

							map.whenReady(this._onZoomEnd, this);
						}
					}
					addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
					this._draggable.enable();
					this._positions = [];
					this._times = [];
				},

				removeHooks: function removeHooks() {
					removeClass(this._map._container, 'leaflet-grab');
					removeClass(this._map._container, 'leaflet-touch-drag');
					this._draggable.disable();
				},

				moved: function moved() {
					return this._draggable && this._draggable._moved;
				},

				moving: function moving() {
					return this._draggable && this._draggable._moving;
				},

				_onDragStart: function _onDragStart() {
					var map = this._map;

					map._stop();
					if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
						var bounds = toLatLngBounds(this._map.options.maxBounds);

						this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));

						this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
					} else {
						this._offsetLimit = null;
					}

					map.fire('movestart').fire('dragstart');

					if (map.options.inertia) {
						this._positions = [];
						this._times = [];
					}
				},

				_onDrag: function _onDrag(e) {
					if (this._map.options.inertia) {
						var time = this._lastTime = +new Date(),
						    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

						this._positions.push(pos);
						this._times.push(time);

						this._prunePositions(time);
					}

					this._map.fire('move', e).fire('drag', e);
				},

				_prunePositions: function _prunePositions(time) {
					while (this._positions.length > 1 && time - this._times[0] > 50) {
						this._positions.shift();
						this._times.shift();
					}
				},

				_onZoomEnd: function _onZoomEnd() {
					var pxCenter = this._map.getSize().divideBy(2),
					    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

					this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
					this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
				},

				_viscousLimit: function _viscousLimit(value, threshold) {
					return value - (value - threshold) * this._viscosity;
				},

				_onPreDragLimit: function _onPreDragLimit() {
					if (!this._viscosity || !this._offsetLimit) {
						return;
					}

					var offset = this._draggable._newPos.subtract(this._draggable._startPos);

					var limit = this._offsetLimit;
					if (offset.x < limit.min.x) {
						offset.x = this._viscousLimit(offset.x, limit.min.x);
					}
					if (offset.y < limit.min.y) {
						offset.y = this._viscousLimit(offset.y, limit.min.y);
					}
					if (offset.x > limit.max.x) {
						offset.x = this._viscousLimit(offset.x, limit.max.x);
					}
					if (offset.y > limit.max.y) {
						offset.y = this._viscousLimit(offset.y, limit.max.y);
					}

					this._draggable._newPos = this._draggable._startPos.add(offset);
				},

				_onPreDragWrap: function _onPreDragWrap() {
					// TODO refactor to be able to adjust map pane position after zoom
					var worldWidth = this._worldWidth,
					    halfWidth = Math.round(worldWidth / 2),
					    dx = this._initialWorldOffset,
					    x = this._draggable._newPos.x,
					    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
					    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
					    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

					this._draggable._absPos = this._draggable._newPos.clone();
					this._draggable._newPos.x = newX;
				},

				_onDragEnd: function _onDragEnd(e) {
					var map = this._map,
					    options = map.options,
					    noInertia = !options.inertia || this._times.length < 2;

					map.fire('dragend', e);

					if (noInertia) {
						map.fire('moveend');
					} else {
						this._prunePositions(+new Date());

						var direction = this._lastPos.subtract(this._positions[0]),
						    duration = (this._lastTime - this._times[0]) / 1000,
						    ease = options.easeLinearity,
						    speedVector = direction.multiplyBy(ease / duration),
						    speed = speedVector.distanceTo([0, 0]),
						    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
						    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
						    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
						    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

						if (!offset.x && !offset.y) {
							map.fire('moveend');
						} else {
							offset = map._limitOffset(offset, map.options.maxBounds);

							requestAnimFrame(function () {
								map.panBy(offset, {
									duration: decelerationDuration,
									easeLinearity: ease,
									noMoveStart: true,
									animate: true
								});
							});
						}
					}
				}
			});

			// @section Handlers
			// @property dragging: Handler
			// Map dragging handler (by both mouse and touch).
			Map.addInitHook('addHandler', 'dragging', Drag);

			/*
    * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
    */

			// @namespace Map
			// @section Keyboard Navigation Options
			Map.mergeOptions({
				// @option keyboard: Boolean = true
				// Makes the map focusable and allows users to navigate the map with keyboard
				// arrows and `+`/`-` keys.
				keyboard: true,

				// @option keyboardPanDelta: Number = 80
				// Amount of pixels to pan when pressing an arrow key.
				keyboardPanDelta: 80
			});

			var Keyboard = Handler.extend({

				keyCodes: {
					left: [37],
					right: [39],
					down: [40],
					up: [38],
					zoomIn: [187, 107, 61, 171],
					zoomOut: [189, 109, 54, 173]
				},

				initialize: function initialize(map) {
					this._map = map;

					this._setPanDelta(map.options.keyboardPanDelta);
					this._setZoomDelta(map.options.zoomDelta);
				},

				addHooks: function addHooks() {
					var container = this._map._container;

					// make the container focusable by tabbing
					if (container.tabIndex <= 0) {
						container.tabIndex = '0';
					}

					on(container, {
						focus: this._onFocus,
						blur: this._onBlur,
						mousedown: this._onMouseDown
					}, this);

					this._map.on({
						focus: this._addHooks,
						blur: this._removeHooks
					}, this);
				},

				removeHooks: function removeHooks() {
					this._removeHooks();

					off(this._map._container, {
						focus: this._onFocus,
						blur: this._onBlur,
						mousedown: this._onMouseDown
					}, this);

					this._map.off({
						focus: this._addHooks,
						blur: this._removeHooks
					}, this);
				},

				_onMouseDown: function _onMouseDown() {
					if (this._focused) {
						return;
					}

					var body = document.body,
					    docEl = document.documentElement,
					    top = body.scrollTop || docEl.scrollTop,
					    left = body.scrollLeft || docEl.scrollLeft;

					this._map._container.focus();

					window.scrollTo(left, top);
				},

				_onFocus: function _onFocus() {
					this._focused = true;
					this._map.fire('focus');
				},

				_onBlur: function _onBlur() {
					this._focused = false;
					this._map.fire('blur');
				},

				_setPanDelta: function _setPanDelta(panDelta) {
					var keys = this._panKeys = {},
					    codes = this.keyCodes,
					    i,
					    len;

					for (i = 0, len = codes.left.length; i < len; i++) {
						keys[codes.left[i]] = [-1 * panDelta, 0];
					}
					for (i = 0, len = codes.right.length; i < len; i++) {
						keys[codes.right[i]] = [panDelta, 0];
					}
					for (i = 0, len = codes.down.length; i < len; i++) {
						keys[codes.down[i]] = [0, panDelta];
					}
					for (i = 0, len = codes.up.length; i < len; i++) {
						keys[codes.up[i]] = [0, -1 * panDelta];
					}
				},

				_setZoomDelta: function _setZoomDelta(zoomDelta) {
					var keys = this._zoomKeys = {},
					    codes = this.keyCodes,
					    i,
					    len;

					for (i = 0, len = codes.zoomIn.length; i < len; i++) {
						keys[codes.zoomIn[i]] = zoomDelta;
					}
					for (i = 0, len = codes.zoomOut.length; i < len; i++) {
						keys[codes.zoomOut[i]] = -zoomDelta;
					}
				},

				_addHooks: function _addHooks() {
					on(document, 'keydown', this._onKeyDown, this);
				},

				_removeHooks: function _removeHooks() {
					off(document, 'keydown', this._onKeyDown, this);
				},

				_onKeyDown: function _onKeyDown(e) {
					if (e.altKey || e.ctrlKey || e.metaKey) {
						return;
					}

					var key = e.keyCode,
					    map = this._map,
					    offset;

					if (key in this._panKeys) {
						if (!map._panAnim || !map._panAnim._inProgress) {
							offset = this._panKeys[key];
							if (e.shiftKey) {
								offset = toPoint(offset).multiplyBy(3);
							}

							map.panBy(offset);

							if (map.options.maxBounds) {
								map.panInsideBounds(map.options.maxBounds);
							}
						}
					} else if (key in this._zoomKeys) {
						map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
					} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
						map.closePopup();
					} else {
						return;
					}

					stop(e);
				}
			});

			// @section Handlers
			// @section Handlers
			// @property keyboard: Handler
			// Keyboard navigation handler.
			Map.addInitHook('addHandler', 'keyboard', Keyboard);

			/*
    * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
    */

			// @namespace Map
			// @section Interaction Options
			Map.mergeOptions({
				// @section Mousewheel options
				// @option scrollWheelZoom: Boolean|String = true
				// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
				// it will zoom to the center of the view regardless of where the mouse was.
				scrollWheelZoom: true,

				// @option wheelDebounceTime: Number = 40
				// Limits the rate at which a wheel can fire (in milliseconds). By default
				// user can't zoom via wheel more often than once per 40 ms.
				wheelDebounceTime: 40,

				// @option wheelPxPerZoomLevel: Number = 60
				// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
				// mean a change of one full zoom level. Smaller values will make wheel-zooming
				// faster (and vice versa).
				wheelPxPerZoomLevel: 60
			});

			var ScrollWheelZoom = Handler.extend({
				addHooks: function addHooks() {
					on(this._map._container, 'mousewheel', this._onWheelScroll, this);

					this._delta = 0;
				},

				removeHooks: function removeHooks() {
					off(this._map._container, 'mousewheel', this._onWheelScroll, this);
				},

				_onWheelScroll: function _onWheelScroll(e) {
					var delta = getWheelDelta(e);

					var debounce = this._map.options.wheelDebounceTime;

					this._delta += delta;
					this._lastMousePos = this._map.mouseEventToContainerPoint(e);

					if (!this._startTime) {
						this._startTime = +new Date();
					}

					var left = Math.max(debounce - (+new Date() - this._startTime), 0);

					clearTimeout(this._timer);
					this._timer = setTimeout(bind(this._performZoom, this), left);

					stop(e);
				},

				_performZoom: function _performZoom() {
					var map = this._map,
					    zoom = map.getZoom(),
					    snap = this._map.options.zoomSnap || 0;

					map._stop(); // stop panning and fly animations if any

					// map the delta with a sigmoid function to -4..4 range leaning on -1..1
					var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
					    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
					    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
					    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

					this._delta = 0;
					this._startTime = null;

					if (!delta) {
						return;
					}

					if (map.options.scrollWheelZoom === 'center') {
						map.setZoom(zoom + delta);
					} else {
						map.setZoomAround(this._lastMousePos, zoom + delta);
					}
				}
			});

			// @section Handlers
			// @property scrollWheelZoom: Handler
			// Scroll wheel zoom handler.
			Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

			/*
    * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
    */

			// @namespace Map
			// @section Interaction Options
			Map.mergeOptions({
				// @section Touch interaction options
				// @option tap: Boolean = true
				// Enables mobile hacks for supporting instant taps (fixing 200ms click
				// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
				tap: true,

				// @option tapTolerance: Number = 15
				// The max number of pixels a user can shift his finger during touch
				// for it to be considered a valid tap.
				tapTolerance: 15
			});

			var Tap = Handler.extend({
				addHooks: function addHooks() {
					on(this._map._container, 'touchstart', this._onDown, this);
				},

				removeHooks: function removeHooks() {
					off(this._map._container, 'touchstart', this._onDown, this);
				},

				_onDown: function _onDown(e) {
					if (!e.touches) {
						return;
					}

					preventDefault(e);

					this._fireClick = true;

					// don't simulate click or track longpress if more than 1 touch
					if (e.touches.length > 1) {
						this._fireClick = false;
						clearTimeout(this._holdTimeout);
						return;
					}

					var first = e.touches[0],
					    el = first.target;

					this._startPos = this._newPos = new Point(first.clientX, first.clientY);

					// if touching a link, highlight it
					if (el.tagName && el.tagName.toLowerCase() === 'a') {
						addClass(el, 'leaflet-active');
					}

					// simulate long hold but setting a timeout
					this._holdTimeout = setTimeout(bind(function () {
						if (this._isTapValid()) {
							this._fireClick = false;
							this._onUp();
							this._simulateEvent('contextmenu', first);
						}
					}, this), 1000);

					this._simulateEvent('mousedown', first);

					on(document, {
						touchmove: this._onMove,
						touchend: this._onUp
					}, this);
				},

				_onUp: function _onUp(e) {
					clearTimeout(this._holdTimeout);

					off(document, {
						touchmove: this._onMove,
						touchend: this._onUp
					}, this);

					if (this._fireClick && e && e.changedTouches) {

						var first = e.changedTouches[0],
						    el = first.target;

						if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
							removeClass(el, 'leaflet-active');
						}

						this._simulateEvent('mouseup', first);

						// simulate click if the touch didn't move too much
						if (this._isTapValid()) {
							this._simulateEvent('click', first);
						}
					}
				},

				_isTapValid: function _isTapValid() {
					return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
				},

				_onMove: function _onMove(e) {
					var first = e.touches[0];
					this._newPos = new Point(first.clientX, first.clientY);
					this._simulateEvent('mousemove', first);
				},

				_simulateEvent: function _simulateEvent(type, e) {
					var simulatedEvent = document.createEvent('MouseEvents');

					simulatedEvent._simulated = true;
					e.target._simulatedClick = true;

					simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);

					e.target.dispatchEvent(simulatedEvent);
				}
			});

			// @section Handlers
			// @property tap: Handler
			// Mobile touch hacks (quick tap and touch hold) handler.
			if (touch && !pointer) {
				Map.addInitHook('addHandler', 'tap', Tap);
			}

			/*
    * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
    */

			// @namespace Map
			// @section Interaction Options
			Map.mergeOptions({
				// @section Touch interaction options
				// @option touchZoom: Boolean|String = *
				// Whether the map can be zoomed by touch-dragging with two fingers. If
				// passed `'center'`, it will zoom to the center of the view regardless of
				// where the touch events (fingers) were. Enabled for touch-capable web
				// browsers except for old Androids.
				touchZoom: touch && !android23,

				// @option bounceAtZoomLimits: Boolean = true
				// Set it to false if you don't want the map to zoom beyond min/max zoom
				// and then bounce back when pinch-zooming.
				bounceAtZoomLimits: true
			});

			var TouchZoom = Handler.extend({
				addHooks: function addHooks() {
					addClass(this._map._container, 'leaflet-touch-zoom');
					on(this._map._container, 'touchstart', this._onTouchStart, this);
				},

				removeHooks: function removeHooks() {
					removeClass(this._map._container, 'leaflet-touch-zoom');
					off(this._map._container, 'touchstart', this._onTouchStart, this);
				},

				_onTouchStart: function _onTouchStart(e) {
					var map = this._map;
					if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
						return;
					}

					var p1 = map.mouseEventToContainerPoint(e.touches[0]),
					    p2 = map.mouseEventToContainerPoint(e.touches[1]);

					this._centerPoint = map.getSize()._divideBy(2);
					this._startLatLng = map.containerPointToLatLng(this._centerPoint);
					if (map.options.touchZoom !== 'center') {
						this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
					}

					this._startDist = p1.distanceTo(p2);
					this._startZoom = map.getZoom();

					this._moved = false;
					this._zooming = true;

					map._stop();

					on(document, 'touchmove', this._onTouchMove, this);
					on(document, 'touchend', this._onTouchEnd, this);

					preventDefault(e);
				},

				_onTouchMove: function _onTouchMove(e) {
					if (!e.touches || e.touches.length !== 2 || !this._zooming) {
						return;
					}

					var map = this._map,
					    p1 = map.mouseEventToContainerPoint(e.touches[0]),
					    p2 = map.mouseEventToContainerPoint(e.touches[1]),
					    scale = p1.distanceTo(p2) / this._startDist;

					this._zoom = map.getScaleZoom(scale, this._startZoom);

					if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
						this._zoom = map._limitZoom(this._zoom);
					}

					if (map.options.touchZoom === 'center') {
						this._center = this._startLatLng;
						if (scale === 1) {
							return;
						}
					} else {
						// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
						var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
						if (scale === 1 && delta.x === 0 && delta.y === 0) {
							return;
						}
						this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
					}

					if (!this._moved) {
						map._moveStart(true, false);
						this._moved = true;
					}

					cancelAnimFrame(this._animRequest);

					var moveFn = bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
					this._animRequest = requestAnimFrame(moveFn, this, true);

					preventDefault(e);
				},

				_onTouchEnd: function _onTouchEnd() {
					if (!this._moved || !this._zooming) {
						this._zooming = false;
						return;
					}

					this._zooming = false;
					cancelAnimFrame(this._animRequest);

					off(document, 'touchmove', this._onTouchMove);
					off(document, 'touchend', this._onTouchEnd);

					// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
					if (this._map.options.zoomAnimation) {
						this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
					} else {
						this._map._resetView(this._center, this._map._limitZoom(this._zoom));
					}
				}
			});

			// @section Handlers
			// @property touchZoom: Handler
			// Touch zoom handler.
			Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

			Map.BoxZoom = BoxZoom;
			Map.DoubleClickZoom = DoubleClickZoom;
			Map.Drag = Drag;
			Map.Keyboard = Keyboard;
			Map.ScrollWheelZoom = ScrollWheelZoom;
			Map.Tap = Tap;
			Map.TouchZoom = TouchZoom;

			Object.freeze = freeze;

			exports.version = version;
			exports.Control = Control;
			exports.control = control;
			exports.Browser = Browser;
			exports.Evented = Evented;
			exports.Mixin = Mixin;
			exports.Util = Util;
			exports.Class = Class;
			exports.Handler = Handler;
			exports.extend = extend;
			exports.bind = bind;
			exports.stamp = stamp;
			exports.setOptions = setOptions;
			exports.DomEvent = DomEvent;
			exports.DomUtil = DomUtil;
			exports.PosAnimation = PosAnimation;
			exports.Draggable = Draggable;
			exports.LineUtil = LineUtil;
			exports.PolyUtil = PolyUtil;
			exports.Point = Point;
			exports.point = toPoint;
			exports.Bounds = Bounds;
			exports.bounds = toBounds;
			exports.Transformation = Transformation;
			exports.transformation = toTransformation;
			exports.Projection = index;
			exports.LatLng = LatLng;
			exports.latLng = toLatLng;
			exports.LatLngBounds = LatLngBounds;
			exports.latLngBounds = toLatLngBounds;
			exports.CRS = CRS;
			exports.GeoJSON = GeoJSON;
			exports.geoJSON = geoJSON;
			exports.geoJson = geoJson;
			exports.Layer = Layer;
			exports.LayerGroup = LayerGroup;
			exports.layerGroup = layerGroup;
			exports.FeatureGroup = FeatureGroup;
			exports.featureGroup = featureGroup;
			exports.ImageOverlay = ImageOverlay;
			exports.imageOverlay = imageOverlay;
			exports.VideoOverlay = VideoOverlay;
			exports.videoOverlay = videoOverlay;
			exports.DivOverlay = DivOverlay;
			exports.Popup = Popup;
			exports.popup = popup;
			exports.Tooltip = Tooltip;
			exports.tooltip = tooltip;
			exports.Icon = Icon;
			exports.icon = icon;
			exports.DivIcon = DivIcon;
			exports.divIcon = divIcon;
			exports.Marker = Marker;
			exports.marker = marker;
			exports.TileLayer = TileLayer;
			exports.tileLayer = tileLayer;
			exports.GridLayer = GridLayer;
			exports.gridLayer = gridLayer;
			exports.SVG = SVG;
			exports.svg = svg$1;
			exports.Renderer = Renderer;
			exports.Canvas = Canvas;
			exports.canvas = canvas$1;
			exports.Path = Path;
			exports.CircleMarker = CircleMarker;
			exports.circleMarker = circleMarker;
			exports.Circle = Circle;
			exports.circle = circle;
			exports.Polyline = Polyline;
			exports.polyline = polyline;
			exports.Polygon = Polygon;
			exports.polygon = polygon;
			exports.Rectangle = Rectangle;
			exports.rectangle = rectangle;
			exports.Map = Map;
			exports.map = createMap;

			var oldL = window.L;
			exports.noConflict = function () {
				window.L = oldL;
				return this;
			};

			// Always export us to window global (see #2364)
			window.L = exports;
		});
	});

	var L$1 = window['L'];

	var factory = function factory(sel, options) {
		var map = L$1.map(sel).setView(options.locations, 13);

		//Create a tile layer that points to the Azure Maps tiles.
		L$1.tileLayer('https://atlas.microsoft.com/map/imagery/png?subscription-key={subscriptionKey}&api-version=1.0&style=satellite&zoom={z}&x={x}&y={y}', {
			attribution: '© ' + new Date().getFullYear() + ' Microsoft, © 1992 - ' + new Date().getFullYear() + ' TomTom',
			// // maxZoom: 20,
			// crossOrigin: true,
			subscriptionKey: 'zD_fp0xJKCNg2fbMfeFDWcq71tn0Z6O9PEvTGu0YE1U'
		}).addTo(map);

		L$1.marker(options.locations, { icon: L$1.icon({
				iconUrl: '../marker.svg',
				iconSize: [35, 49],
				iconAnchor: [17, 49],
				popupAnchor: [-3, -76]
			}) }).addTo(map);
	};

	//https://atlas.microsoft.com/map/tile/png?api-version=1.0&layer=basic&style=main&zoom={z}&x={x}&y={y}&subscription-key={subscriptionKey}
	//https://atlas.microsoft.com/map/imagery/png?subscription-key={subscription-key}&api-version=1.0&style=satellite&zoom={zoom}&x={x}&y={y}

	//there aren't satellite tiles available on azure, only 'imagery tile' which is

	var index = {
		init: function init(sel, opts) {
			return factory(sel, Object.assign({}, defaults, opts));
		}
	};

	exports.default = index;;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
'use strict';

var _dist = require('../../dist');

var _dist2 = _interopRequireDefault(_dist);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

var onDOMContentLoadedTasks = function onDOMContentLoadedTasks() {
    _dist2.default.init('js-map', { locations: [50.7929694199227, -4.55790996551514] });
};

if ('addEventListener' in window) window.addEventListener('DOMContentLoaded', onDOMContentLoadedTasks);

},{"../../dist":1}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L3N0b3JtLW1hcC5zdGFuZGFsb25lLmpzIiwiZXhhbXBsZS9zcmMvYXBwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7O0FBTUMsQ0FBQSxVQUFBLElBQUEsRUFBQSxPQUFBLEVBQXdCO0FBQ3RCLEtBQUksTUFBTTtBQUNOLFdBQVM7QUFESCxFQUFWO0FBR0EsS0FBSSxPQUFBLE9BQUEsS0FBSixXQUFBLEVBQW1DO0FBQy9CLE1BQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxVQUFRLElBQVIsT0FBQTtBQUNBLFNBQUEsT0FBQSxHQUFpQixJQUFBLE9BQUEsQ0FBakIsT0FBQTtBQUhKLEVBQUEsTUFJTztBQUNILFVBQVEsSUFBUixPQUFBO0FBQ0EsT0FBQSxXQUFBLEdBQW1CLElBQUEsT0FBQSxDQUFuQixPQUFBO0FBQ0g7QUFYSCxDQUFBLEVBQUEsU0FBQSxFQWFPLFVBQUEsT0FBQSxFQUFrQjtBQUN2Qjs7QUFFSCxRQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQUEsWUFBQSxFQUE2QztBQUM1QyxTQUFPO0FBRHFDLEVBQTdDOztBQUlBLEtBQUksVUFBVSxPQUFBLE1BQUEsS0FBQSxVQUFBLElBQWdDLFNBQU8sT0FBUCxRQUFBLE1BQWhDLFFBQUEsR0FBc0UsVUFBQSxHQUFBLEVBQWU7QUFBRSxTQUFBLE9BQUEsR0FBQSxLQUFBLFdBQUEsR0FBQSxXQUFBLEdBQUEsU0FBQSxHQUFBLENBQUE7QUFBdkYsRUFBQSxHQUE4RyxVQUFBLEdBQUEsRUFBZTtBQUFFLFNBQU8sT0FBTyxPQUFBLE1BQUEsS0FBUCxVQUFBLElBQXVDLElBQUEsV0FBQSxLQUF2QyxNQUFBLElBQXFFLFFBQVEsT0FBN0UsU0FBQSxHQUFBLFFBQUEsR0FBQSxPQUFBLEdBQUEsS0FBQSxXQUFBLEdBQUEsV0FBQSxHQUFBLFNBQVAsR0FBTyxDQUFQO0FBQTdJLEVBQUE7O0FB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QUFDTixXQUFBLElBQUEsQ0FBQSxVQUFBLENBQXFCLEtBQXJCLE9BQUEsRUFBbUMsS0FBQSxJQUFBLENBQUEsVUFBQSxDQUFxQixLQUF4RCxLQUFtQyxDQUFuQztBQUNBO0FBQ0Q7QUFyRzZCLElBQWYsQ0FBaEI7O0FBd0dBO0FBQ0E7QUFDQTtBQUNBLE9BQUEsV0FBQSxDQUFBLFlBQUEsRUFBQSxXQUFBLEVBQUEsU0FBQTs7QUFFQSxPQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsT0FBQSxlQUFBLEdBQUEsZUFBQTtBQUNBLE9BQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxPQUFBLFFBQUEsR0FBQSxRQUFBO0FBQ0EsT0FBQSxlQUFBLEdBQUEsZUFBQTtBQUNBLE9BQUEsR0FBQSxHQUFBLEdBQUE7QUFDQSxPQUFBLFNBQUEsR0FBQSxTQUFBOztBQUVBLFVBQUEsTUFBQSxHQUFBLE1BQUE7O0FBRUEsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxXQUFBLEtBQUEsR0FBQSxLQUFBO0FBQ0EsV0FBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLFdBQUEsS0FBQSxHQUFBLEtBQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxNQUFBLEdBQUEsTUFBQTtBQUNBLFdBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxXQUFBLEtBQUEsR0FBQSxLQUFBO0FBQ0EsV0FBQSxVQUFBLEdBQUEsVUFBQTtBQUNBLFdBQUEsUUFBQSxHQUFBLFFBQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxZQUFBLEdBQUEsWUFBQTtBQUNBLFdBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxXQUFBLFFBQUEsR0FBQSxRQUFBO0FBQ0EsV0FBQSxRQUFBLEdBQUEsUUFBQTtBQUNBLFdBQUEsS0FBQSxHQUFBLEtBQUE7QUFDQSxXQUFBLEtBQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxNQUFBLEdBQUEsTUFBQTtBQUNBLFdBQUEsTUFBQSxHQUFBLFFBQUE7QUFDQSxXQUFBLGNBQUEsR0FBQSxjQUFBO0FBQ0EsV0FBQSxjQUFBLEdBQUEsZ0JBQUE7QUFDQSxXQUFBLFVBQUEsR0FBQSxLQUFBO0FBQ0EsV0FBQSxNQUFBLEdBQUEsTUFBQTtBQUNBLFdBQUEsTUFBQSxHQUFBLFFBQUE7QUFDQSxXQUFBLFlBQUEsR0FBQSxZQUFBO0FBQ0EsV0FBQSxZQUFBLEdBQUEsY0FBQTtBQUNBLFdBQUEsR0FBQSxHQUFBLEdBQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxXQUFBLEtBQUEsR0FBQSxLQUFBO0FBQ0EsV0FBQSxVQUFBLEdBQUEsVUFBQTtBQUNBLFdBQUEsVUFBQSxHQUFBLFVBQUE7QUFDQSxXQUFBLFlBQUEsR0FBQSxZQUFBO0FBQ0EsV0FBQSxZQUFBLEdBQUEsWUFBQTtBQUNBLFdBQUEsWUFBQSxHQUFBLFlBQUE7QUFDQSxXQUFBLFlBQUEsR0FBQSxZQUFBO0FBQ0EsV0FBQSxZQUFBLEdBQUEsWUFBQTtBQUNBLFdBQUEsWUFBQSxHQUFBLFlBQUE7QUFDQSxXQUFBLFVBQUEsR0FBQSxVQUFBO0FBQ0EsV0FBQSxLQUFBLEdBQUEsS0FBQTtBQUNBLFdBQUEsS0FBQSxHQUFBLEtBQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxXQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxXQUFBLE1BQUEsR0FBQSxNQUFBO0FBQ0EsV0FBQSxNQUFBLEdBQUEsTUFBQTtBQUNBLFdBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxXQUFBLFNBQUEsR0FBQSxTQUFBO0FBQ0EsV0FBQSxTQUFBLEdBQUEsU0FBQTtBQUNBLFdBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxXQUFBLEdBQUEsR0FBQSxHQUFBO0FBQ0EsV0FBQSxHQUFBLEdBQUEsS0FBQTtBQUNBLFdBQUEsUUFBQSxHQUFBLFFBQUE7QUFDQSxXQUFBLE1BQUEsR0FBQSxNQUFBO0FBQ0EsV0FBQSxNQUFBLEdBQUEsUUFBQTtBQUNBLFdBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxXQUFBLFlBQUEsR0FBQSxZQUFBO0FBQ0EsV0FBQSxZQUFBLEdBQUEsWUFBQTtBQUNBLFdBQUEsTUFBQSxHQUFBLE1BQUE7QUFDQSxXQUFBLE1BQUEsR0FBQSxNQUFBO0FBQ0EsV0FBQSxRQUFBLEdBQUEsUUFBQTtBQUNBLFdBQUEsUUFBQSxHQUFBLFFBQUE7QUFDQSxXQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsV0FBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLFdBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxXQUFBLFNBQUEsR0FBQSxTQUFBO0FBQ0EsV0FBQSxHQUFBLEdBQUEsR0FBQTtBQUNBLFdBQUEsR0FBQSxHQUFBLFNBQUE7O0FBRUEsT0FBSSxPQUFPLE9BQVgsQ0FBQTtBQUNBLFdBQUEsVUFBQSxHQUFxQixZQUFZO0FBQ2hDLFdBQUEsQ0FBQSxHQUFBLElBQUE7QUFDQSxXQUFBLElBQUE7QUFGRCxJQUFBOztBQUtBO0FBQ0EsVUFBQSxDQUFBLEdBQUEsT0FBQTtBQTdsYkQsR0FBQTtBQU5ELEVBQWlCLENBQWpCOztBQXVtYkEsS0FBSSxNQUFNLE9BQVYsR0FBVSxDQUFWOztBQUVBLEtBQUksVUFBVSxTQUFBLE9BQUEsQ0FBQSxHQUFBLEVBQUEsT0FBQSxFQUErQjtBQUM1QyxNQUFJLE1BQU0sSUFBQSxHQUFBLENBQUEsR0FBQSxFQUFBLE9BQUEsQ0FBcUIsUUFBckIsU0FBQSxFQUFWLEVBQVUsQ0FBVjs7QUFFQTtBQUNBLE1BQUEsU0FBQSxDQUFBLHFJQUFBLEVBQXFKO0FBQ3BKLGdCQUFhLE9BQU8sSUFBQSxJQUFBLEdBQVAsV0FBTyxFQUFQLEdBQUEsdUJBQUEsR0FBNEQsSUFBQSxJQUFBLEdBQTVELFdBQTRELEVBQTVELEdBRHVJLFNBQUE7QUFFcEo7QUFDQTtBQUNBLG9CQUFpQjtBQUptSSxHQUFySixFQUFBLEtBQUEsQ0FBQSxHQUFBOztBQU9BLE1BQUEsTUFBQSxDQUFXLFFBQVgsU0FBQSxFQUE4QixFQUFFLE1BQU0sSUFBQSxJQUFBLENBQVM7QUFDN0MsYUFENkMsZUFBQTtBQUU3QyxjQUFVLENBQUEsRUFBQSxFQUZtQyxFQUVuQyxDQUZtQztBQUc3QyxnQkFBWSxDQUFBLEVBQUEsRUFIaUMsRUFHakMsQ0FIaUM7QUFJN0MsaUJBQWEsQ0FBQyxDQUFELENBQUEsRUFBSyxDQUFMLEVBQUE7QUFKZ0MsSUFBVCxDQUFSLEVBQTlCLEVBQUEsS0FBQSxDQUFBLEdBQUE7QUFYRCxFQUFBOztBQW1CQTtBQUNBOztBQUVBOztBQUVBLEtBQUksUUFBUTtBQUNYLFFBQU0sU0FBQSxJQUFBLENBQUEsR0FBQSxFQUFBLElBQUEsRUFBeUI7QUFDOUIsVUFBTyxRQUFBLEdBQUEsRUFBYSxPQUFBLE1BQUEsQ0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFwQixJQUFvQixDQUFiLENBQVA7QUFDQTtBQUhVLEVBQVo7O0FBTUEsU0FBQSxPQUFBLEdBQUEsS0FBQSxDQUF3QjtBQXZxYnhCLENBQUM7Ozs7Ozs7QUNORCxJQUFBLFFBQUEsUUFBQSxZQUFBLENBQUE7Ozs7Ozs7O0FBRUEsSUFBTSwwQkFBMEIsU0FBMUIsdUJBQTBCLEdBQU07QUFDbEMsV0FBQSxPQUFBLENBQUEsSUFBQSxDQUFBLFFBQUEsRUFBbUIsRUFBRSxXQUFXLENBQUEsZ0JBQUEsRUFBbUIsQ0FBbkQsZ0JBQWdDLENBQWIsRUFBbkI7QUFESixDQUFBOztBQUlBLElBQUcsc0JBQUgsTUFBQSxFQUFpQyxPQUFBLGdCQUFBLENBQUEsa0JBQUEsRUFBQSx1QkFBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogQG5hbWUgc3Rvcm0tbWFwOiBcbiAqIEB2ZXJzaW9uIDAuMS4wOiBUaHUsIDI2IEp1bCAyMDE4IDEyOjM5OjU4IEdNVFxuICogQGF1dGhvciBzdG9ybWlkXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgIHZhciBtb2QgPSB7XG4gICAgICAgZXhwb3J0czoge31cbiAgIH07XG4gICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICBtb2QuZXhwb3J0cyA9IGV4cG9ydHNcbiAgICAgICBmYWN0b3J5KG1vZC5leHBvcnRzKVxuICAgICAgIG1vZHVsZS5leHBvcnRzID0gbW9kLmV4cG9ydHMuZGVmYXVsdFxuICAgfSBlbHNlIHtcbiAgICAgICBmYWN0b3J5KG1vZC5leHBvcnRzKTtcbiAgICAgICByb290Lmd1bHBXcmFwVW1kID0gbW9kLmV4cG9ydHMuZGVmYXVsdFxuICAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICd1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGNhbGxiYWNrOiBudWxsXG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGxlYWZsZXRTcmMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdC8qIEBwcmVzZXJ2ZVxuICAqIExlYWZsZXQgMS4zLjMsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cDovL2xlYWZsZXRqcy5jb21cbiAgKiAoYykgMjAxMC0yMDE4IFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiAgKi9cblxuXHQoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHRcdGZhY3RvcnkoZXhwb3J0cyk7XG5cdH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdHZhciB2ZXJzaW9uID0gXCIxLjMuM1wiO1xuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIFV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xuXG5cdFx0dmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG5cdFx0T2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblxuXHRcdC8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3Rcblx0XHQvLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxuXHRcdGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XG5cdFx0XHR2YXIgaSwgaiwgbGVuLCBzcmM7XG5cblx0XHRcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHRcdFx0XHRzcmMgPSBhcmd1bWVudHNbal07XG5cdFx0XHRcdGZvciAoaSBpbiBzcmMpIHtcblx0XHRcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVzdDtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3Rcblx0XHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcblx0XHR2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRmdW5jdGlvbiBGKCkge31cblx0XHRcdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcblx0XHRcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdFx0cmV0dXJuIG5ldyBGKCk7XG5cdFx0XHR9O1xuXHRcdH0oKTtcblxuXHRcdC8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cblx0XHQvLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXG5cdFx0Ly8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cblx0XHRmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcblx0XHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXHRcdFx0aWYgKGZuLmJpbmQpIHtcblx0XHRcdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcblx0XHQvLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxuXHRcdHZhciBsYXN0SWQgPSAwO1xuXG5cdFx0Ly8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXG5cdFx0Ly8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXG5cdFx0ZnVuY3Rpb24gc3RhbXAob2JqKSB7XG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXG5cdFx0XHRvYmouX2xlYWZsZXRfaWQgPSBvYmouX2xlYWZsZXRfaWQgfHwgKytsYXN0SWQ7XG5cdFx0XHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xuXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cblx0XHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcblx0XHQvLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cblx0XHQvLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xuXHRcdC8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcblx0XHQvLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXG5cdFx0Ly8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cblx0XHRmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xuXHRcdFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XG5cblx0XHRcdGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG5cdFx0XHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXG5cdFx0XHRcdGxvY2sgPSBmYWxzZTtcblx0XHRcdFx0aWYgKGFyZ3MpIHtcblx0XHRcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdFx0XHRcdFx0YXJncyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR3cmFwcGVyRm4gPSBmdW5jdGlvbiB3cmFwcGVyRm4oKSB7XG5cdFx0XHRcdGlmIChsb2NrKSB7XG5cdFx0XHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXG5cdFx0XHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcblx0XHRcdFx0XHRsb2NrID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIHdyYXBwZXJGbjtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxuXHRcdC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXG5cdFx0Ly8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxuXHRcdC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxuXHRcdGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcblx0XHRcdHZhciBtYXggPSByYW5nZVsxXSxcblx0XHRcdCAgICBtaW4gPSByYW5nZVswXSxcblx0XHRcdCAgICBkID0gbWF4IC0gbWluO1xuXHRcdFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXG5cdFx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG5cdFx0ZnVuY3Rpb24gZmFsc2VGbigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcblx0XHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxuXHRcdGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIGRpZ2l0cykge1xuXHRcdFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpO1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xuXHRcdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxuXHRcdGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXG5cdFx0Ly8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxuXHRcdGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxuXHRcdC8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cblx0XHRmdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuXHRcdFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmoub3B0aW9ucztcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXG5cdFx0Ly8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxuXHRcdC8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcblx0XHQvLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxuXHRcdC8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcblx0XHRmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcblx0XHRcdHZhciBwYXJhbXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHR2YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3Xy1dKykgKlxcfS9nO1xuXG5cdFx0Ly8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcblx0XHQvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2Bcblx0XHQvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xuXHRcdC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxuXHRcdC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxuXHRcdGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cblx0XHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcblx0XHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHRcdH07XG5cblx0XHQvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcblx0XHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXG5cdFx0ZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycmF5W2ldID09PSBlbCkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXG5cdFx0Ly8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xuXHRcdC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxuXHRcdC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxuXHRcdC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cblx0XHR2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcblxuXHRcdC8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cblx0XHRmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcblx0XHR9XG5cblx0XHR2YXIgbGFzdFRpbWUgPSAwO1xuXG5cdFx0Ly8gZmFsbGJhY2sgZm9yIElFIDctOFxuXHRcdGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xuXHRcdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XG5cblx0XHRcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xuXHRcdH1cblxuXHRcdHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XG5cdFx0dmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8IGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuXHRcdH07XG5cblx0XHQvLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcblx0XHQvLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXG5cdFx0Ly8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcblx0XHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXG5cdFx0Ly8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxuXHRcdC8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuXHRcdGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xuXHRcdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xuXHRcdFx0XHRmbi5jYWxsKGNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxuXHRcdC8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxuXHRcdGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xuXHRcdFx0aWYgKGlkKSB7XG5cdFx0XHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIFV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0XHRcdGZyZWV6ZTogZnJlZXplLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGJpbmQ6IGJpbmQsXG5cdFx0XHRsYXN0SWQ6IGxhc3RJZCxcblx0XHRcdHN0YW1wOiBzdGFtcCxcblx0XHRcdHRocm90dGxlOiB0aHJvdHRsZSxcblx0XHRcdHdyYXBOdW06IHdyYXBOdW0sXG5cdFx0XHRmYWxzZUZuOiBmYWxzZUZuLFxuXHRcdFx0Zm9ybWF0TnVtOiBmb3JtYXROdW0sXG5cdFx0XHR0cmltOiB0cmltLFxuXHRcdFx0c3BsaXRXb3Jkczogc3BsaXRXb3Jkcyxcblx0XHRcdHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG5cdFx0XHRnZXRQYXJhbVN0cmluZzogZ2V0UGFyYW1TdHJpbmcsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRpc0FycmF5OiBpc0FycmF5LFxuXHRcdFx0aW5kZXhPZjogaW5kZXhPZixcblx0XHRcdGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG5cdFx0XHRyZXF1ZXN0Rm46IHJlcXVlc3RGbixcblx0XHRcdGNhbmNlbEZuOiBjYW5jZWxGbixcblx0XHRcdHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG5cdFx0XHRjYW5jZWxBbmltRnJhbWU6IGNhbmNlbEFuaW1GcmFtZVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGNsYXNzIENsYXNzXG5cdFx0Ly8gQGFrYSBMLkNsYXNzXG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEB1bmluaGVyaXRhYmxlXG5cblx0XHQvLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcblxuXHRcdGZ1bmN0aW9uIENsYXNzKCkge31cblxuXHRcdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xuXG5cdFx0XHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxuXHRcdFx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXG5cdFx0XHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cblx0XHRcdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uIE5ld0NsYXNzKCkge1xuXG5cdFx0XHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcblx0XHRcdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXG5cdFx0XHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XG5cblx0XHRcdHZhciBwcm90byA9IGNyZWF0ZShwYXJlbnRQcm90byk7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xuXG5cdFx0XHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcblxuXHRcdFx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpIHtcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcblx0XHRcdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXG5cdFx0XHRpZiAocHJvcHMuc3RhdGljcykge1xuXHRcdFx0XHRleHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xuXHRcdFx0XHRkZWxldGUgcHJvcHMuc3RhdGljcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxuXHRcdFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XG5cdFx0XHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcblx0XHRcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XG5cdFx0XHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWVyZ2Ugb3B0aW9uc1xuXHRcdFx0aWYgKHByb3RvLm9wdGlvbnMpIHtcblx0XHRcdFx0cHJvcHMub3B0aW9ucyA9IGV4dGVuZChjcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcblx0XHRcdGV4dGVuZChwcm90bywgcHJvcHMpO1xuXG5cdFx0XHRwcm90by5faW5pdEhvb2tzID0gW107XG5cblx0XHRcdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXG5cdFx0XHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xuXHRcdFx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBOZXdDbGFzcztcblx0XHR9O1xuXG5cdFx0Ly8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xuXHRcdC8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXG5cdFx0Q2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXG5cdFx0Ly8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXG5cdFx0Q2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdGV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHQvLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xuXHRcdC8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXG5cdFx0Q2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdFx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcblx0XHRcdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xuXHRcdFx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGluY2x1ZGVzID0gaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICsgJ3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArICdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIEV2ZW50ZWRcclxuICAgKiBAYWthIEwuRXZlbnRlZFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICAgKiB9ICk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAgICpcclxuICAgKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBgYGBcclxuICAgKi9cblxuXHRcdHZhciBFdmVudHMgPSB7XG5cdFx0XHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcbiAgICAqXHJcbiAgICAqIEBhbHRlcm5hdGl2ZVxyXG4gICAgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgICAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICAgICovXG5cdFx0XHRvbjogZnVuY3Rpb24gb24odHlwZXMsIGZuLCBjb250ZXh0KSB7XG5cblx0XHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdFx0XHRcdGlmICgodHlwZW9mIHR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0eXBlcykpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcblx0XHRcdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcblx0XHRcdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxuXHRcdFx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xuXHRcdFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgICAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgICAqXHJcbiAgICAqIEBhbHRlcm5hdGl2ZVxyXG4gICAgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gICAgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcbiAgICAqXHJcbiAgICAqIEBhbHRlcm5hdGl2ZVxyXG4gICAgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG4gICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LlxyXG4gICAgKi9cblx0XHRcdG9mZjogZnVuY3Rpb24gb2ZmKHR5cGVzLCBmbiwgY29udGV4dCkge1xuXG5cdFx0XHRcdGlmICghdHlwZXMpIHtcblx0XHRcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiB0eXBlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZXMpKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcblx0XHRcdF9vbjogZnVuY3Rpb24gX29uKHR5cGUsIGZuLCBjb250ZXh0KSB7XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcblxuXHRcdFx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cblx0XHRcdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cdFx0XHRcdGlmICghdHlwZUxpc3RlbmVycykge1xuXHRcdFx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcblx0XHRcdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXG5cdFx0XHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7IGZuOiBmbiwgY3R4OiBjb250ZXh0IH0sXG5cdFx0XHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb2ZmOiBmdW5jdGlvbiBfb2ZmKHR5cGUsIGZuLCBjb250ZXh0KSB7XG5cdFx0XHRcdHZhciBsaXN0ZW5lcnMsIGksIGxlbjtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuXHRcdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghZm4pIHtcblx0XHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBmYWxzZUZuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobGlzdGVuZXJzKSB7XG5cblx0XHRcdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxuXHRcdFx0XHRcdFx0XHRsLmZuID0gZmFsc2VGbjtcblxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcblx0XHRcdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxuXHRcdFx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcblx0XHRcdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXG5cdFx0XHRmaXJlOiBmdW5jdGlvbiBmaXJlKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xuXHRcdFx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZXZlbnQgPSBleHRlbmQoe30sIGRhdGEsIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdHRhcmdldDogdGhpcyxcblx0XHRcdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XG5cdFx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gdGhpcy5fZmlyaW5nQ291bnQgKyAxIHx8IDE7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xuXHRcdFx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcm9wYWdhdGUpIHtcblx0XHRcdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxuXHRcdFx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxuXHRcdFx0bGlzdGVuczogZnVuY3Rpb24gbGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpIHtcblx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BhZ2F0ZSkge1xuXHRcdFx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcblx0XHRcdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcblx0XHRcdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxuXHRcdFx0b25jZTogZnVuY3Rpb24gb25jZSh0eXBlcywgZm4sIGNvbnRleHQpIHtcblxuXHRcdFx0XHRpZiAoKHR5cGVvZiB0eXBlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZXMpKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaGFuZGxlciA9IGJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMub2ZmKHR5cGVzLCBmbiwgY29udGV4dCkub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcblx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vbih0eXBlcywgZm4sIGNvbnRleHQpLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xuXHRcdFx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcblx0XHRcdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiBhZGRFdmVudFBhcmVudChvYmopIHtcblx0XHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXG5cdFx0XHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xuXHRcdFx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50UGFyZW50KG9iaikge1xuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gX3Byb3BhZ2F0ZUV2ZW50KGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgZXh0ZW5kKHtcblx0XHRcdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcblx0XHRcdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxuXHRcdFx0XHRcdH0sIGUpLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxuXG5cdFx0Ly8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcblx0XHQvLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcblx0XHRFdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcblxuXHRcdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXG5cdFx0Ly8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcblxuXHRcdC8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXG5cdFx0Ly8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcblx0XHRFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcblxuXHRcdC8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xuXHRcdC8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcblx0XHRFdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcblxuXHRcdC8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcblx0XHQvLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXG5cdFx0RXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xuXG5cdFx0Ly8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXG5cdFx0Ly8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxuXHRcdEV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xuXG5cdFx0dmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIFBvaW50XHJcbiAgICogQGFrYSBMLlBvaW50XHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAgICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cblxuXHRcdGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XG5cdFx0XHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG5cdFx0XHR0aGlzLnggPSByb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4O1xuXHRcdFx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuXHRcdFx0dGhpcy55ID0gcm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeTtcblx0XHR9XG5cblx0XHR2YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xuXHRcdH07XG5cblx0XHRQb2ludC5wcm90b3R5cGUgPSB7XG5cblx0XHRcdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKHBvaW50KSB7XG5cdFx0XHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FkZDogZnVuY3Rpb24gX2FkZChwb2ludCkge1xuXHRcdFx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XG5cdFx0XHRcdHRoaXMueCArPSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLnkgKz0gcG9pbnQueTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cblx0XHRcdHN1YnRyYWN0OiBmdW5jdGlvbiBzdWJ0cmFjdChwb2ludCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfc3VidHJhY3Q6IGZ1bmN0aW9uIF9zdWJ0cmFjdChwb2ludCkge1xuXHRcdFx0XHR0aGlzLnggLT0gcG9pbnQueDtcblx0XHRcdFx0dGhpcy55IC09IHBvaW50Lnk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cblx0XHRcdGRpdmlkZUJ5OiBmdW5jdGlvbiBkaXZpZGVCeShudW0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcblx0XHRcdH0sXG5cblx0XHRcdF9kaXZpZGVCeTogZnVuY3Rpb24gX2RpdmlkZUJ5KG51bSkge1xuXHRcdFx0XHR0aGlzLnggLz0gbnVtO1xuXHRcdFx0XHR0aGlzLnkgLz0gbnVtO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cblx0XHRcdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIG11bHRpcGx5QnkobnVtKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcblx0XHRcdH0sXG5cblx0XHRcdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiBfbXVsdGlwbHlCeShudW0pIHtcblx0XHRcdFx0dGhpcy54ICo9IG51bTtcblx0XHRcdFx0dGhpcy55ICo9IG51bTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2Zcblx0XHRcdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXG5cdFx0XHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxuXHRcdFx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxuXHRcdFx0c2NhbGVCeTogZnVuY3Rpb24gc2NhbGVCeShwb2ludCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XG5cdFx0XHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cblx0XHRcdHVuc2NhbGVCeTogZnVuY3Rpb24gdW5zY2FsZUJ5KHBvaW50KSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXG5cdFx0XHRyb3VuZDogZnVuY3Rpb24gcm91bmQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcm91bmQ6IGZ1bmN0aW9uIF9yb3VuZCgpIHtcblx0XHRcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuXHRcdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxuXHRcdFx0Zmxvb3I6IGZ1bmN0aW9uIGZsb29yKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2Zsb29yOiBmdW5jdGlvbiBfZmxvb3IoKSB7XG5cdFx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxuXHRcdFx0Y2VpbDogZnVuY3Rpb24gY2VpbCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NlaWw6IGZ1bmN0aW9uIF9jZWlsKCkge1xuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cblx0XHRcdHRydW5jOiBmdW5jdGlvbiB0cnVuYygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcblx0XHRcdH0sXG5cblx0XHRcdF90cnVuYzogZnVuY3Rpb24gX3RydW5jKCkge1xuXHRcdFx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xuXHRcdFx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXG5cdFx0XHRkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKHBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG5cblx0XHRcdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxuXHRcdFx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cblx0XHRcdGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG5cblx0XHRcdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJiBwb2ludC55ID09PSB0aGlzLnk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxuXHRcdFx0Y29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKHBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiYgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXG5cdFx0XHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdFx0XHRyZXR1cm4gJ1BvaW50KCcgKyBmb3JtYXROdW0odGhpcy54KSArICcsICcgKyBmb3JtYXROdW0odGhpcy55KSArICcpJztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxuXHRcdC8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxuXG5cdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0Ly8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxuXHRcdC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cblxuXHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdC8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXG5cdFx0Ly8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cblx0XHRmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XG5cdFx0XHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkoeCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcblx0XHRcdH1cblx0XHRcdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdH1cblx0XHRcdGlmICgodHlwZW9mIHggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHgpKSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcblx0XHR9XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBCb3VuZHNcclxuICAgKiBAYWthIEwuQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICAgKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICAgKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xuXG5cdFx0ZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcblx0XHRcdGlmICghYSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdEJvdW5kcy5wcm90b3R5cGUgPSB7XG5cdFx0XHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXG5cdFx0XHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChwb2ludCkge1xuXHRcdFx0XHQvLyAoUG9pbnQpXG5cdFx0XHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG5cblx0XHRcdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcblx0XHRcdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuXHRcdFx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxuXHRcdFx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuXHRcdFx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xuXHRcdFx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xuXHRcdFx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcblx0XHRcdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XG5cdFx0XHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxuXHRcdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIocm91bmQpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludCgodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMiwgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cblx0XHRcdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cblx0XHRcdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiBnZXRUb3BSaWdodCgpIHtcblx0XHRcdFx0Ly8gLT4gUG9pbnRcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cblx0XHRcdGdldFRvcExlZnQ6IGZ1bmN0aW9uIGdldFRvcExlZnQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cblx0XHRcdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiBnZXRCb3R0b21SaWdodCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xuXHRcdFx0Z2V0U2l6ZTogZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cblx0XHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdFx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXG5cdFx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cblx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhvYmopIHtcblx0XHRcdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xuXHRcdFx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xuXHRcdFx0XHRcdG1pbiA9IG9iai5taW47XG5cdFx0XHRcdFx0bWF4ID0gb2JqLm1heDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW4gPSBtYXggPSBvYmo7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWluLnggPj0gdGhpcy5taW4ueCAmJiBtYXgueCA8PSB0aGlzLm1heC54ICYmIG1pbi55ID49IHRoaXMubWluLnkgJiYgbWF4LnkgPD0gdGhpcy5tYXgueTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcblx0XHRcdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cblx0XHRcdGludGVyc2VjdHM6IGZ1bmN0aW9uIGludGVyc2VjdHMoYm91bmRzKSB7XG5cdFx0XHRcdC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cblx0XHRcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcblxuXHRcdFx0XHR2YXIgbWluID0gdGhpcy5taW4sXG5cdFx0XHRcdCAgICBtYXggPSB0aGlzLm1heCxcblx0XHRcdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxuXHRcdFx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXG5cdFx0XHRcdCAgICB4SW50ZXJzZWN0cyA9IG1heDIueCA+PSBtaW4ueCAmJiBtaW4yLnggPD0gbWF4LngsXG5cdFx0XHRcdCAgICB5SW50ZXJzZWN0cyA9IG1heDIueSA+PSBtaW4ueSAmJiBtaW4yLnkgPD0gbWF4Lnk7XG5cblx0XHRcdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXG5cdFx0XHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxuXHRcdFx0b3ZlcmxhcHM6IGZ1bmN0aW9uIG92ZXJsYXBzKGJvdW5kcykge1xuXHRcdFx0XHQvLyAoQm91bmRzKSAtPiBCb29sZWFuXG5cdFx0XHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XG5cblx0XHRcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxuXHRcdFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXG5cdFx0XHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcblx0XHRcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxuXHRcdFx0XHQgICAgeE92ZXJsYXBzID0gbWF4Mi54ID4gbWluLnggJiYgbWluMi54IDwgbWF4LngsXG5cdFx0XHRcdCAgICB5T3ZlcmxhcHMgPSBtYXgyLnkgPiBtaW4ueSAmJiBtaW4yLnkgPCBtYXgueTtcblxuXHRcdFx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcblx0XHRcdH0sXG5cblx0XHRcdGlzVmFsaWQ6IGZ1bmN0aW9uIGlzVmFsaWQoKSB7XG5cdFx0XHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcblx0XHQvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXG5cdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0Ly8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxuXHRcdC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cblx0XHRmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XG5cdFx0XHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xuXHRcdH1cblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gICAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICAgKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICAgKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAuZml0Qm91bmRzKFtcclxuICAgKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gICAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICAgKiBdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXG5cblx0XHRmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikge1xuXHRcdFx0Ly8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXG5cdFx0XHRpZiAoIWNvcm5lcjEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRMYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xuXG5cdFx0XHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcblx0XHRcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XG5cblx0XHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0XHRcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG5cdFx0XHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcblx0XHRcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxuXHRcdFx0XHQgICAgc3cyLFxuXHRcdFx0XHQgICAgbmUyO1xuXG5cdFx0XHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcblx0XHRcdFx0XHRzdzIgPSBvYmo7XG5cdFx0XHRcdFx0bmUyID0gb2JqO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xuXHRcdFx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xuXHRcdFx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xuXG5cdFx0XHRcdFx0aWYgKCFzdzIgfHwgIW5lMikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghc3cgJiYgIW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcblx0XHRcdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XG5cdFx0XHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcblx0XHRcdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xuXHRcdFx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcblx0XHRcdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXG5cdFx0XHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cblx0XHRcdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cblx0XHRcdHBhZDogZnVuY3Rpb24gcGFkKGJ1ZmZlclJhdGlvKSB7XG5cdFx0XHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcblx0XHRcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxuXHRcdFx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxuXHRcdFx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSwgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0XHRcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxuXHRcdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKCh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLCAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcblx0XHRcdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cblx0XHRcdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gZ2V0U291dGhXZXN0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXG5cdFx0XHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uIGdldE5vcnRoRWFzdCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xuXHRcdFx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxuXHRcdFx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiBnZXROb3J0aFdlc3QoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXG5cdFx0XHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uIGdldFNvdXRoRWFzdCgpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXG5cdFx0XHRnZXRXZXN0OiBmdW5jdGlvbiBnZXRXZXN0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXG5cdFx0XHRnZXRTb3V0aDogZnVuY3Rpb24gZ2V0U291dGgoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xuXHRcdFx0Z2V0RWFzdDogZnVuY3Rpb24gZ2V0RWFzdCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xuXHRcdFx0Z2V0Tm9ydGg6IGZ1bmN0aW9uIGdldE5vcnRoKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cblxuXHRcdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0XHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuXHRcdFx0Y29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKG9iaikge1xuXHRcdFx0XHQvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XG5cdFx0XHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxuXHRcdFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXG5cdFx0XHRcdCAgICBzdzIsXG5cdFx0XHRcdCAgICBuZTI7XG5cblx0XHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xuXHRcdFx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcblx0XHRcdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3cyID0gbmUyID0gb2JqO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN3Mi5sYXQgPj0gc3cubGF0ICYmIG5lMi5sYXQgPD0gbmUubGF0ICYmIHN3Mi5sbmcgPj0gc3cubG5nICYmIG5lMi5sbmcgPD0gbmUubG5nO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXG5cdFx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXG5cdFx0XHRpbnRlcnNlY3RzOiBmdW5jdGlvbiBpbnRlcnNlY3RzKGJvdW5kcykge1xuXHRcdFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xuXG5cdFx0XHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcblx0XHRcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxuXHRcdFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IG5lMi5sYXQgPj0gc3cubGF0ICYmIHN3Mi5sYXQgPD0gbmUubGF0LFxuXHRcdFx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IG5lMi5sbmcgPj0gc3cubG5nICYmIHN3Mi5sbmcgPD0gbmUubG5nO1xuXG5cdFx0XHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXG5cdFx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cblx0XHRcdG92ZXJsYXBzOiBmdW5jdGlvbiBvdmVybGFwcyhib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcblxuXHRcdFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXG5cdFx0XHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcblx0XHRcdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdFx0ICAgIGxhdE92ZXJsYXBzID0gbmUyLmxhdCA+IHN3LmxhdCAmJiBzdzIubGF0IDwgbmUubGF0LFxuXHRcdFx0XHQgICAgbG5nT3ZlcmxhcHMgPSBuZTIubG5nID4gc3cubG5nICYmIHN3Mi5sbmcgPCBuZS5sbmc7XG5cblx0XHRcdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXG5cdFx0XHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cblx0XHRcdHRvQkJveFN0cmluZzogZnVuY3Rpb24gdG9CQm94U3RyaW5nKCkge1xuXHRcdFx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXG5cdFx0XHRlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhib3VuZHMsIG1heE1hcmdpbikge1xuXHRcdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxuXHRcdFx0aXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZCgpIHtcblx0XHRcdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXG5cdFx0Ly8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXG5cblx0XHQvLyBAYWx0ZXJuYXRpdmVcblx0XHQvLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcblx0XHQvLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXG5cdFx0ZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xuXHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcblx0XHR9XG5cblx0XHQvKiBAY2xhc3MgTGF0TG5nXHJcbiAgICogQGFrYSBMLkxhdExuZ1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAgICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAgICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAgICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXG5cblx0XHRmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xuXHRcdFx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXG5cdFx0XHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXG5cdFx0XHR0aGlzLmxhdCA9ICtsYXQ7XG5cblx0XHRcdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxuXHRcdFx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcblx0XHRcdHRoaXMubG5nID0gK2xuZztcblxuXHRcdFx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXG5cdFx0XHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxuXHRcdFx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuYWx0ID0gK2FsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRMYXRMbmcucHJvdG90eXBlID0ge1xuXHRcdFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXG5cdFx0XHRlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhvYmosIG1heE1hcmdpbikge1xuXHRcdFx0XHRpZiAoIW9iaikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XG5cblx0XHRcdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xuXG5cdFx0XHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXG5cdFx0XHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcocHJlY2lzaW9uKSB7XG5cdFx0XHRcdHJldHVybiAnTGF0TG5nKCcgKyBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICsgZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxuXHRcdFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gZGlzdGFuY2VUbyhvdGhlcikge1xuXHRcdFx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcblx0XHRcdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxuXHRcdFx0d3JhcDogZnVuY3Rpb24gd3JhcCgpIHtcblx0XHRcdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxuXHRcdFx0dG9Cb3VuZHM6IGZ1bmN0aW9uIHRvQm91bmRzKHNpemVJbk1ldGVycykge1xuXHRcdFx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcblx0XHRcdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogdGhpcy5sYXQpO1xuXG5cdFx0XHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcblx0XHQvLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxuXG5cdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0Ly8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xuXHRcdC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXG5cblx0XHQvLyBAYWx0ZXJuYXRpdmVcblx0XHQvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xuXHRcdC8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cblxuXHRcdGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcblx0XHRcdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkoYSkgJiYgX3R5cGVvZihhWzBdKSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XG5cdFx0fVxuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gICAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gICAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAgICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICAgKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nvb3JkaW5hdGVfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gICAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICAgKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xuXG5cdFx0dmFyIENSUyA9IHtcblx0XHRcdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcblx0XHRcdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuIHpvb20uXG5cdFx0XHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiBsYXRMbmdUb1BvaW50KGxhdGxuZywgem9vbSkge1xuXHRcdFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxuXHRcdFx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xuXHRcdFx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXG5cdFx0XHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxuXHRcdFx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gcG9pbnRUb0xhdExuZyhwb2ludCwgem9vbSkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxuXHRcdFx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuXHRcdFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgaW4gdW5pdHMgYWNjZXB0ZWQgZm9yXG5cdFx0XHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cblx0XHRcdHByb2plY3Q6IGZ1bmN0aW9uIHByb2plY3QobGF0bG5nKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG5cdFx0XHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxuXHRcdFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxuXHRcdFx0dW5wcm9qZWN0OiBmdW5jdGlvbiB1bnByb2plY3QocG9pbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIHNjYWxlIHVzZWQgd2hlbiB0cmFuc2Zvcm1pbmcgcHJvamVjdGVkIGNvb3JkaW5hdGVzIGludG9cblx0XHRcdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcblx0XHRcdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXG5cdFx0XHRzY2FsZTogZnVuY3Rpb24gc2NhbGUoem9vbSkge1xuXHRcdFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHpvb20oc2NhbGU6IE51bWJlcik6IE51bWJlclxuXHRcdFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXG5cdFx0XHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cblx0XHRcdHpvb206IGZ1bmN0aW9uIHpvb20oc2NhbGUpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXG5cdFx0XHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uIGdldFByb2plY3RlZEJvdW5kcyh6b29tKSB7XG5cdFx0XHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXG5cdFx0XHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcblx0XHRcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcblx0XHRcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXG5cblx0XHRcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcblx0XHRcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxuXHRcdFx0Ly9cblx0XHRcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxuXHRcdFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXG5cdFx0XHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxuXHRcdFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXG5cdFx0XHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxuXG5cdFx0XHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxuXHRcdFx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcblxuXHRcdFx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXG5cdFx0XHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxuXHRcdFx0aW5maW5pdGU6IGZhbHNlLFxuXG5cdFx0XHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcblx0XHRcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcblx0XHRcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cblx0XHRcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIHdyYXBMYXRMbmcobGF0bG5nKSB7XG5cdFx0XHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyB3cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxuXHRcdFx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gd3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcblx0XHRcdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcblx0XHRcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcblx0XHRcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cblx0XHRcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cdFx0XHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiB3cmFwTGF0TG5nQm91bmRzKGJvdW5kcykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpLFxuXHRcdFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXG5cdFx0XHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxuXHRcdFx0XHQgICAgbG5nU2hpZnQgPSBjZW50ZXIubG5nIC0gbmV3Q2VudGVyLmxuZztcblxuXHRcdFx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcblx0XHRcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cblx0XHR2YXIgRWFydGggPSBleHRlbmQoe30sIENSUywge1xuXHRcdFx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0XHRcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdFx0XHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHRcdFx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRcdFx0UjogNjM3MTAwMCxcblxuXHRcdFx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRcdFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIGRpc3RhbmNlKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHRcdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0XHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0XHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG5cdFx0XHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0XHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0XHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gICAqXHJcbiAgICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICAgKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAgICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICAgKi9cblxuXHRcdHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcblxuXHRcdFx0UjogNjM3ODEzNyxcblx0XHRcdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcblxuXHRcdFx0cHJvamVjdDogZnVuY3Rpb24gcHJvamVjdChsYXRsbmcpIHtcblx0XHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXG5cdFx0XHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcblx0XHRcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5SICogbGF0bG5nLmxuZyAqIGQsIHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcblx0XHRcdH0sXG5cblx0XHRcdHVucHJvamVjdDogZnVuY3Rpb24gdW5wcm9qZWN0KHBvaW50KSB7XG5cdFx0XHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IExhdExuZygoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gMikgKiBkLCBwb2ludC54ICogZCAvIHRoaXMuUik7XG5cdFx0XHR9LFxuXG5cdFx0XHRib3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGQgPSA2Mzc4MTM3ICogTWF0aC5QSTtcblx0XHRcdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XG5cdFx0XHR9KClcblx0XHR9O1xuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICAgKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAgICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gICAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAgICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICAgKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gICAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHQvLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcblx0XHQvLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxuXHRcdGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdGlmIChpc0FycmF5KGEpKSB7XG5cdFx0XHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXG5cdFx0XHRcdHRoaXMuX2EgPSBhWzBdO1xuXHRcdFx0XHR0aGlzLl9iID0gYVsxXTtcblx0XHRcdFx0dGhpcy5fYyA9IGFbMl07XG5cdFx0XHRcdHRoaXMuX2QgPSBhWzNdO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hID0gYTtcblx0XHRcdHRoaXMuX2IgPSBiO1xuXHRcdFx0dGhpcy5fYyA9IGM7XG5cdFx0XHR0aGlzLl9kID0gZDtcblx0XHR9XG5cblx0XHRUcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cblx0XHRcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblx0XHRcdHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50LCBzY2FsZSkge1xuXHRcdFx0XHQvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3Rlcilcblx0XHRcdF90cmFuc2Zvcm06IGZ1bmN0aW9uIF90cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcblx0XHRcdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XG5cdFx0XHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxuXHRcdFx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cdFx0XHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gdW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludCgocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLCAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcblxuXHRcdC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxuXHRcdC8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXG5cblx0XHQvLyBAYWx0ZXJuYXRpdmVcblx0XHQvLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxuXHRcdC8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXG5cdFx0Ly8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cblxuXHRcdGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcblx0XHR9XG5cblx0XHQvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gICAqXHJcbiAgICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAgICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAgICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gICAqL1xuXG5cdFx0dmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xuXHRcdFx0Y29kZTogJ0VQU0c6Mzg1NycsXG5cdFx0XHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcblxuXHRcdFx0dHJhbnNmb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcblx0XHRcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xuXHRcdFx0fSgpXG5cdFx0fSk7XG5cblx0XHR2YXIgRVBTRzkwMDkxMyA9IGV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcblx0XHRcdGNvZGU6ICdFUFNHOjkwMDkxMydcblx0XHR9KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuXHRcdC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cblx0XHQvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcblx0XHQvLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcblx0XHQvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cblx0XHRmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcblx0XHQvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG5cdFx0Ly8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuXHRcdGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdFx0XHR2YXIgc3RyID0gJycsXG5cdFx0XHQgICAgaSxcblx0XHRcdCAgICBqLFxuXHRcdFx0ICAgIGxlbixcblx0XHRcdCAgICBsZW4yLFxuXHRcdFx0ICAgIHBvaW50cyxcblx0XHRcdCAgICBwO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRcdFx0c3RyICs9IGNsb3NlZCA/IHN2ZyA/ICd6JyA6ICd4JyA6ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRcdFx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG5cdFx0fVxuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICAgKiBAYWthIEwuQnJvd3NlclxyXG4gICAqXHJcbiAgICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICAgKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHR2YXIgc3R5bGUkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cblx0XHR2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xuXG5cdFx0Ly8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxuXHRcdHZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xuXG5cdFx0Ly8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXG5cdFx0dmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcblxuXHRcdC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XG5cdFx0Ly8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXG5cdFx0dmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXG5cdFx0Ly8gYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXG5cdFx0dmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xuXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXG5cdFx0dmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XG5cblx0XHQvKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXG5cdFx0dmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxuXHRcdC8vIEBwcm9wZXJ0eSBhbmRyb2lkU3RvY2s6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxuXHRcdHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xuXG5cdFx0Ly8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXG5cdFx0dmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XG5cblx0XHQvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cblx0XHR2YXIgY2hyb21lID0gdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xuXG5cdFx0Ly8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHR2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XG5cblx0XHQvLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cblx0XHR2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XG5cblx0XHR2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XG5cblx0XHQvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXG5cdFx0dmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlJDE7XG5cblx0XHQvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxuXHRcdHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XG5cblx0XHQvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cblx0XHR2YXIgaWUzZCA9IGllICYmICd0cmFuc2l0aW9uJyBpbiBzdHlsZSQxO1xuXG5cdFx0Ly8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxuXHRcdHZhciB3ZWJraXQzZCA9ICdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdyAmJiAnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpICYmICFhbmRyb2lkMjM7XG5cblx0XHQvLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxuXHRcdHZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZSQxO1xuXG5cdFx0Ly8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cblx0XHR2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxuXHRcdHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXG5cdFx0dmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XG5cblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXG5cdFx0dmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xuXG5cdFx0Ly8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxuXHRcdHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XG5cblx0XHQvLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cblx0XHR2YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcblxuXHRcdC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXG5cdFx0Ly8gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcblx0XHQvLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLlxuXHRcdHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG5cblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxuXHRcdHZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXG5cdFx0dmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xuXG5cdFx0Ly8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxuXHRcdC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXG5cdFx0dmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSA+IDE7XG5cblx0XHQvLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXG5cdFx0Ly8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cblx0XHR2YXIgY2FudmFzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcblx0XHR9KCk7XG5cblx0XHQvLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXG5cdFx0Ly8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cblx0XHR2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XG5cblx0XHQvLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXG5cdFx0Ly8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxuXHRcdHZhciB2bWwgPSAhc3ZnICYmIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XG5cblx0XHRcdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcblxuXHRcdFx0XHRyZXR1cm4gc2hhcGUgJiYgX3R5cGVvZihzaGFwZS5hZGopID09PSAnb2JqZWN0Jztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0oKTtcblxuXHRcdGZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xuXHRcdFx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcblx0XHR9XG5cblx0XHR2YXIgQnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRcdFx0aWU6IGllLFxuXHRcdFx0aWVsdDk6IGllbHQ5LFxuXHRcdFx0ZWRnZTogZWRnZSxcblx0XHRcdHdlYmtpdDogd2Via2l0LFxuXHRcdFx0YW5kcm9pZDogYW5kcm9pZCxcblx0XHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxuXHRcdFx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXG5cdFx0XHRvcGVyYTogb3BlcmEsXG5cdFx0XHRjaHJvbWU6IGNocm9tZSxcblx0XHRcdGdlY2tvOiBnZWNrbyxcblx0XHRcdHNhZmFyaTogc2FmYXJpLFxuXHRcdFx0cGhhbnRvbTogcGhhbnRvbSxcblx0XHRcdG9wZXJhMTI6IG9wZXJhMTIsXG5cdFx0XHR3aW46IHdpbixcblx0XHRcdGllM2Q6IGllM2QsXG5cdFx0XHR3ZWJraXQzZDogd2Via2l0M2QsXG5cdFx0XHRnZWNrbzNkOiBnZWNrbzNkLFxuXHRcdFx0YW55M2Q6IGFueTNkLFxuXHRcdFx0bW9iaWxlOiBtb2JpbGUsXG5cdFx0XHRtb2JpbGVXZWJraXQ6IG1vYmlsZVdlYmtpdCxcblx0XHRcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcblx0XHRcdG1zUG9pbnRlcjogbXNQb2ludGVyLFxuXHRcdFx0cG9pbnRlcjogcG9pbnRlcixcblx0XHRcdHRvdWNoOiB0b3VjaCxcblx0XHRcdG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcblx0XHRcdG1vYmlsZUdlY2tvOiBtb2JpbGVHZWNrbyxcblx0XHRcdHJldGluYTogcmV0aW5hLFxuXHRcdFx0Y2FudmFzOiBjYW52YXMsXG5cdFx0XHRzdmc6IHN2Zyxcblx0XHRcdHZtbDogdm1sXG5cdFx0fSk7XG5cblx0XHQvKlxuICAgKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICAgKi9cblxuXHRcdHZhciBQT0lOVEVSX0RPV04gPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiAncG9pbnRlcmRvd24nO1xuXHRcdHZhciBQT0lOVEVSX01PVkUgPSBtc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgOiAncG9pbnRlcm1vdmUnO1xuXHRcdHZhciBQT0lOVEVSX1VQID0gbXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6ICdwb2ludGVydXAnO1xuXHRcdHZhciBQT0lOVEVSX0NBTkNFTCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xuXHRcdHZhciBUQUdfV0hJVEVfTElTVCA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ09QVElPTiddO1xuXG5cdFx0dmFyIF9wb2ludGVycyA9IHt9O1xuXHRcdHZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cblx0XHQvLyBEb21FdmVudC5Eb3VibGVUYXAgbmVlZHMgdG8ga25vdyBhYm91dCB0aGlzXG5cdFx0dmFyIF9wb2ludGVyc0NvdW50ID0gMDtcblxuXHRcdC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cblx0XHQvLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5cdFx0ZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0XHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRcdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdFx0dmFyIG9uRG93biA9IGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5NU1BPSU5URVJfVFlQRV9NT1VTRSAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG5cdFx0XHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdFx0XHQvLyBuZWVkIHRoZXNlIGV2ZW50cy4gRm9yIG90aGVyIHRhcmdldCB0YWdzLCB3ZSBwcmV2ZW50IGRlZmF1bHQgb24gdGhlIGV2ZW50LlxuXHRcdFx0XHRcdGlmIChUQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHRcdFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdFx0XHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHRcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRcdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0XHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdFx0X3BvaW50ZXJzQ291bnQrKztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRcdFx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRcdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdFx0XHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0XHRcdF9wb2ludGVyc0NvdW50LS07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRcdFx0ZS50b3VjaGVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdFx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRcdFx0aGFuZGxlcihlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdFx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIG9uTW92ZShlKSB7XG5cdFx0XHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHRcdH07XG5cblx0XHRcdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdFx0dmFyIG9uVXAgPSBmdW5jdGlvbiBvblVwKGUpIHtcblx0XHRcdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0XHR9O1xuXG5cdFx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdC8qXHJcbiAgICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gICAqL1xuXG5cdFx0dmFyIF90b3VjaHN0YXJ0ID0gbXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogcG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XG5cdFx0dmFyIF90b3VjaGVuZCA9IG1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBwb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xuXHRcdHZhciBfcHJlID0gJ19sZWFmbGV0Xyc7XG5cblx0XHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xuXHRcdGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHRcdHZhciBsYXN0LFxuXHRcdFx0ICAgIHRvdWNoJCQxLFxuXHRcdFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxuXHRcdFx0ICAgIGRlbGF5ID0gMjUwO1xuXG5cdFx0XHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuXHRcdFx0XHR2YXIgY291bnQ7XG5cblx0XHRcdFx0aWYgKHBvaW50ZXIpIHtcblx0XHRcdFx0XHRpZiAoIWVkZ2UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3VudCA9IF9wb2ludGVyc0NvdW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvdW50ID0gZS50b3VjaGVzLmxlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb3VudCA+IDEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcblx0XHRcdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcblxuXHRcdFx0XHR0b3VjaCQkMSA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cdFx0XHRcdGRvdWJsZVRhcCA9IGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheTtcblx0XHRcdFx0bGFzdCA9IG5vdztcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG5cdFx0XHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoJCQxLmNhbmNlbEJ1YmJsZSkge1xuXHRcdFx0XHRcdGlmIChwb2ludGVyKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWVkZ2UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXG5cdFx0XHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcblx0XHRcdFx0XHRcdCAgICBwcm9wLFxuXHRcdFx0XHRcdFx0ICAgIGk7XG5cblx0XHRcdFx0XHRcdGZvciAoaSBpbiB0b3VjaCQkMSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wID0gdG91Y2gkJDFbaV07XG5cdFx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gkJDEpIDogcHJvcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRvdWNoJCQxID0gbmV3VG91Y2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRvdWNoJCQxLnR5cGUgPSAnZGJsY2xpY2snO1xuXHRcdFx0XHRcdGhhbmRsZXIodG91Y2gkJDEpO1xuXHRcdFx0XHRcdGxhc3QgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XG5cdFx0XHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XG5cdFx0XHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xuXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcblxuXHRcdFx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxuXHRcdFx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxuXHRcdFx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxuXHRcdFx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XG5cdFx0XHR2YXIgdG91Y2hzdGFydCA9IG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0sXG5cdFx0XHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcblx0XHRcdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcblxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIGZhbHNlKTtcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcblx0XHRcdGlmICghZWRnZSkge1xuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBkYmxjbGljaywgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gICAqXHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gICAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqXHJcbiAgICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gICAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICAgKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAgICovXG5cblx0XHQvLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcblx0XHQvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cblx0XHR2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xuXG5cdFx0Ly8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xuXHRcdC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuXG5cdFx0Ly8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xuXHRcdC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXG5cdFx0dmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcblxuXHRcdC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXG5cdFx0Ly8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cblx0XHR2YXIgVFJBTlNJVElPTl9FTkQgPSBUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcblxuXHRcdC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XG5cdFx0Ly8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXG5cdFx0Ly8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cblx0XHRmdW5jdGlvbiBnZXQoaWQpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xuXHRcdC8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG5cdFx0Ly8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxuXHRcdGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdO1xuXG5cdFx0XHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xuXHRcdFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG5cdFx0XHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XG5cdFx0Ly8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlJDEodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cdFx0XHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG5cblx0XHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbDtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcblx0XHQvLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcblx0XHRmdW5jdGlvbiBfcmVtb3ZlKGVsKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxuXHRcdC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcblx0XHRmdW5jdGlvbiBlbXB0eShlbCkge1xuXHRcdFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxuXHRcdC8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXG5cdFx0ZnVuY3Rpb24gdG9Gcm9udChlbCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAocGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcblx0XHQvLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXG5cdFx0ZnVuY3Rpb24gdG9CYWNrKGVsKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdGlmIChwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcblx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cblx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXG5cdFx0ZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcblx0XHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcblx0XHRcdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxuXHRcdC8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxuXHRcdGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG5cdFx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xuXHRcdFx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcblx0XHQvLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxuXHRcdGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG5cdFx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldENsYXNzKGVsLCB0cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcblx0XHQvLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXG5cdFx0ZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcblx0XHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XG5cdFx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXG5cdFx0Ly8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxuXHRcdGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XG5cdFx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxuXHRcdC8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxuXHRcdC8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cblx0XHRmdW5jdGlvbiBfc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcblx0XHRcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcblx0XHRcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xuXHRcdFx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcblx0XHRcdHZhciBmaWx0ZXIgPSBmYWxzZSxcblx0XHRcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcblxuXHRcdFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxuXHRcdFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxuXHRcdFx0XHRpZiAodmFsdWUgPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcblxuXHRcdFx0aWYgKGZpbHRlcikge1xuXHRcdFx0XHRmaWx0ZXIuRW5hYmxlZCA9IHZhbHVlICE9PSAxMDA7XG5cdFx0XHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2Vcblx0XHQvLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXG5cdFx0Ly8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcblx0XHQvLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cblx0XHRmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9wc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcblx0XHQvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xuXHRcdC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcblx0XHQvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cblx0XHRmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcblx0XHRcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xuXG5cdFx0XHRlbC5zdHlsZVtUUkFOU0ZPUk1dID0gKGllM2QgPyAndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6ICd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgKyAoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXG5cdFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcblx0XHQvLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxuXHRcdC8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cblx0XHRmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcblxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xuXHRcdFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0XHRcdGlmIChhbnkzZCkge1xuXHRcdFx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4Jztcblx0XHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XG5cdFx0Ly8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cblx0XHRmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXG5cdFx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxuXG5cdFx0XHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxuXHRcdC8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXG5cdFx0Ly8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcblx0XHQvLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXG5cdFx0Ly8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXG5cblx0XHQvLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXG5cdFx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxuXHRcdHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcblx0XHR2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcblx0XHR2YXIgX3VzZXJTZWxlY3Q7XG5cdFx0aWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xuXHRcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpIHtcblx0XHRcdFx0b24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cdFx0XHR9O1xuXHRcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG5cdFx0XHRcdG9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcblxuXHRcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpIHtcblx0XHRcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblx0XHRcdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XG5cdFx0XHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKCkge1xuXHRcdFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcblx0XHRcdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXG5cdFx0Ly8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxuXHRcdC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxuXHRcdGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XG5cdFx0XHRvbih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXG5cdFx0Ly8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xuXHRcdFx0b2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcblx0XHR9XG5cblx0XHR2YXIgX291dGxpbmVFbGVtZW50O1xuXHRcdHZhciBfb3V0bGluZVN0eWxlO1xuXHRcdC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXG5cdFx0Ly8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcblx0XHQvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxuXHRcdC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcblx0XHQvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXG5cdFx0ZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xuXHRcdFx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWVsZW1lbnQuc3R5bGUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmVzdG9yZU91dGxpbmUoKTtcblx0XHRcdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuXHRcdFx0b24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcblx0XHR9XG5cblx0XHQvLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxuXHRcdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXG5cdFx0ZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XG5cdFx0XHRpZiAoIV9vdXRsaW5lRWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XG5cdFx0XHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cdFx0XHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xuXHRcdFx0b2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxuXHRcdC8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxuXHRcdGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcblx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3Rcblx0XHQvLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxuXHRcdC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxuXHRcdC8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxuXHRcdGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcblx0XHRcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcblx0XHRcdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxuXHRcdFx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3Rcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIERvbVV0aWwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0XHRcdFRSQU5TRk9STTogVFJBTlNGT1JNLFxuXHRcdFx0VFJBTlNJVElPTjogVFJBTlNJVElPTixcblx0XHRcdFRSQU5TSVRJT05fRU5EOiBUUkFOU0lUSU9OX0VORCxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0Z2V0U3R5bGU6IGdldFN0eWxlLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUkMSxcblx0XHRcdHJlbW92ZTogX3JlbW92ZSxcblx0XHRcdGVtcHR5OiBlbXB0eSxcblx0XHRcdHRvRnJvbnQ6IHRvRnJvbnQsXG5cdFx0XHR0b0JhY2s6IHRvQmFjayxcblx0XHRcdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0XHRcdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0XHRcdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcblx0XHRcdHNldENsYXNzOiBzZXRDbGFzcyxcblx0XHRcdGdldENsYXNzOiBnZXRDbGFzcyxcblx0XHRcdHNldE9wYWNpdHk6IF9zZXRPcGFjaXR5LFxuXHRcdFx0dGVzdFByb3A6IHRlc3RQcm9wLFxuXHRcdFx0c2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG5cdFx0XHRzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG5cdFx0XHRnZXRQb3NpdGlvbjogZ2V0UG9zaXRpb24sXG5cdFx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbjogZGlzYWJsZVRleHRTZWxlY3Rpb24sXG5cdFx0XHRlbmFibGVUZXh0U2VsZWN0aW9uOiBlbmFibGVUZXh0U2VsZWN0aW9uLFxuXHRcdFx0ZGlzYWJsZUltYWdlRHJhZzogZGlzYWJsZUltYWdlRHJhZyxcblx0XHRcdGVuYWJsZUltYWdlRHJhZzogZW5hYmxlSW1hZ2VEcmFnLFxuXHRcdFx0cHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuXHRcdFx0cmVzdG9yZU91dGxpbmU6IHJlc3RvcmVPdXRsaW5lLFxuXHRcdFx0Z2V0U2l6ZWRQYXJlbnROb2RlOiBnZXRTaXplZFBhcmVudE5vZGUsXG5cdFx0XHRnZXRTY2FsZTogZ2V0U2NhbGVcblx0XHR9KTtcblxuXHRcdC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xuXG5cdFx0Ly8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxuXG5cdFx0Ly8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHRcdC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxuXHRcdC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXG5cdFx0Ly8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcblx0XHQvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cblxuXHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdFx0Ly8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxuXHRcdGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XG5cblx0XHRcdGlmICgodHlwZW9mIHR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0eXBlcykpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XG5cdFx0XHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcblxuXHRcdC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdFx0Ly8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdFx0Ly8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxuXHRcdC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cblxuXHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHRcdC8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcblx0XHRmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcblxuXHRcdFx0aWYgKCh0eXBlb2YgdHlwZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGVzKSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcblx0XHRcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVzKSB7XG5cdFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xuXHRcdFx0XHRcdHJlbW92ZU9uZShvYmosIGosIG9ialtldmVudHNLZXldW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcblxuXHRcdFx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xuXG5cdFx0XHRpZiAocG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcblx0XHRcdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xuXHRcdFx0XHRhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRvdWNoICYmIHR5cGUgPT09ICdkYmxjbGljaycgJiYgYWRkRG91YmxlVGFwTGlzdGVuZXIgJiYgIShwb2ludGVyICYmIGNocm9tZSkpIHtcblx0XHRcdFx0Ly8gQ2hyb21lID41NSBkb2VzIG5vdCBuZWVkIHRoZSBzeW50aGV0aWMgZGJsY2xpY2tzIGZyb20gYWRkRG91YmxlVGFwTGlzdGVuZXJcblx0XHRcdFx0Ly8gU2VlICM1MTgwXG5cdFx0XHRcdGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XG5cblx0XHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xuXHRcdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuXHRcdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcblx0XHRcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblx0XHRcdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycgJiYgYW5kcm9pZCkge1xuXHRcdFx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuXHRcdFx0XHRcdFx0XHRmaWx0ZXJDbGljayhlLCBvcmlnaW5hbEhhbmRsZXIpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gb2JqKSB7XG5cdFx0XHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG5cdFx0XHR9XG5cblx0XHRcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XG5cdFx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XG5cblx0XHRcdHZhciBpZCA9IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpLFxuXHRcdFx0ICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XG5cblx0XHRcdGlmICghaGFuZGxlcikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XG5cdFx0XHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcblx0XHRcdH0gZWxzZSBpZiAodG91Y2ggJiYgdHlwZSA9PT0gJ2RibGNsaWNrJyAmJiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lciAmJiAhKHBvaW50ZXIgJiYgY2hyb21lKSkge1xuXHRcdFx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xuXG5cdFx0XHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcblx0XHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogdHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xuXHRcdFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xuXHRcdC8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxuXHRcdC8vIGBgYGpzXG5cdFx0Ly8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xuXHRcdC8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xuXHRcdC8vIH0pO1xuXHRcdC8vIGBgYFxuXHRcdGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XG5cblx0XHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdFx0Ly8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxuXHRcdFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0c2tpcHBlZChlKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXG5cdFx0Ly8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cblx0XHRmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcblx0XHRcdGFkZE9uZShlbCwgJ21vdXNld2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcblx0XHQvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXG5cdFx0Ly8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxuXHRcdGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XG5cdFx0XHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcblx0XHRcdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcblx0XHQvLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXG5cdFx0Ly8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxuXHRcdC8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXG5cdFx0Ly8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG5cdFx0ZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuXHRcdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xuXHRcdC8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cblx0XHRmdW5jdGlvbiBzdG9wKGUpIHtcblx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0c3RvcFByb3BhZ2F0aW9uKGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XG5cdFx0Ly8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXG5cdFx0Ly8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cblx0XHRmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xuXHRcdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXG5cdFx0XHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxuXG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxuXHRcdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXG5cdFx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LCAoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcblx0XHQvLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXG5cdFx0dmFyIHdoZWVsUHhGYWN0b3IgPSB3aW4gJiYgY2hyb21lID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG5cblx0XHQvLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcblx0XHQvLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxuXHRcdC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxuXHRcdC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXG5cdFx0Ly8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cblx0XHRmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcblx0XHRcdHJldHVybiBlZGdlID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcblx0XHRcdGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xuXHRcdFx0ZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXG5cdFx0XHRlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMiA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcblx0XHRcdGUuZGVsdGFYIHx8IGUuZGVsdGFaID8gMCA6IC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcblx0XHRcdGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xuXHRcdFx0ZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcblx0XHRcdGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcblx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBFdmVudHMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZha2VTdG9wKGUpIHtcblx0XHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxuXHRcdFx0c2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBza2lwcGVkKGUpIHtcblx0XHRcdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XG5cdFx0XHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxuXHRcdFx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gZXZlbnRzO1xuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxuXHRcdGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcblxuXHRcdFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG5cblx0XHRcdGlmICghcmVsYXRlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgcmVsYXRlZCAhPT0gZWwpIHtcblx0XHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGF0ZWQgIT09IGVsO1xuXHRcdH1cblxuXHRcdHZhciBsYXN0Q2xpY2s7XG5cblx0XHQvLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXG5cdFx0ZnVuY3Rpb24gZmlsdGVyQ2xpY2soZSwgaGFuZGxlcikge1xuXHRcdFx0dmFyIHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wLFxuXHRcdFx0ICAgIGVsYXBzZWQgPSBsYXN0Q2xpY2sgJiYgdGltZVN0YW1wIC0gbGFzdENsaWNrO1xuXG5cdFx0XHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xuXHRcdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXG5cdFx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XG5cdFx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xuXG5cdFx0XHRpZiAoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDAgfHwgZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpIHtcblx0XHRcdFx0c3RvcChlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bGFzdENsaWNrID0gdGltZVN0YW1wO1xuXG5cdFx0XHRoYW5kbGVyKGUpO1xuXHRcdH1cblxuXHRcdHZhciBEb21FdmVudCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRcdFx0b246IG9uLFxuXHRcdFx0b2ZmOiBvZmYsXG5cdFx0XHRzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcblx0XHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uLFxuXHRcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uLFxuXHRcdFx0cHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuXHRcdFx0c3RvcDogc3RvcCxcblx0XHRcdGdldE1vdXNlUG9zaXRpb246IGdldE1vdXNlUG9zaXRpb24sXG5cdFx0XHRnZXRXaGVlbERlbHRhOiBnZXRXaGVlbERlbHRhLFxuXHRcdFx0ZmFrZVN0b3A6IGZha2VTdG9wLFxuXHRcdFx0c2tpcHBlZDogc2tpcHBlZCxcblx0XHRcdGlzRXh0ZXJuYWxUYXJnZXQ6IGlzRXh0ZXJuYWxUYXJnZXQsXG5cdFx0XHRhZGRMaXN0ZW5lcjogb24sXG5cdFx0XHRyZW1vdmVMaXN0ZW5lcjogb2ZmXG5cdFx0fSk7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gICAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAgICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAgICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAgICpcbiAgICovXG5cblx0XHR2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdFx0XHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHRcdFx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHRcdFx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdFx0XHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0XHRcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRcdFx0cnVuOiBmdW5jdGlvbiBydW4oZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHRcdFx0dGhpcy5zdG9wKCk7XG5cblx0XHRcdFx0dGhpcy5fZWwgPSBlbDtcblx0XHRcdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHRcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24oZWwpO1xuXHRcdFx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdFx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHRcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc3RvcCgpXG5cdFx0XHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FuaW1hdGU6IGZ1bmN0aW9uIF9hbmltYXRlKCkge1xuXHRcdFx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdFx0XHR0aGlzLl9hbmltSWQgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9zdGVwKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfc3RlcDogZnVuY3Rpb24gX3N0ZXAocm91bmQpIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQgPSArbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0XHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcnVuRnJhbWU6IGZ1bmN0aW9uIF9ydW5GcmFtZShwcm9ncmVzcywgcm91bmQpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdFx0XHRpZiAocm91bmQpIHtcblx0XHRcdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHRcdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY29tcGxldGU6IGZ1bmN0aW9uIF9jb21wbGV0ZSgpIHtcblx0XHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHRcdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHRcdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0XHRcdH0sXG5cblx0XHRcdF9lYXNlT3V0OiBmdW5jdGlvbiBfZWFzZU91dCh0KSB7XG5cdFx0XHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXG5cblx0XHR2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXG5cdFx0XHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xuXHRcdFx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XG5cdFx0XHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cblx0XHRcdFx0Y3JzOiBFUFNHMzg1NyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXG5cdFx0XHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxuXHRcdFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdFx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXG5cdFx0XHRcdHpvb206IHVuZGVmaW5lZCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcblx0XHRcdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXG5cdFx0XHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxuXHRcdFx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdFx0XHRtaW5ab29tOiB1bmRlZmluZWQsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXG5cdFx0XHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxuXHRcdFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcblx0XHRcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG5cdFx0XHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXG5cdFx0XHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcblx0XHRcdFx0bGF5ZXJzOiBbXSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxuXHRcdFx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXG5cdFx0XHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXG5cdFx0XHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxuXHRcdFx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXG5cdFx0XHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxuXHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXG5cdFx0XHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxuXHRcdFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxuXG5cdFx0XHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXG5cdFx0XHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXG5cdFx0XHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cblx0XHRcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcblx0XHRcdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxuXHRcdFx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxuXHRcdFx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXG5cdFx0XHRcdGZhZGVBbmltYXRpb246IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxuXHRcdFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xuXHRcdFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cblx0XHRcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcblx0XHRcdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcblx0XHRcdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cblx0XHRcdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cblx0XHRcdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XG5cblx0XHRcdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXHRcdFx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXG5cdFx0XHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcblx0XHRcdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cblx0XHRcdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXG5cdFx0XHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcblx0XHRcdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXG5cdFx0XHRcdHpvb21TbmFwOiAxLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXG5cdFx0XHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcblx0XHRcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2Bcblx0XHRcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cblx0XHRcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxuXHRcdFx0XHR6b29tRGVsdGE6IDEsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cblx0XHRcdFx0dHJhY2tSZXNpemU6IHRydWVcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoaWQsIG9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxuXHRcdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcblx0XHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xuXG5cdFx0XHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcblx0XHRcdFx0dGhpcy5fb25SZXNpemUgPSBiaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcblxuXHRcdFx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7IHJlc2V0OiB0cnVlIH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0dGhpcy5fbGF5ZXJzID0ge307XG5cdFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xuXHRcdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XG5cblx0XHRcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXG5cdFx0XHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgYW55M2QgJiYgIW1vYmlsZU9wZXJhICYmIHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xuXG5cdFx0XHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdFx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xuXHRcdFx0XHRcdG9uKHRoaXMuX3Byb3h5LCBUUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxuXHRcdFx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXG5cdFx0XHRzZXRWaWV3OiBmdW5jdGlvbiBzZXRWaWV3KGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0XHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdFx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdFx0dGhpcy5fc3RvcCgpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoeyBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUgfSwgb3B0aW9ucy56b29tKTtcblx0XHRcdFx0XHRcdG9wdGlvbnMucGFuID0gZXh0ZW5kKHsgYW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiB9LCBvcHRpb25zLnBhbik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0XHRcdHZhciBtb3ZlZCA9IHRoaXMuX3pvb20gIT09IHpvb20gPyB0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6IHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xuXG5cdFx0XHRcdFx0aWYgKG1vdmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0XHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXG5cdFx0XHRzZXRab29tOiBmdW5jdGlvbiBzZXRab29tKHpvb20sIG9wdGlvbnMpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcblx0XHRcdFx0XHR0aGlzLl96b29tID0gem9vbTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHsgem9vbTogb3B0aW9ucyB9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXG5cdFx0XHR6b29tSW46IGZ1bmN0aW9uIHpvb21JbihkZWx0YSwgb3B0aW9ucykge1xuXHRcdFx0XHRkZWx0YSA9IGRlbHRhIHx8IChhbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXG5cdFx0XHR6b29tT3V0OiBmdW5jdGlvbiB6b29tT3V0KGRlbHRhLCBvcHRpb25zKSB7XG5cdFx0XHRcdGRlbHRhID0gZGVsdGEgfHwgKGFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXG5cdFx0XHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cblx0XHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXG5cdFx0XHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiBzZXRab29tQXJvdW5kKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHRcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0XHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXG5cdFx0XHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcblx0XHRcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHsgem9vbTogb3B0aW9ucyB9KTtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiBfZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpIHtcblxuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cblx0XHRcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcblx0XHRcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXG5cdFx0XHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XG5cblx0XHRcdFx0em9vbSA9IHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XG5cblx0XHRcdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxuXHRcdFx0XHRcdFx0em9vbTogem9vbVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxuXHRcdFx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxuXHRcdFx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxuXHRcdFx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHpvb206IHpvb21cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxuXHRcdFx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxuXHRcdFx0Zml0Qm91bmRzOiBmdW5jdGlvbiBmaXRCb3VuZHMoYm91bmRzLCBvcHRpb25zKSB7XG5cblx0XHRcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcblxuXHRcdFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxuXHRcdFx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cblx0XHRcdGZpdFdvcmxkOiBmdW5jdGlvbiBmaXRXb3JsZChvcHRpb25zKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxuXHRcdFx0cGFuVG86IGZ1bmN0aW9uIHBhblRvKGNlbnRlciwgb3B0aW9ucykge1xuXHRcdFx0XHQvLyAoTGF0TG5nKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwgeyBwYW46IG9wdGlvbnMgfSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cblx0XHRcdHBhbkJ5OiBmdW5jdGlvbiBwYW5CeShvZmZzZXQsIG9wdGlvbnMpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xuXHRcdFx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxuXHRcdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xuXHRcdFx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XG5cblx0XHRcdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcblx0XHRcdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcblx0XHRcdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcblx0XHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXG5cdFx0XHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXG5cdFx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblxuXHRcdFx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdFx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XG5cdFx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxuXHRcdFx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxuXHRcdFx0Zmx5VG86IGZ1bmN0aW9uIGZseVRvKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xuXG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhYW55M2QpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHRcdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXG5cdFx0XHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxuXHRcdFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxuXHRcdFx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcblxuXHRcdFx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xuXHRcdFx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcblxuXHRcdFx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXG5cdFx0XHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcblx0XHRcdFx0ICAgIHUxID0gdG8uZGlzdGFuY2VUbyhmcm9tKSB8fCAxLFxuXHRcdFx0XHQgICAgcmhvID0gMS40Mixcblx0XHRcdFx0ICAgIHJobzIgPSByaG8gKiByaG87XG5cblx0XHRcdFx0ZnVuY3Rpb24gcihpKSB7XG5cdFx0XHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcblx0XHRcdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcblx0XHRcdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxuXHRcdFx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcblx0XHRcdFx0XHQgICAgYiA9IHQxIC8gYjEsXG5cdFx0XHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xuXG5cdFx0XHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxuXHRcdFx0XHRcdC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXG5cdFx0XHRcdFx0dmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbG9nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gc2luaChuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNvc2gobikge1xuXHRcdFx0XHRcdHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiB0YW5oKG4pIHtcblx0XHRcdFx0XHRyZXR1cm4gc2luaChuKSAvIGNvc2gobik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcjAgPSByKDApO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHcocykge1xuXHRcdFx0XHRcdHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gdShzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxuXHRcdFx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxuXHRcdFx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcblxuXHRcdFx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcblx0XHRcdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXG5cdFx0XHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcblxuXHRcdFx0XHRcdGlmICh0IDw9IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fbW92ZSh0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLCB0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksIHsgZmx5VG86IHRydWUgfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKS5fbW92ZUVuZCh0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XG5cblx0XHRcdFx0ZnJhbWUuY2FsbCh0aGlzKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXG5cdFx0XHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXG5cdFx0XHRmbHlUb0JvdW5kczogZnVuY3Rpb24gZmx5VG9Cb3VuZHMoYm91bmRzLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xuXHRcdFx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxuXHRcdFx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiBzZXRNYXhCb3VuZHMoYm91bmRzKSB7XG5cdFx0XHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cblx0XHRcdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcblxuXHRcdFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cblx0XHRcdHNldE1pblpvb206IGZ1bmN0aW9uIHNldE1pblpvb20oem9vbSkge1xuXHRcdFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XG5cblx0XHRcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XG5cdFx0XHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxuXHRcdFx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gc2V0TWF4Wm9vbSh6b29tKSB7XG5cdFx0XHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcblxuXHRcdFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxuXHRcdFx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiBwYW5JbnNpZGVCb3VuZHMoYm91bmRzLCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuXHRcdFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcblxuXHRcdFx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xuXHRcdFx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcblx0XHRcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xuXHRcdFx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cblx0XHRcdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xuXHRcdFx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcblx0XHRcdC8vIHRpbWVzIGluIGEgcm93LlxuXG5cdFx0XHQvLyBAYWx0ZXJuYXRpdmVcblx0XHRcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcblx0XHRcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcblx0XHRcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xuXHRcdFx0Ly8gcGFuIGJ5IGRlZmF1bHQuXG5cdFx0XHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gaW52YWxpZGF0ZVNpemUob3B0aW9ucykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3B0aW9ucyA9IGV4dGVuZCh7XG5cdFx0XHRcdFx0YW5pbWF0ZTogZmFsc2UsXG5cdFx0XHRcdFx0cGFuOiB0cnVlXG5cdFx0XHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7IGFuaW1hdGU6IHRydWUgfSA6IG9wdGlvbnMpO1xuXG5cdFx0XHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XG5cdFx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XG5cblx0XHRcdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcblx0XHRcdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcblx0XHRcdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcblx0XHRcdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xuXG5cdFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XG5cdFx0XHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLnBhbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcblxuXHRcdFx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdFx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cblx0XHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xuXHRcdFx0XHRcdG9sZFNpemU6IG9sZFNpemUsXG5cdFx0XHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcblx0XHRcdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXG5cdFx0XHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxuXHRcdFx0c3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0XHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XG5cdFx0XHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xuXHRcdFx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcblx0XHRcdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxuXHRcdFx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cblx0XHRcdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cblx0XHRcdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cblx0XHRcdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcblx0XHRcdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXG5cdFx0XHRsb2NhdGU6IGZ1bmN0aW9uIGxvY2F0ZShvcHRpb25zKSB7XG5cblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBleHRlbmQoe1xuXHRcdFx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxuXHRcdFx0XHRcdHdhdGNoOiBmYWxzZVxuXHRcdFx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXG5cdFx0XHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cblx0XHRcdFx0XHQvLyBtYXhpbXVtQWdlOiAwXG5cdFx0XHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxuXHRcdFx0XHR9LCBvcHRpb25zKTtcblxuXHRcdFx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcblx0XHRcdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IDAsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb25SZXNwb25zZSA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXG5cdFx0XHRcdCAgICBvbkVycm9yID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcblxuXHRcdFx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xuXHRcdFx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xuXHRcdFx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXG5cdFx0XHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcblx0XHRcdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxuXHRcdFx0c3RvcExvY2F0ZTogZnVuY3Rpb24gc3RvcExvY2F0ZSgpIHtcblx0XHRcdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xuXHRcdFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiBfaGFuZGxlR2VvbG9jYXRpb25FcnJvcihlcnJvcikge1xuXHRcdFx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXG5cdFx0XHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOiBjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0Jyk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5maXRXb3JsZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXG5cdFx0XHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xuXHRcdFx0XHRcdGNvZGU6IGMsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiBfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZShwb3MpIHtcblx0XHRcdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXG5cdFx0XHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcblx0XHRcdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxuXHRcdFx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcblx0XHRcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcblx0XHRcdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xuXHRcdFx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdGxhdGxuZzogbGF0bG5nLFxuXHRcdFx0XHRcdGJvdW5kczogYm91bmRzLFxuXHRcdFx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXG5cdFx0XHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xuXHRcdFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xuXHRcdFx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcblx0XHRcdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0XHRcdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIGFkZEhhbmRsZXIobmFtZSwgSGFuZGxlckNsYXNzKSB7XG5cdFx0XHRcdGlmICghSGFuZGxlckNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xuXHRcdFx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcblx0XHRcdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblxuXHRcdFx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xuXHRcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXG5cdFx0XHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3N0b3AoKTtcblxuXHRcdFx0XHRfcmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcblx0XHRcdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xuXHRcdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcblx0XHRcdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHRcdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxuXHRcdFx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcblx0XHRcdFx0XHRfcmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xheWVycyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9wYW5lcyA9IFtdO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xuXHRcdFx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXG5cdFx0XHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3Jcblx0XHRcdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cblx0XHRcdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIGNyZWF0ZVBhbmUobmFtZSwgY29udGFpbmVyKSB7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxuXHRcdFx0XHQgICAgcGFuZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcblxuXHRcdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFuZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHRcdFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcblx0XHRcdGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xuXHRcdFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcblx0XHRcdGdldFpvb206IGZ1bmN0aW9uIGdldFpvb20oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl96b29tO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcblx0XHRcdGdldEJvdW5kczogZnVuY3Rpb24gZ2V0Qm91bmRzKCkge1xuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdFx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcblx0XHRcdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxuXHRcdFx0Z2V0TWluWm9vbTogZnVuY3Rpb24gZ2V0TWluWm9vbSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cblx0XHRcdGdldE1heFpvb206IGZ1bmN0aW9uIGdldE1heFpvb20oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tIDogdGhpcy5vcHRpb25zLm1heFpvb207XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcblx0XHRcdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2Rcblx0XHRcdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cblx0XHRcdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxuXHRcdFx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gZ2V0Qm91bmRzWm9vbShib3VuZHMsIGluc2lkZSwgcGFkZGluZykge1xuXHRcdFx0XHQvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcblx0XHRcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHRcdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xuXG5cdFx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcblx0XHRcdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxuXHRcdFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXG5cdFx0XHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxuXHRcdFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxuXHRcdFx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcblx0XHRcdFx0ICAgIHNuYXAgPSBhbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXG5cdFx0XHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXG5cdFx0XHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXG5cdFx0XHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcblxuXHRcdFx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xuXG5cdFx0XHRcdGlmIChzbmFwKSB7XG5cdFx0XHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxuXHRcdFx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXG5cdFx0XHRnZXRTaXplOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLCB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xuXG5cdFx0XHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcblx0XHRcdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcblx0XHRcdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXG5cdFx0XHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gZ2V0UGl4ZWxCb3VuZHMoY2VudGVyLCB6b29tKSB7XG5cdFx0XHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cblx0XHRcdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcblx0XHRcdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxuXHRcdFx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxuXHRcdFx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIGdldFBpeGVsT3JpZ2luKCkge1xuXHRcdFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXG5cdFx0XHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxuXHRcdFx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcblx0XHRcdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXG5cdFx0XHRnZXRQYW5lOiBmdW5jdGlvbiBnZXRQYW5lKHBhbmUpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XG5cdFx0XHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcblx0XHRcdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXG5cdFx0XHRnZXRQYW5lczogZnVuY3Rpb24gZ2V0UGFuZXMoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYW5lcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cblx0XHRcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxuXHRcdFx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXG5cdFx0XHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uIGdldFpvb21TY2FsZSh0b1pvb20sIGZyb21ab29tKSB7XG5cdFx0XHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xuXHRcdFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcblx0XHRcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xuXHRcdFx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXG5cdFx0XHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxuXHRcdFx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXG5cdFx0XHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIGdldFNjYWxlWm9vbShzY2FsZSwgZnJvbVpvb20pIHtcblx0XHRcdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XG5cdFx0XHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcblx0XHRcdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xuXHRcdFx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XG5cdFx0XHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxuXHRcdFx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXG5cdFx0XHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cblx0XHRcdC8vIHRoZSBDUlMgb3JpZ2luLlxuXHRcdFx0cHJvamVjdDogZnVuY3Rpb24gcHJvamVjdChsYXRsbmcsIHpvb20pIHtcblx0XHRcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcblx0XHRcdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cblx0XHRcdHVucHJvamVjdDogZnVuY3Rpb24gdW5wcm9qZWN0KHBvaW50LCB6b29tKSB7XG5cdFx0XHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcblx0XHRcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXG5cdFx0XHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXG5cdFx0XHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludCkge1xuXHRcdFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcblx0XHRcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxuXHRcdFx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxuXHRcdFx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKSB7XG5cdFx0XHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcblx0XHRcdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXG5cdFx0XHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxuXHRcdFx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcblx0XHRcdC8vIENSUydzIGJvdW5kcy5cblx0XHRcdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xuXHRcdFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXG5cdFx0XHR3cmFwTGF0TG5nOiBmdW5jdGlvbiB3cmFwTGF0TG5nKGxhdGxuZykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcblx0XHRcdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXG5cdFx0XHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xuXHRcdFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xuXHRcdFx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cblx0XHRcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIHdyYXBMYXRMbmdCb3VuZHMobGF0bG5nKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXG5cdFx0XHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxuXHRcdFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIGRpc3RhbmNlKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xuXHRcdFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXG5cdFx0XHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQpIHtcblx0XHRcdFx0Ly8gKFBvaW50KVxuXHRcdFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXG5cdFx0XHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXG5cdFx0XHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQpIHtcblx0XHRcdFx0Ly8gKFBvaW50KVxuXHRcdFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXG5cdFx0XHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcblx0XHRcdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXG5cdFx0XHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50KSB7XG5cdFx0XHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XG5cdFx0XHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcblx0XHRcdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxuXHRcdFx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XG5cdFx0XHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxuXHRcdFx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cblx0XHRcdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSB7XG5cdFx0XHRcdHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxuXHRcdFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xuXHRcdFx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxuXHRcdFx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gbW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcblx0XHRcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXG5cdFx0XHQvLyBldmVudCB0b29rIHBsYWNlLlxuXHRcdFx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiBtb3VzZUV2ZW50VG9MYXRMbmcoZSkge1xuXHRcdFx0XHQvLyAoTW91c2VFdmVudClcblx0XHRcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xuXG5cdFx0XHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gX2luaXRDb250YWluZXIoaWQpIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGdldChpZCk7XG5cblx0XHRcdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHN0YW1wKGNvbnRhaW5lcik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfaW5pdExheW91dDogZnVuY3Rpb24gX2luaXRMYXlvdXQoKSB7XG5cdFx0XHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHRcdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgYW55M2Q7XG5cblx0XHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICsgKHRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArIChyZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArIChpZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgKyAoc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgKyAodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2luaXRQYW5lcygpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xuXHRcdFx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9pbml0UGFuZXM6IGZ1bmN0aW9uIF9pbml0UGFuZXMoKSB7XG5cdFx0XHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XG5cdFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcblxuXHRcdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxuXHRcdFx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3Jcblx0XHRcdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcblx0XHRcdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcblx0XHRcdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcblxuXHRcdFx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcblxuXHRcdFx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcblx0XHRcdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcblx0XHRcdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xuXHRcdFx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcblx0XHRcdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXG5cdFx0XHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xuXHRcdFx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxuXHRcdFx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcblx0XHRcdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xuXHRcdFx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxuXHRcdFx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xuXHRcdFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcblx0XHRcdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXG5cdFx0XHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXG5cdFx0XHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcblx0XHRcdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxuXHRcdFx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cblx0XHRcdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0YWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XG5cdFx0XHRcdFx0YWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcblxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHRcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIF9yZXNldFZpZXcoY2VudGVyLCB6b29tKSB7XG5cdFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XG5cblx0XHRcdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xuXHRcdFx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXHRcdFx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xuXG5cdFx0XHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XG5cblx0XHRcdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcblx0XHRcdFx0dGhpcy5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSkuX21vdmUoY2VudGVyLCB6b29tKS5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcblx0XHRcdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcblx0XHRcdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cblx0XHRcdFx0aWYgKGxvYWRpbmcpIHtcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X21vdmVTdGFydDogZnVuY3Rpb24gX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcblx0XHRcdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXG5cdFx0XHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXG5cdFx0XHRcdGlmICh6b29tQ2hhbmdlZCkge1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFub01vdmVTdGFydCkge1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfbW92ZTogZnVuY3Rpb24gX21vdmUoY2VudGVyLCB6b29tLCBkYXRhKSB7XG5cdFx0XHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR6b29tID0gdGhpcy5fem9vbTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xuXG5cdFx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xuXHRcdFx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xuXHRcdFx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cblx0XHRcdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxuXHRcdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgZGF0YSAmJiBkYXRhLnBpbmNoKSB7XG5cdFx0XHRcdFx0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcblx0XHRcdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXG5cdFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcblx0XHRcdH0sXG5cblx0XHRcdF9tb3ZlRW5kOiBmdW5jdGlvbiBfbW92ZUVuZCh6b29tQ2hhbmdlZCkge1xuXHRcdFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cblx0XHRcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXG5cdFx0XHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfc3RvcDogZnVuY3Rpb24gX3N0b3AoKSB7XG5cdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcblx0XHRcdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9yYXdQYW5CeTogZnVuY3Rpb24gX3Jhd1BhbkJ5KG9mZnNldCkge1xuXHRcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uIF9nZXRab29tU3BhbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiBfcGFuSW5zaWRlTWF4Qm91bmRzKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xuXHRcdFx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gX2NoZWNrSWZMb2FkZWQoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXG5cblx0XHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xuXHRcdFx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIF9pbml0RXZlbnRzKHJlbW92ZSQkMSkge1xuXHRcdFx0XHR0aGlzLl90YXJnZXRzID0ge307XG5cdFx0XHRcdHRoaXMuX3RhcmdldHNbc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xuXG5cdFx0XHRcdHZhciBvbk9mZiA9IHJlbW92ZSQkMSA/IG9mZiA6IG9uO1xuXG5cdFx0XHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cblx0XHRcdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXG5cdFx0XHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxuXHRcdFx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cblx0XHRcdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cblx0XHRcdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxuXHRcdFx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXG5cdFx0XHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXG5cdFx0XHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cblx0XHRcdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxuXHRcdFx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxuXHRcdFx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cblx0XHRcdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArICdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcblx0XHRcdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcblx0XHRcdFx0XHQocmVtb3ZlJCQxID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X29uUmVzaXplOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG5cdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcblx0XHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZGF0ZVNpemUoeyBkZWJvdW5jZU1vdmVlbmQ6IHRydWUgfSk7XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uU2Nyb2xsOiBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiBfb25Nb3ZlRW5kKCkge1xuXHRcdFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xuXHRcdFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxuXHRcdFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cblx0XHRcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxuXHRcdFx0XHQgICAgdGFyZ2V0LFxuXHRcdFx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXG5cdFx0XHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG5cdFx0XHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xuXG5cdFx0XHRcdHdoaWxlIChzcmMpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xuXHRcdFx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XG5cdFx0XHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cblx0XHRcdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XG5cdFx0XHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XG5cdFx0XHRcdFx0XHRpZiAoaXNIb3Zlcikge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0cztcblx0XHRcdH0sXG5cblx0XHRcdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gX2hhbmRsZURPTUV2ZW50KGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgc2tpcHBlZChlKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0eXBlID0gZS50eXBlO1xuXG5cdFx0XHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnKSB7XG5cdFx0XHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XG5cdFx0XHRcdFx0cHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcblx0XHRcdH0sXG5cblx0XHRcdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcblxuXHRcdFx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gX2ZpcmVET01FdmVudChlLCB0eXBlLCB0YXJnZXRzKSB7XG5cblx0XHRcdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cblx0XHRcdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxuXHRcdFx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXG5cdFx0XHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXG5cdFx0XHRcdFx0dmFyIHN5bnRoID0gZXh0ZW5kKHt9LCBlKTtcblx0XHRcdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcblx0XHRcdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGUuX3N0b3BwZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXG5cdFx0XHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xuXG5cdFx0XHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnKSB7XG5cdFx0XHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcblx0XHRcdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgPyB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cdFx0XHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcblx0XHRcdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8IHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBpbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gX2RyYWdnYWJsZU1vdmVkKG9iaikge1xuXHRcdFx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XG5cdFx0XHRcdHJldHVybiBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkgfHwgdGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uIF9jbGVhckhhbmRsZXJzKCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcblxuXHRcdFx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHRcdFx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXG5cdFx0XHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcblx0XHRcdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cblx0XHRcdHdoZW5SZWFkeTogZnVuY3Rpb24gd2hlblJlYWR5KGNhbGxiYWNrLCBjb250ZXh0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywgeyB0YXJnZXQ6IHRoaXMgfSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcblxuXHRcdFx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uIF9nZXRNYXBQYW5lUG9zKCkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xuXHRcdFx0fSxcblxuXHRcdFx0X21vdmVkOiBmdW5jdGlvbiBfbW92ZWQoKSB7XG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XG5cdFx0XHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIF9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKSB7XG5cdFx0XHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgPyB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDogdGhpcy5nZXRQaXhlbE9yaWdpbigpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkge1xuXHRcdFx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcblx0XHRcdH0sXG5cblx0XHRcdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIF9sYXRMbmdUb05ld0xheWVyUG9pbnQobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcblx0XHRcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XG5cdFx0XHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcblx0XHRcdFx0cmV0dXJuIHRvQm91bmRzKFt0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksIHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSwgdGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLCB0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCldKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxuXHRcdFx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uIF9nZXRDZW50ZXJMYXllclBvaW50KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xuXHRcdFx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gX2dldENlbnRlck9mZnNldChsYXRsbmcpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcblx0XHRcdF9saW1pdENlbnRlcjogZnVuY3Rpb24gX2xpbWl0Q2VudGVyKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XG5cblx0XHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2VudGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0XHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdFx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcblx0XHRcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xuXG5cdFx0XHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxuXHRcdFx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXG5cdFx0XHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxuXHRcdFx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2VudGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcblx0XHRcdF9saW1pdE9mZnNldDogZnVuY3Rpb24gX2xpbWl0T2Zmc2V0KG9mZnNldCwgYm91bmRzKSB7XG5cdFx0XHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdFx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xuXG5cdFx0XHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXG5cdFx0XHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiBfZ2V0Qm91bmRzT2Zmc2V0KHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcblx0XHRcdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLCB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSksXG5cdFx0XHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXG5cdFx0XHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXG5cdFx0XHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXG5cdFx0XHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3JlYm91bmQ6IGZ1bmN0aW9uIF9yZWJvdW5kKGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID8gTWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6IE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfbGltaXRab29tOiBmdW5jdGlvbiBfbGltaXRab29tKHpvb20pIHtcblx0XHRcdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxuXHRcdFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXG5cdFx0XHRcdCAgICBzbmFwID0gYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xuXHRcdFx0XHRpZiAoc25hcCkge1xuXHRcdFx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gX29uUGFuVHJhbnNpdGlvblN0ZXAoKSB7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gX29uUGFuVHJhbnNpdGlvbkVuZCgpIHtcblx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIF90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xuXG5cdFx0XHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdFx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uIF9jcmVhdGVBbmltUHJveHkoKSB7XG5cblx0XHRcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xuXG5cdFx0XHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR2YXIgcHJvcCA9IFRSQU5TRk9STSxcblx0XHRcdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XG5cblx0XHRcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XG5cblx0XHRcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxuXHRcdFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcblx0XHRcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXG5cdFx0XHRcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcblx0XHRcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gX2Rlc3Ryb3lBbmltUHJveHkoKSB7XG5cdFx0XHRcdF9yZW1vdmUodGhpcy5fcHJveHkpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiBfY2F0Y2hUcmFuc2l0aW9uRW5kKGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uIF9ub3RoaW5nVG9BbmltYXRlKCkge1xuXHRcdFx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiBfdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2Vcblx0XHRcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHwgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXG5cdFx0XHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxuXHRcdFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xuXG5cdFx0XHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXG5cdFx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhcnRBbmltKSB7XG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cblx0XHRcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XG5cblx0XHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxuXHRcdFx0XHQvLyBGaXJlZCBvbiBldmVyeSBmcmFtZSBvZiBhIHpvb20gYW5pbWF0aW9uXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XG5cdFx0XHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRcdFx0em9vbTogem9vbSxcblx0XHRcdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xuXHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gX29uWm9vbVRyYW5zaXRpb25FbmQoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHRcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xuXG5cdFx0XHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxuXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBzZWN0aW9uXG5cblx0XHQvLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXG5cdFx0Ly8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XG5cdFx0Ly8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxuXHRcdC8vXG5cdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0Ly8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXG5cdFx0Ly8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XG5cdFx0Ly8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxuXHRcdGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2xcclxuICAgKiBAYWthIEwuQ29udHJvbFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICAgKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICAgKi9cblxuXHRcdHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXG5cdFx0XHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXG5cdFx0XHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXG5cdFx0XHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpIHtcblx0XHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qIEBzZWN0aW9uXHJcbiAgICAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgICAqL1xuXHRcdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXG5cdFx0XHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0XHRpZiAobWFwKSB7XG5cdFx0XHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxuXHRcdFx0XHRpZiAobWFwKSB7XG5cdFx0XHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cblx0XHRcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcblx0XHRcdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cblx0XHRcdGFkZFRvOiBmdW5jdGlvbiBhZGRUbyhtYXApIHtcblx0XHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0XHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXG5cdFx0XHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXG5cdFx0XHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XG5cblx0XHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XG5cblx0XHRcdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0XHRcdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3JlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XG5cdFx0XHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbWFwID0gbnVsbDtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIF9yZWZvY3VzT25NYXAoZSkge1xuXHRcdFx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxuXHRcdFx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBjb250cm9sID0gZnVuY3Rpb24gY29udHJvbChvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XG5cdFx0fTtcblxuXHRcdC8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAgICogQHVuaW5oZXJpdGFibGVcclxuICAgKlxyXG4gICAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICAgKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAgICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gICAqL1xuXG5cdFx0LyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgICovXG5cdFx0TWFwLmluY2x1ZGUoe1xuXHRcdFx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXG5cdFx0XHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcblx0XHRcdGFkZENvbnRyb2w6IGZ1bmN0aW9uIGFkZENvbnRyb2woY29udHJvbCkge1xuXHRcdFx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcblx0XHRcdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIHJlbW92ZUNvbnRyb2woY29udHJvbCkge1xuXHRcdFx0XHRjb250cm9sLnJlbW92ZSgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gX2luaXRDb250cm9sUG9zKCkge1xuXHRcdFx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXG5cdFx0XHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcblx0XHRcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XG5cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xuXHRcdFx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XG5cblx0XHRcdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcblx0XHRcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcblx0XHRcdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xuXHRcdFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gX2NsZWFyQ29udHJvbFBvcygpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xuXHRcdFx0XHRcdF9yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gICAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICAgKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICAgKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogdmFyIG92ZXJsYXlzID0ge1xyXG4gICAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gICAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcclxuICAgKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAgICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHR2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxuXHRcdFx0XHRjb2xsYXBzZWQ6IHRydWUsXG5cdFx0XHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cblx0XHRcdFx0YXV0b1pJbmRleDogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cblx0XHRcdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXG5cdFx0XHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cblx0XHRcdFx0c29ydExheWVyczogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxuXHRcdFx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxuXHRcdFx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXG5cdFx0XHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cblx0XHRcdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXG5cdFx0XHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxuXHRcdFx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IG5hbWVCIDwgbmFtZUEgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9sYXllcnMgPSBbXTtcblx0XHRcdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XG5cdFx0XHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcblxuXHRcdFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcblx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xuXHRcdFx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuXHRcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXG5cdFx0XHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRUbzogZnVuY3Rpb24gYWRkVG8obWFwKSB7XG5cdFx0XHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcblx0XHRcdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0b25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuXHRcdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xuXHRcdFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cblx0XHRcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gYWRkQmFzZUxheWVyKGxheWVyLCBuYW1lKSB7XG5cdFx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcCA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcblx0XHRcdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXG5cdFx0XHRhZGRPdmVybGF5OiBmdW5jdGlvbiBhZGRPdmVybGF5KGxheWVyLCBuYW1lKSB7XG5cdFx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcCA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxuXHRcdFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIHJlbW92ZUxheWVyKGxheWVyKSB7XG5cdFx0XHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xuXG5cdFx0XHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChsYXllcikpO1xuXHRcdFx0XHRpZiAob2JqKSB7XG5cdFx0XHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xuXHRcdFx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXG5cdFx0XHRleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZCgpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xuXHRcdFx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IG51bGw7XG5cdFx0XHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XG5cdFx0XHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fZm9ybS5jbGllbnRIZWlnaHQpIHtcblx0XHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcblx0XHRcdFx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcblx0XHRcdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cblx0XHRcdGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZSgpIHtcblx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiBfaW5pdExheW91dCgpIHtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcblx0XHRcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdFx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcblxuXHRcdFx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXG5cdFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcblxuXHRcdFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xuXHRcdFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcblxuXHRcdFx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBjcmVhdGUkMSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xuXG5cdFx0XHRcdGlmIChjb2xsYXBzZWQpIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XG5cblx0XHRcdFx0XHRpZiAoIWFuZHJvaWQpIHtcblx0XHRcdFx0XHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcblx0XHRcdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxuXHRcdFx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XG5cdFx0XHRcdGxpbmsuaHJlZiA9ICcjJztcblx0XHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xuXG5cdFx0XHRcdGlmICh0b3VjaCkge1xuXHRcdFx0XHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xuXHRcdFx0XHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWNvbGxhcHNlZCkge1xuXHRcdFx0XHRcdHRoaXMuZXhwYW5kKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcblx0XHRcdFx0dGhpcy5fc2VwYXJhdG9yID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XG5cdFx0XHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgZm9ybSk7XG5cblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldExheWVyOiBmdW5jdGlvbiBfZ2V0TGF5ZXIoaWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIF9hZGRMYXllcihsYXllciwgbmFtZSwgb3ZlcmxheSkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xheWVycy5wdXNoKHtcblx0XHRcdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRvdmVybGF5OiBvdmVybGF5XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xuXHRcdFx0XHRcdHRoaXMuX2xheWVycy5zb3J0KGJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xuXHRcdFx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xuXHRcdFx0XHRlbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xuXG5cdFx0XHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xuXHRcdFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsXG5cdFx0XHRcdCAgICBvdmVybGF5c1ByZXNlbnQsXG5cdFx0XHRcdCAgICBpLFxuXHRcdFx0XHQgICAgb2JqLFxuXHRcdFx0XHQgICAgYmFzZUxheWVyc0NvdW50ID0gMDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xuXHRcdFx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcblx0XHRcdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XG5cdFx0XHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XG5cdFx0XHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcblx0XHRcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XG5cdFx0XHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIF9vbkxheWVyQ2hhbmdlKGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcblxuXHRcdFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdFx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcblx0XHRcdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cblx0XHRcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXG5cdFx0XHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXG5cdFx0XHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcblx0XHRcdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/IGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScgOiBlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsO1xuXG5cdFx0XHRcdGlmICh0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcblx0XHRcdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIF9jcmVhdGVSYWRpb0VsZW1lbnQobmFtZSwgY2hlY2tlZCkge1xuXG5cdFx0XHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICsgbmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xuXG5cdFx0XHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xuXG5cdFx0XHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkSXRlbTogZnVuY3Rpb24gX2FkZEl0ZW0ob2JqKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXG5cdFx0XHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXG5cdFx0XHRcdCAgICBpbnB1dDtcblxuXHRcdFx0XHRpZiAob2JqLm92ZXJsYXkpIHtcblx0XHRcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XG5cdFx0XHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xuXHRcdFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVycycsIGNoZWNrZWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xuXHRcdFx0XHRpbnB1dC5sYXllcklkID0gc3RhbXAob2JqLmxheWVyKTtcblxuXHRcdFx0XHRvbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcblxuXHRcdFx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcblxuXHRcdFx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxuXHRcdFx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cblx0XHRcdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcblx0XHRcdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcblx0XHRcdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xuXG5cdFx0XHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG5cdFx0XHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gX29uSW5wdXRDbGljaygpIHtcblx0XHRcdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcblx0XHRcdFx0ICAgIGlucHV0LFxuXHRcdFx0XHQgICAgbGF5ZXI7XG5cdFx0XHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxuXHRcdFx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xuXG5cdFx0XHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcblx0XHRcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xuXG5cdFx0XHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xuXG5cdFx0XHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uIF9jaGVja0Rpc2FibGVkTGF5ZXJzKCkge1xuXHRcdFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxuXHRcdFx0XHQgICAgaW5wdXQsXG5cdFx0XHRcdCAgICBsYXllcixcblx0XHRcdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcblx0XHRcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xuXHRcdFx0XHRcdGlucHV0LmRpc2FibGVkID0gbGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSB8fCBsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uIF9leHBhbmRJZk5vdENvbGxhcHNlZCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xuXHRcdFx0XHRcdHRoaXMuZXhwYW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZXhwYW5kOiBmdW5jdGlvbiBfZXhwYW5kKCkge1xuXHRcdFx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHBhbmQoKTtcblx0XHRcdH0sXG5cblx0XHRcdF9jb2xsYXBzZTogZnVuY3Rpb24gX2NvbGxhcHNlKCkge1xuXHRcdFx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb2xsYXBzZSgpO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0XHQvLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcblx0XHQvLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxuXHRcdHZhciBsYXllcnMgPSBmdW5jdGlvbiBsYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcblx0XHR9O1xuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICovXG5cblx0XHR2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcblx0XHRcdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxuXHRcdFx0XHR6b29tSW5UZXh0OiAnKycsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXG5cdFx0XHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXG5cdFx0XHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xuXHRcdFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxuXHRcdFx0XHR6b29tT3V0VGV4dDogJyYjeDIyMTI7JyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xuXHRcdFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cblx0XHRcdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXG5cdFx0XHR9LFxuXG5cdFx0XHRvbkFkZDogZnVuY3Rpb24gb25BZGQobWFwKSB7XG5cdFx0XHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXG5cdFx0XHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXG5cdFx0XHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsIHpvb21OYW1lICsgJy1pbicsIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcblx0XHRcdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSwgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XG5cblx0XHRcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0XHRcdH0sXG5cblx0XHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZShtYXApIHtcblx0XHRcdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRcdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuXHRcdFx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF96b29tSW46IGZ1bmN0aW9uIF96b29tSW4oZSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3pvb21PdXQ6IGZ1bmN0aW9uIF96b29tT3V0KGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiBfY3JlYXRlQnV0dG9uKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcblx0XHRcdFx0dmFyIGxpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHRcdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0XHRsaW5rLmhyZWYgPSAnIyc7XG5cdFx0XHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcblxuXHRcdFx0XHQvKlxyXG4gICAgICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuICAgICAqL1xuXHRcdFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcblx0XHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XG5cblx0XHRcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XG5cdFx0XHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xuXHRcdFx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XG5cdFx0XHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XG5cblx0XHRcdFx0cmV0dXJuIGxpbms7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uIF91cGRhdGVEaXNhYmxlZCgpIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHRcdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcblxuXHRcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xuXHRcdFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xuXHRcdFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXG5cdFx0TWFwLm1lcmdlT3B0aW9ucyh7XG5cdFx0XHR6b29tQ29udHJvbDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0TWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcblx0XHRcdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XG5cdFx0XHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXG5cdFx0Ly8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXG5cdFx0Ly8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxuXHRcdHZhciB6b29tID0gZnVuY3Rpb24gem9vbShvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XG5cdFx0fTtcblxuXHRcdC8qXG4gICAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gICAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gICAqIEBpbmhlcml0cyBDb250cm9sXG4gICAqXG4gICAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cblx0XHR2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcblx0XHRcdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0XHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdFx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcblx0XHRcdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0XHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0XHRcdH0sXG5cblx0XHRcdG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuXHRcdFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0XHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0XHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0XHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0XHRcdH0sXG5cblx0XHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZShtYXApIHtcblx0XHRcdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkU2NhbGVzOiBmdW5jdGlvbiBfYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHRcdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLCBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiBfdXBkYXRlTWV0cmljKG1heE1ldGVycykge1xuXHRcdFx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHRcdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiBtZXRlcnMgLyAxMDAwICsgJyBrbSc7XG5cblx0XHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycykge1xuXHRcdFx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHRcdFx0ICAgIG1heE1pbGVzLFxuXHRcdFx0XHQgICAgbWlsZXMsXG5cdFx0XHRcdCAgICBmZWV0O1xuXG5cdFx0XHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiBfdXBkYXRlU2NhbGUoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0XHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdFx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiBfZ2V0Um91bmROdW0obnVtKSB7XG5cdFx0XHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdFx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0XHRcdGQgPSBkID49IDEwID8gMTAgOiBkID49IDUgPyA1IDogZCA+PSAzID8gMyA6IGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0XHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcblx0XHQvLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cblx0XHR2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xuXHRcdH07XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAgICovXG5cblx0XHR2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XG5cdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xuXHRcdFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cblx0XHRcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuXHRcdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcblx0XHRcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcblxuXHRcdFx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXG5cdFx0XHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcblx0XHRcdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cblx0XHRcdHNldFByZWZpeDogZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcblx0XHRcdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXG5cdFx0XHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gYWRkQXR0cmlidXRpb24odGV4dCkge1xuXHRcdFx0XHRpZiAoIXRleHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcblxuXHRcdFx0XHR0aGlzLl91cGRhdGUoKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxuXHRcdFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQpIHtcblx0XHRcdFx0aWYgKCF0ZXh0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGF0dHJpYnMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XG5cdFx0XHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cblx0XHRNYXAubWVyZ2VPcHRpb25zKHtcblx0XHRcdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0TWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXG5cdFx0Ly8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcblx0XHQvLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXG5cdFx0dmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gYXR0cmlidXRpb24ob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcblx0XHR9O1xuXG5cdFx0Q29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5cdFx0Q29udHJvbC5ab29tID0gWm9vbTtcblx0XHRDb250cm9sLlNjYWxlID0gU2NhbGU7XG5cdFx0Q29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5cdFx0Y29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5cdFx0Y29udHJvbC56b29tID0gem9vbTtcblx0XHRjb250cm9sLnNjYWxlID0gc2NhbGU7XG5cdFx0Y29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG5cdFx0LypcbiAgXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuICBcdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuICAqL1xuXG5cdFx0Ly8gQGNsYXNzIEhhbmRsZXJcblx0XHQvLyBAYWthIEwuSGFuZGxlclxuXHRcdC8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuXHRcdHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobWFwKSB7XG5cdFx0XHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0XHRcdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0XHRcdGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHRcdFx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cdFx0XHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdFx0XHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0XHRcdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuXHRcdFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHRcdFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG5cdFx0fSk7XG5cblx0XHQvLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuXHRcdC8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuXHRcdC8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cdFx0SGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0XHRcdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHZhciBNaXhpbiA9IHsgRXZlbnRzOiBFdmVudHMgfTtcblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIERyYWdnYWJsZVxyXG4gICAqIEBha2EgTC5EcmFnZ2FibGVcclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gICAqXHJcbiAgICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gICAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICAgKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHR2YXIgU1RBUlQgPSB0b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcblx0XHR2YXIgRU5EID0ge1xuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXG5cdFx0fTtcblx0XHR2YXIgTU9WRSA9IHtcblx0XHRcdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcblx0XHRcdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXG5cdFx0fTtcblxuXHRcdHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xuXHRcdFx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXG5cdFx0XHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXG5cdFx0XHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cblx0XHRcdFx0Y2xpY2tUb2xlcmFuY2U6IDNcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXG5cdFx0XHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSQkMSwgb3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcblx0XHRcdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZSQkMTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZW5hYmxlKClcblx0XHRcdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcblx0XHRcdGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cblx0XHRcdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGRpc2FibGUoKVxuXHRcdFx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcblx0XHRcdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXG5cdFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcblxuXHRcdFx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Eb3duOiBmdW5jdGlvbiBfb25Eb3duKGUpIHtcblx0XHRcdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxuXHRcdFx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2Zcblx0XHRcdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXG5cdFx0XHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcblx0XHRcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXG5cdFx0XHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCAhPT0gMSAmJiBlLmJ1dHRvbiAhPT0gMSAmJiAhZS50b3VjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cblxuXHRcdFx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcblx0XHRcdFx0XHRwcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpc2FibGVJbWFnZURyYWcoKTtcblx0XHRcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRpZiAodGhpcy5fbW92aW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcblxuXHRcdFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0XHQgICAgc2l6ZWRQYXJlbnQgPSBnZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XG5cblx0XHRcdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXG5cdFx0XHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xuXG5cdFx0XHRcdG9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdFx0XHRcdG9uKGRvY3VtZW50LCBFTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Nb3ZlOiBmdW5jdGlvbiBfb25Nb3ZlKGUpIHtcblx0XHRcdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxuXHRcdFx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2Zcblx0XHRcdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXG5cdFx0XHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcblx0XHRcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXG5cdFx0XHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XG5cblx0XHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxuXHRcdFx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXG5cdFx0XHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cblx0XHRcdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcblx0XHRcdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcblxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0XHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcblxuXHRcdFx0XHRcdGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XG5cblx0XHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXHRcdFx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxuXHRcdFx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdFx0XHRcdHRoaXMuX21vdmluZyA9IHRydWU7XG5cblx0XHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblx0XHRcdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcblx0XHRcdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdFx0XHR2YXIgZSA9IHsgb3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50IH07XG5cblx0XHRcdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXG5cdFx0XHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcblx0XHRcdFx0c2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcblxuXHRcdFx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cblx0XHRcdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25VcDogZnVuY3Rpb24gX29uVXAoZSkge1xuXHRcdFx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXG5cdFx0XHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxuXHRcdFx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cblx0XHRcdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxuXHRcdFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cblx0XHRcdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcblx0XHRcdH0sXG5cblx0XHRcdGZpbmlzaERyYWc6IGZ1bmN0aW9uIGZpbmlzaERyYWcoKSB7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcblx0XHRcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xuXHRcdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XG5cdFx0XHRcdFx0b2ZmKGRvY3VtZW50LCBNT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuXHRcdFx0XHRcdG9mZihkb2N1bWVudCwgRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVuYWJsZUltYWdlRHJhZygpO1xuXHRcdFx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZykge1xuXHRcdFx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXG5cdFx0XHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdFx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXG5cdFx0XHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XG5cdFx0XHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAgICovXG5cblx0XHQvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cblx0XHQvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxuXG5cdFx0Ly8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXG5cdFx0Ly8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcblx0XHQvLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxuXHRcdC8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxuXHRcdC8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3Jcblx0XHQvLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXG5cdFx0Ly8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cblx0XHQvLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXG5cdFx0ZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcblx0XHRcdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXG5cdFx0XHQvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXG5cdFx0XHRwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xuXG5cdFx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cblx0XHRcdHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxuXHRcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cblx0XHRmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcblx0XHQvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cblx0XHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XG5cdFx0XHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XG5cdFx0fVxuXG5cdFx0Ly8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXG5cdFx0ZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuXG5cdFx0XHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdCAgICBBcnJheUNvbnN0cnVjdG9yID0gKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihVaW50OEFycmF5KSkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxuXHRcdFx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xuXG5cdFx0XHRtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XG5cblx0XHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcblxuXHRcdFx0dmFyIGksXG5cdFx0XHQgICAgbmV3UG9pbnRzID0gW107XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAobWFya2Vyc1tpXSkge1xuXHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ld1BvaW50cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcblxuXHRcdFx0dmFyIG1heFNxRGlzdCA9IDAsXG5cdFx0XHQgICAgaW5kZXgsXG5cdFx0XHQgICAgaSxcblx0XHRcdCAgICBzcURpc3Q7XG5cblx0XHRcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XG5cdFx0XHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuXHRcdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG5cdFx0XHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcblxuXHRcdFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcblx0XHRcdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XG5cdFx0ZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG5cdFx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xuXHRcdFx0XHRcdHByZXYgPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldiA8IGxlbiAtIDEpIHtcblx0XHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVkdWNlZFBvaW50cztcblx0XHR9XG5cblx0XHR2YXIgX2xhc3RDb2RlO1xuXG5cdFx0Ly8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXG5cdFx0Ly8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxuXHRcdC8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcblx0XHQvLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXG5cdFx0Ly8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cblx0XHRmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xuXHRcdFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxuXHRcdFx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcblx0XHRcdCAgICBjb2RlT3V0LFxuXHRcdFx0ICAgIHAsXG5cdFx0XHQgICAgbmV3Q29kZTtcblxuXHRcdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XG5cdFx0XHRfbGFzdENvZGUgPSBjb2RlQjtcblxuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxuXHRcdFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xuXHRcdFx0XHRcdHJldHVybiBbYSwgYl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxuXHRcdFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG90aGVyIGNhc2VzXG5cdFx0XHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcblx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xuXHRcdFx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcblxuXHRcdFx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcblx0XHRcdFx0XHRhID0gcDtcblx0XHRcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YiA9IHA7XG5cdFx0XHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xuXHRcdFx0dmFyIGR4ID0gYi54IC0gYS54LFxuXHRcdFx0ICAgIGR5ID0gYi55IC0gYS55LFxuXHRcdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXG5cdFx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcblx0XHRcdCAgICB4LFxuXHRcdFx0ICAgIHk7XG5cblx0XHRcdGlmIChjb2RlICYgOCkge1xuXHRcdFx0XHQvLyB0b3Bcblx0XHRcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xuXHRcdFx0XHR5ID0gbWF4Lnk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7XG5cdFx0XHRcdC8vIGJvdHRvbVxuXHRcdFx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XG5cdFx0XHRcdHkgPSBtaW4ueTtcblx0XHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHtcblx0XHRcdFx0Ly8gcmlnaHRcblx0XHRcdFx0eCA9IG1heC54O1xuXHRcdFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XG5cdFx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7XG5cdFx0XHRcdC8vIGxlZnRcblx0XHRcdFx0eCA9IG1pbi54O1xuXHRcdFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xuXHRcdFx0dmFyIGNvZGUgPSAwO1xuXG5cdFx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7XG5cdFx0XHRcdC8vIGxlZnRcblx0XHRcdFx0Y29kZSB8PSAxO1xuXHRcdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHtcblx0XHRcdFx0Ly8gcmlnaHRcblx0XHRcdFx0Y29kZSB8PSAyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7XG5cdFx0XHRcdC8vIGJvdHRvbVxuXHRcdFx0XHRjb2RlIHw9IDQ7XG5cdFx0XHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkge1xuXHRcdFx0XHQvLyB0b3Bcblx0XHRcdFx0Y29kZSB8PSA4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29kZTtcblx0XHR9XG5cblx0XHQvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcblx0XHRmdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xuXHRcdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXG5cdFx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcblx0XHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHR9XG5cblx0XHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcblx0XHRmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcblx0XHRcdHZhciB4ID0gcDEueCxcblx0XHRcdCAgICB5ID0gcDEueSxcblx0XHRcdCAgICBkeCA9IHAyLnggLSB4LFxuXHRcdFx0ICAgIGR5ID0gcDIueSAtIHksXG5cdFx0XHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXG5cdFx0XHQgICAgdDtcblxuXHRcdFx0aWYgKGRvdCA+IDApIHtcblx0XHRcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcblxuXHRcdFx0XHRpZiAodCA+IDEpIHtcblx0XHRcdFx0XHR4ID0gcDIueDtcblx0XHRcdFx0XHR5ID0gcDIueTtcblx0XHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xuXHRcdFx0XHRcdHggKz0gZHggKiB0O1xuXHRcdFx0XHRcdHkgKz0gZHkgKiB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGR4ID0gcC54IC0geDtcblx0XHRcdGR5ID0gcC55IC0geTtcblxuXHRcdFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXG5cdFx0Ly8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cblx0XHRmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xuXHRcdFx0cmV0dXJuICFpc0FycmF5KGxhdGxuZ3NbMF0pIHx8IF90eXBlb2YobGF0bG5nc1swXVswXSkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XG5cdFx0XHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xuXHRcdH1cblxuXHRcdHZhciBMaW5lVXRpbCA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRcdFx0c2ltcGxpZnk6IHNpbXBsaWZ5LFxuXHRcdFx0cG9pbnRUb1NlZ21lbnREaXN0YW5jZTogcG9pbnRUb1NlZ21lbnREaXN0YW5jZSxcblx0XHRcdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdFx0Y2xpcFNlZ21lbnQ6IGNsaXBTZWdtZW50LFxuXHRcdFx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IF9nZXRFZGdlSW50ZXJzZWN0aW9uLFxuXHRcdFx0X2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuXHRcdFx0X3NxQ2xvc2VzdFBvaW50T25TZWdtZW50OiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0XHRpc0ZsYXQ6IGlzRmxhdCxcblx0XHRcdF9mbGF0OiBfZmxhdFxuXHRcdH0pO1xuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gICAqL1xuXG5cdFx0LyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICAgKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gICAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAgICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gICAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gICAqL1xuXHRcdGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xuXHRcdFx0dmFyIGNsaXBwZWRQb2ludHMsXG5cdFx0XHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXG5cdFx0XHQgICAgaSxcblx0XHRcdCAgICBqLFxuXHRcdFx0ICAgIGssXG5cdFx0XHQgICAgYSxcblx0XHRcdCAgICBiLFxuXHRcdFx0ICAgIGxlbixcblx0XHRcdCAgICBlZGdlLFxuXHRcdFx0ICAgIHA7XG5cblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcblx0XHRcdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcblx0XHRcdFx0ZWRnZSA9IGVkZ2VzW2tdO1xuXHRcdFx0XHRjbGlwcGVkUG9pbnRzID0gW107XG5cblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdFx0XHRhID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRcdGIgPSBwb2ludHNbal07XG5cblx0XHRcdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcblx0XHRcdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcblx0XHRcdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxuXHRcdFx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcblx0XHRcdFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XG5cdFx0XHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcblxuXHRcdFx0XHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXG5cdFx0XHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xuXHRcdFx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xuXHRcdFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XG5cdFx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludHM7XG5cdFx0fVxuXG5cdFx0dmFyIFBvbHlVdGlsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdFx0XHRjbGlwUG9seWdvbjogY2xpcFBvbHlnb25cblx0XHR9KTtcblxuXHRcdC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHNlY3Rpb25cclxuICAgKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gICAqXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gICAqXHJcbiAgICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAgICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICAgKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gICAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAgICovXG5cblx0XHR2YXIgTG9uTGF0ID0ge1xuXHRcdFx0cHJvamVjdDogZnVuY3Rpb24gcHJvamVjdChsYXRsbmcpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcblx0XHRcdH0sXG5cblx0XHRcdHVucHJvamVjdDogZnVuY3Rpb24gdW5wcm9qZWN0KHBvaW50KSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXG5cdFx0fTtcblxuXHRcdC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gVGFrZXMgaW50byBhY2NvdW50IHRoYXQgRWFydGggaXMgYSBnZW9pZCwgbm90IGEgcGVyZmVjdCBzcGhlcmUuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAgICovXG5cblx0XHR2YXIgTWVyY2F0b3IgPSB7XG5cdFx0XHRSOiA2Mzc4MTM3LFxuXHRcdFx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXG5cblx0XHRcdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXG5cblx0XHRcdHByb2plY3Q6IGZ1bmN0aW9uIHByb2plY3QobGF0bG5nKSB7XG5cdFx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdFx0ICAgIHIgPSB0aGlzLlIsXG5cdFx0XHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXG5cdFx0XHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxuXHRcdFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcblx0XHRcdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcblxuXHRcdFx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xuXHRcdFx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XG5cdFx0XHR9LFxuXG5cdFx0XHR1bnByb2plY3Q6IGZ1bmN0aW9uIHVucHJvamVjdChwb2ludCkge1xuXHRcdFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRcdCAgICByID0gdGhpcy5SLFxuXHRcdFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcblx0XHRcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXG5cdFx0XHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXG5cdFx0XHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xuXHRcdFx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xuXHRcdFx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xuXHRcdFx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xuXHRcdFx0XHRcdHBoaSArPSBkcGhpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LypcbiAgICogQGNsYXNzIFByb2plY3Rpb25cbiAgXG4gICAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gICAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuICBcbiAgICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gICAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG4gIFxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuICBcbiAgICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gICAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG4gIFxuICAgKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cbiAgXG4gICAqL1xuXG5cdFx0dmFyIGluZGV4ID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdFx0XHRMb25MYXQ6IExvbkxhdCxcblx0XHRcdE1lcmNhdG9yOiBNZXJjYXRvcixcblx0XHRcdFNwaGVyaWNhbE1lcmNhdG9yOiBTcGhlcmljYWxNZXJjYXRvclxuXHRcdH0pO1xuXG5cdFx0LypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICAgKlxyXG4gICAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICovXG5cdFx0dmFyIEVQU0czMzk1ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xuXHRcdFx0Y29kZTogJ0VQU0c6MzM5NScsXG5cdFx0XHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcblxuXHRcdFx0dHJhbnNmb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcblx0XHRcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xuXHRcdFx0fSgpXG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gICAqXHJcbiAgICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gICAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAgICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gICAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICAgKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICAgKi9cblxuXHRcdHZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcblx0XHRcdGNvZGU6ICdFUFNHOjQzMjYnLFxuXHRcdFx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHRcdFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcblx0XHR9KTtcblxuXHRcdC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gICAqXG4gICAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICAgKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gICAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICAgKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICAgKi9cblxuXHRcdHZhciBTaW1wbGUgPSBleHRlbmQoe30sIENSUywge1xuXHRcdFx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHRcdFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdFx0XHRzY2FsZTogZnVuY3Rpb24gc2NhbGUoem9vbSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdFx0XHR9LFxuXG5cdFx0XHR6b29tOiBmdW5jdGlvbiB6b29tKHNjYWxlKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0XHRcdH0sXG5cblx0XHRcdGRpc3RhbmNlOiBmdW5jdGlvbiBkaXN0YW5jZShsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0XHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0XHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpbmZpbml0ZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0Q1JTLkVhcnRoID0gRWFydGg7XG5cdFx0Q1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5cdFx0Q1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG5cdFx0Q1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuXHRcdENSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuXHRcdENSUy5TaW1wbGUgPSBTaW1wbGU7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgTGF5ZXJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogQGFrYSBMLkxheWVyXG4gICAqIEBha2EgSUxheWVyXG4gICAqXG4gICAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gICAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5NYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5hZGRUbyhtYXApO1xuICAgKiBsYXllci5yZW1vdmUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBldmVudCBhZGQ6IEV2ZW50XG4gICAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICAgKlxuICAgKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gICAqL1xuXG5cdFx0dmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdFx0XHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0XHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRcdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0XHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhLCBlLmcuIFwiwqkgTWFwYm94XCIuXG5cdFx0XHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0XHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0XHRcdH0sXG5cblx0XHRcdC8qIEBzZWN0aW9uXG4gICAgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICAqXG4gICAgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG4gICAgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuICAgICovXG5cdFx0XHRhZGRUbzogZnVuY3Rpb24gYWRkVG8obWFwKSB7XG5cdFx0XHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdFx0XHRyZW1vdmVGcm9tOiBmdW5jdGlvbiByZW1vdmVGcm9tKG9iaikge1xuXHRcdFx0XHRpZiAob2JqKSB7XG5cdFx0XHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRcdFx0Z2V0UGFuZTogZnVuY3Rpb24gZ2V0UGFuZShuYW1lKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gdGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gYWRkSW50ZXJhY3RpdmVUYXJnZXQodGFyZ2V0RWwpIHtcblx0XHRcdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0YXJnZXRFbCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV07XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdFx0XHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRcdFx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uIGdldEF0dHJpYnV0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHRcdFx0fSxcblxuXHRcdFx0X2xheWVyQWRkOiBmdW5jdGlvbiBfbGF5ZXJBZGQoZSkge1xuXHRcdFx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRcdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0XHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0XHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdFx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiB0aGlzIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgICogQHVuaW5oZXJpdGFibGVcbiAgICpcbiAgICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICAgKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqXG4gICAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAgICovXG5cblx0XHQvKiBAbmFtZXNwYWNlIE1hcFxuICAgKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAgICpcbiAgICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICpcbiAgICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICAgKlxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gICAqL1xuXHRcdE1hcC5pbmNsdWRlKHtcblx0XHRcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHRcdFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRcdFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIGFkZExheWVyKGxheWVyKSB7XG5cdFx0XHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXHRcdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdFx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0XHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRcdFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIHJlbW92ZUxheWVyKGxheWVyKSB7XG5cdFx0XHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdFx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0XHRcdGhhc0xheWVyOiBmdW5jdGlvbiBoYXNMYXllcihsYXllcikge1xuXHRcdFx0XHRyZXR1cm4gISFsYXllciAmJiBzdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuXHRcdFx0fSxcblxuXHRcdFx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAqIGBgYFxuICAgICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG4gICAgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuICAgICogfSk7XG4gICAgKiBgYGBcbiAgICAqL1xuXHRcdFx0ZWFjaExheWVyOiBmdW5jdGlvbiBlYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdF9hZGRMYXllcnM6IGZ1bmN0aW9uIF9hZGRMYXllcnMobGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVycyA9IGxheWVycyA/IGlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdIDogW107XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gX2FkZFpvb21MaW1pdChsYXllcikge1xuXHRcdFx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiBfcmVtb3ZlWm9vbUxpbWl0KGxheWVyKSB7XG5cdFx0XHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuXHRcdFx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uIF91cGRhdGVab29tTGV2ZWxzKCkge1xuXHRcdFx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdFx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHRcdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0XHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0XHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdFx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAgICogQGFrYSBMLkxheWVyR3JvdXBcclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gICAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gICAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAgICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAgICogXHQuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cblxuXHRcdHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShsYXllcnMsIG9wdGlvbnMpIHtcblx0XHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcblxuXHRcdFx0XHR2YXIgaSwgbGVuO1xuXG5cdFx0XHRcdGlmIChsYXllcnMpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHRcdFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxuXHRcdFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIGFkZExheWVyKGxheWVyKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XG5cblx0XHRcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0XHRcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxuXHRcdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0XHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXG5cdFx0XHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cblx0XHRcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiByZW1vdmVMYXllcihsYXllcikge1xuXHRcdFx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XG5cblx0XHRcdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxuXHRcdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0XHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXG5cdFx0XHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cblx0XHRcdGhhc0xheWVyOiBmdW5jdGlvbiBoYXNMYXllcihsYXllcikge1xuXHRcdFx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cblx0XHRcdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiBjbGVhckxheWVycygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXG5cdFx0XHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XG5cdFx0XHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XG5cdFx0XHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxuXHRcdFx0aW52b2tlOiBmdW5jdGlvbiBpbnZva2UobWV0aG9kTmFtZSkge1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHRcdCAgICBpLFxuXHRcdFx0XHQgICAgbGF5ZXI7XG5cblx0XHRcdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XG5cdFx0XHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRvbkFkZDogZnVuY3Rpb24gb25BZGQobWFwKSB7XG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcblx0XHRcdH0sXG5cblx0XHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZShtYXApIHtcblx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHRcdFx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHRcdFx0Ly8gYGBganNcblx0XHRcdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHRcdFx0Ly8gfSk7XG5cdFx0XHQvLyBgYGBcblx0XHRcdGVhY2hMYXllcjogZnVuY3Rpb24gZWFjaExheWVyKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXG5cdFx0XHRnZXRMYXllcjogZnVuY3Rpb24gZ2V0TGF5ZXIoaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXG5cdFx0XHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cblx0XHRcdGdldExheWVyczogZnVuY3Rpb24gZ2V0TGF5ZXJzKCkge1xuXHRcdFx0XHR2YXIgbGF5ZXJzID0gW107XG5cdFx0XHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xuXHRcdFx0XHRyZXR1cm4gbGF5ZXJzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdFx0XHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cblx0XHRcdHNldFpJbmRleDogZnVuY3Rpb24gc2V0WkluZGV4KHpJbmRleCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxuXHRcdFx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gZ2V0TGF5ZXJJZChsYXllcikge1xuXHRcdFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXG5cdFx0Ly8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxuXHRcdHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gbGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xuXHRcdH07XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICAgKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAgICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICAgKlxyXG4gICAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAgICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAgICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gICAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gICAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICAgKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAgICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuXG5cdFx0dmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcblxuXHRcdFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIGFkZExheWVyKGxheWVyKSB7XG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XG5cblx0XHRcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXG5cdFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVMYXllcjogZnVuY3Rpb24gcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcblxuXHRcdFx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcblxuXHRcdFx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXG5cdFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cblx0XHRcdHNldFN0eWxlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHRcdFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcblx0XHRcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gYnJpbmdUb0Zyb250KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdFx0XHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcblx0XHRcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiBicmluZ1RvQmFjaygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXG5cdFx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcblx0XHRcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcblx0XHQvLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycy5cblx0XHR2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gZmVhdHVyZUdyb3VwKGxheWVycykge1xuXHRcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcblx0XHR9O1xuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgSWNvblxyXG4gICAqIEBha2EgTC5JY29uXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAgICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAgICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAgICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICAgKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAgICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAgICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gICAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICovXG5cblx0XHR2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XG5cblx0XHRcdC8qIEBzZWN0aW9uXHJcbiAgICAqIEBha2EgSWNvbiBvcHRpb25zXHJcbiAgICAqXHJcbiAgICAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG4gICAgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuICAgICpcclxuICAgICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgICAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG4gICAgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuICAgICpcclxuICAgICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcbiAgICAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gICAgKlxyXG4gICAgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG4gICAgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcbiAgICAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG4gICAgKlxyXG4gICAgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICAgICpcclxuICAgICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gICAgKlxyXG4gICAgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG4gICAgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICpcclxuICAgICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICAgICpcclxuICAgICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuICAgICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuICAgICpcclxuICAgICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcbiAgICAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcbiAgICAqXHJcbiAgICAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gICAgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcbiAgICAqL1xuXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXG5cdFx0XHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXVxuXHRcdFx0fSxcblxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRpb25zKSB7XG5cdFx0XHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcblx0XHRcdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcblx0XHRcdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXG5cdFx0XHRjcmVhdGVJY29uOiBmdW5jdGlvbiBjcmVhdGVJY29uKG9sZEljb24pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XG5cdFx0XHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxuXHRcdFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiBjcmVhdGVTaGFkb3cob2xkSWNvbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gX2NyZWF0ZUljb24obmFtZSwgb2xkSWNvbikge1xuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcblxuXHRcdFx0XHRpZiAoIXNyYykge1xuXHRcdFx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xuXHRcdFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XG5cblx0XHRcdFx0cmV0dXJuIGltZztcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiBfc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0XHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzaXplID0gdG9Qb2ludChzaXplT3B0aW9uKSxcblx0XHRcdFx0ICAgIGFuY2hvciA9IHRvUG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8IHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XG5cblx0XHRcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XG5cblx0XHRcdFx0aWYgKGFuY2hvcikge1xuXHRcdFx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gLWFuY2hvci54ICsgJ3B4Jztcblx0XHRcdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wID0gLWFuY2hvci55ICsgJ3B4Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzaXplKSB7XG5cdFx0XHRcdFx0aW1nLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRcdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gX2NyZWF0ZUltZyhzcmMsIGVsKSB7XG5cdFx0XHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cdFx0XHRcdGVsLnNyYyA9IHNyYztcblx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIF9nZXRJY29uVXJsKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXG5cdFx0Ly8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5cdFx0ZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LypcbiAgICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gICAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAgICogQHNlY3Rpb25cbiAgICpcbiAgICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAgICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gICAqIHJlbGVhc2VzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICAgKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAgICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICAgKi9cblxuXHRcdHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRpY29uVXJsOiAnbWFya2VyLWljb24ucG5nJyxcblx0XHRcdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0XHRcdHNoYWRvd1VybDogJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRcdFx0aWNvblNpemU6IFsyNSwgNDFdLFxuXHRcdFx0XHRpY29uQW5jaG9yOiBbMTIsIDQxXSxcblx0XHRcdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdFx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0XHRcdHNoYWRvd1NpemU6IFs0MSwgNDFdXG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0SWNvblVybDogZnVuY3Rpb24gX2dldEljb25VcmwobmFtZSkge1xuXHRcdFx0XHRpZiAoIUljb25EZWZhdWx0LmltYWdlUGF0aCkge1xuXHRcdFx0XHRcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdFx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0XHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHRcdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0XHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gX2RldGVjdEljb25QYXRoKCkge1xuXHRcdFx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHRcdFx0dmFyIHBhdGggPSBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fCBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpOyAvLyBJRThcblxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdFx0XHRpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoLmluZGV4T2YoJ3VybCcpICE9PSAwKSB7XG5cdFx0XHRcdFx0cGF0aCA9ICcnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL151cmxcXChbXCInXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLywgJycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxuICAgKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gICAqL1xuXG5cdFx0LyogQG5hbWVzcGFjZSBNYXJrZXJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAgICpcbiAgICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gICAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICAgKi9cblxuXHRcdHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShtYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHRcdFx0fSxcblxuXHRcdFx0YWRkSG9va3M6IGZ1bmN0aW9uIGFkZEhvb2tzKCkge1xuXHRcdFx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHRcdFx0YWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdFx0fSxcblxuXHRcdFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uIHJlbW92ZUhvb2tzKCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcblx0XHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdG1vdmVkOiBmdW5jdGlvbiBtb3ZlZCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FkanVzdFBhbjogZnVuY3Rpb24gX2FkanVzdFBhbihlKSB7XG5cdFx0XHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0XHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHRcdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdFx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuXHRcdFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0XHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcblx0XHRcdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0XHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSwgYm91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKSk7XG5cblx0XHRcdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcblx0XHRcdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludCgoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC0gKE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSwgKE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtIChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSkpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7IGFuaW1hdGU6IGZhbHNlIH0pO1xuXG5cdFx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0XHRcdHNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuXHRcdFx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoKSB7XG5cdFx0XHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0XHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdFx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0XHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCkuZmlyZSgnbW92ZXN0YXJ0JykuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25QcmVEcmFnOiBmdW5jdGlvbiBfb25QcmVEcmFnKGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25EcmFnOiBmdW5jdGlvbiBfb25EcmFnKGUpIHtcblx0XHRcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHRcdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0XHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdFx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRcdFx0c2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdFx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRcdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRcdFx0bWFya2VyLmZpcmUoJ21vdmUnLCBlKS5maXJlKCdkcmFnJywgZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25EcmFnRW5kOiBmdW5jdGlvbiBfb25EcmFnRW5kKGUpIHtcblx0XHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXG5cdFx0XHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcblx0XHRcdFx0dGhpcy5fbWFya2VyLmZpcmUoJ21vdmVlbmQnKS5maXJlKCdkcmFnZW5kJywgZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBNYXJrZXJcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKiBAYWthIEwuTWFya2VyXHJcbiAgICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuXG5cdFx0dmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XG5cblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIE1hcmtlciBvcHRpb25zXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcblx0XHRcdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxuXHRcdFx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXG5cdFx0XHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cblx0XHRcdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXG5cblx0XHRcdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdFx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdFx0XHRcdGRyYWdnYWJsZTogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uIHdoZW4gbWFya2VyIGhpdHMgdGhlIGVkZ2VzLlxuXHRcdFx0XHRhdXRvUGFuOiBmYWxzZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcblx0XHRcdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXG5cdFx0XHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcblx0XHRcdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBtb3ZlIGJ5LlxuXHRcdFx0XHRhdXRvUGFuU3BlZWQ6IDEwLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdFx0XHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cblx0XHRcdFx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcblx0XHRcdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXG5cdFx0XHRcdHRpdGxlOiAnJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcblx0XHRcdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cblx0XHRcdFx0YWx0OiAnJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxuXHRcdFx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cblx0XHRcdFx0ekluZGV4T2Zmc2V0OiAwLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0XHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxuXHRcdFx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcblx0XHRcdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXG5cdFx0XHRcdHJpc2VPZmZzZXQ6IDI1MCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xuXHRcdFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cblx0XHRcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0XHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdFx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZVxuXHRcdFx0fSxcblxuXHRcdFx0LyogQHNlY3Rpb25cclxuICAgICpcclxuICAgICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gICAgKi9cblxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRcdH0sXG5cblx0XHRcdG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcblx0XHRcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XG5cblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9pbml0SWNvbigpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0b25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKG1hcCkge1xuXHRcdFx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcblxuXHRcdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiBnZXRFdmVudHMoKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0em9vbTogdGhpcy51cGRhdGUsXG5cdFx0XHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xuXHRcdFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cblx0XHRcdGdldExhdExuZzogZnVuY3Rpb24gZ2V0TGF0TG5nKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXG5cdFx0XHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxuXHRcdFx0c2V0TGF0TG5nOiBmdW5jdGlvbiBzZXRMYXRMbmcobGF0bG5nKSB7XG5cdFx0XHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0XHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7IG9sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZyB9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xuXHRcdFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxuXHRcdFx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXG5cdFx0XHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cblx0XHRcdHNldEljb246IGZ1bmN0aW9uIHNldEljb24oaWNvbikge1xuXG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcblxuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdEljb24oKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRFbGVtZW50OiBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faWNvbjtcblx0XHRcdH0sXG5cblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcblx0XHRcdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0X2luaXRJY29uOiBmdW5jdGlvbiBfaW5pdEljb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdFx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxuXHRcdFx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxuXHRcdFx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9pY29uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFkZEljb24gPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcblx0XHRcdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XG5cdFx0XHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XG5cdFx0XHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2ljb24gPSBpY29uO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5vbih7XG5cdFx0XHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcblx0XHRcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcblx0XHRcdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xuXHRcdFx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3U2hhZG93KSB7XG5cdFx0XHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcblx0XHRcdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFkZEljb24pIHtcblx0XHRcdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcblx0XHRcdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcblx0XHRcdFx0XHR0aGlzLmdldFBhbmUoJ3NoYWRvd1BhbmUnKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gX3JlbW92ZUljb24oKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcblx0XHRcdFx0XHR0aGlzLm9mZih7XG5cdFx0XHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcblx0XHRcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3JlbW92ZSh0aGlzLl9pY29uKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcblxuXHRcdFx0XHR0aGlzLl9pY29uID0gbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uIF9yZW1vdmVTaGFkb3coKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcblx0XHRcdFx0XHRfcmVtb3ZlKHRoaXMuX3NoYWRvdyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRQb3M6IGZ1bmN0aW9uIF9zZXRQb3MocG9zKSB7XG5cdFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xuXHRcdFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcblxuXHRcdFx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gX3VwZGF0ZVpJbmRleChvZmZzZXQpIHtcblx0XHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIF9hbmltYXRlWm9vbShvcHQpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XG5cblx0XHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiBfaW5pdEludGVyYWN0aW9uKCkge1xuXG5cdFx0XHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblxuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xuXG5cdFx0XHRcdGlmIChNYXJrZXJEcmFnKSB7XG5cdFx0XHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XG5cdFx0XHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xuXG5cdFx0XHRcdFx0aWYgKGRyYWdnYWJsZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdFx0XHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXG5cdFx0XHRzZXRPcGFjaXR5OiBmdW5jdGlvbiBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gX3VwZGF0ZU9wYWNpdHkoKSB7XG5cdFx0XHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdFx0X3NldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xuXHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIF9icmluZ1RvRnJvbnQoKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uIF9yZXNldFpJbmRleCgpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiBfZ2V0UG9wdXBBbmNob3IoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uIF9nZXRUb29sdGlwQW5jaG9yKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcblxuXHRcdC8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxuXHRcdC8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXG5cdFx0ZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuXHRcdHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRcdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdFx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0XHRcdHdlaWdodDogMyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdFx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0XHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdFx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHRcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRcdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHRcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdFx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0XHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRcdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRcdFx0ZmlsbDogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHRcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdFx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0XHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRcdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHRcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRcdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdFx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0XHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRcdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHRcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0XHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0XHRcdH0sXG5cblx0XHRcdGJlZm9yZUFkZDogZnVuY3Rpb24gYmVmb3JlQWRkKG1hcCkge1xuXHRcdFx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHRcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdFx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdG9uQWRkOiBmdW5jdGlvbiBvbkFkZCgpIHtcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdFx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZSgpIHtcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdFx0XHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRcdFx0cmVkcmF3OiBmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdFx0XHRzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUpIHtcblx0XHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0XHRcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdFx0XHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIGJyaW5nVG9Gcm9udCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHRcdFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0XHRcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiBicmluZ1RvQmFjaygpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXQ6IGZ1bmN0aW9uIF9yZXNldCgpIHtcblx0XHRcdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG5cdFx0XHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uIF9jbGlja1RvbGVyYW5jZSgpIHtcblx0XHRcdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LypcbiAgICogQGNsYXNzIENpcmNsZU1hcmtlclxuICAgKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAgICovXG5cblx0XHR2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdFx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdFx0XHRyYWRpdXM6IDEwXG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdFx0XHRzZXRMYXRMbmc6IGZ1bmN0aW9uIHNldExhdExuZyhsYXRsbmcpIHtcblx0XHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHsgbGF0bG5nOiB0aGlzLl9sYXRsbmcgfSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0XHRcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdFx0XHRnZXRMYXRMbmc6IGZ1bmN0aW9uIGdldExhdExuZygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0XHRcdHNldFJhZGl1czogZnVuY3Rpb24gc2V0UmFkaXVzKHJhZGl1cykge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRcdFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiBnZXRSYWRpdXMoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUob3B0aW9ucykge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0XHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0XHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0X3Byb2plY3Q6IGZ1bmN0aW9uIF9wcm9qZWN0KCkge1xuXHRcdFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiBfdXBkYXRlQm91bmRzKCkge1xuXHRcdFx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdFx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0XHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gX3VwZGF0ZVBhdGgoKSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZW1wdHk6IGZ1bmN0aW9uIF9lbXB0eSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0XHRcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiBfY29udGFpbnNQb2ludChwKSB7XG5cdFx0XHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuXHRcdC8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5cdFx0ZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgQ2lyY2xlXG4gICAqIEBha2EgTC5DaXJjbGVcbiAgICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAgICpcbiAgICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cblx0XHR2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7IHJhZGl1czogb3B0aW9ucyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0XHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0XHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0XHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdFx0XHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdFx0XHRzZXRSYWRpdXM6IGZ1bmN0aW9uIHNldFJhZGl1cyhyYWRpdXMpIHtcblx0XHRcdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRcdFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiBnZXRSYWRpdXMoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0XHRcdGdldEJvdW5kczogZnVuY3Rpb24gZ2V0Qm91bmRzKCkge1xuXHRcdFx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyh0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSwgdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRcdFx0X3Byb2plY3Q6IGZ1bmN0aW9uIF9wcm9qZWN0KCkge1xuXG5cdFx0XHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdFx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHRcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHRcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdFx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdFx0XHQgICAgbGF0UiA9IHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SIC8gZCxcblx0XHRcdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC8gKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcblx0XHQvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcblx0XHQvLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cblx0XHQvLyBAYWx0ZXJuYXRpdmVcblx0XHQvLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcblx0XHQvLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuXHRcdC8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuXHRcdGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LypcbiAgICogQGNsYXNzIFBvbHlsaW5lXG4gICAqIEBha2EgTC5Qb2x5bGluZVxuICAgKiBAaW5oZXJpdHMgUGF0aFxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdFszNy43NywgLTEyMi40M10sXG4gICAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gICAqIF07XG4gICAqXG4gICAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gICAqIFx0IFszNy43NywgLTEyMi40M10sXG4gICAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gICAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAgICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICAgKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuXHRcdHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0XHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHRcdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdFx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0XHRcdG5vQ2xpcDogZmFsc2Vcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdFx0XHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdFx0XHRnZXRMYXRMbmdzOiBmdW5jdGlvbiBnZXRMYXRMbmdzKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0XHRcdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRcdFx0c2V0TGF0TG5nczogZnVuY3Rpb24gc2V0TGF0TG5ncyhsYXRsbmdzKSB7XG5cdFx0XHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0XHRcdGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG5cdFx0XHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0XHRcdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiBjbG9zZXN0TGF5ZXJQb2ludChwKSB7XG5cdFx0XHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdFx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdFx0XHQgICAgY2xvc2VzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHRcdFx0ICAgIHAxLFxuXHRcdFx0XHQgICAgcDI7XG5cblx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtaW5Qb2ludDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHRcdFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdFx0XHRnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcigpIHtcblx0XHRcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0ICAgIGhhbGZEaXN0LFxuXHRcdFx0XHQgICAgc2VnRGlzdCxcblx0XHRcdFx0ICAgIGRpc3QsXG5cdFx0XHRcdCAgICBwMSxcblx0XHRcdFx0ICAgIHAyLFxuXHRcdFx0XHQgICAgcmF0aW8sXG5cdFx0XHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHRcdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCFsZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRcdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHRcdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLCBwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0XHRcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRcdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiBnZXRCb3VuZHMoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdFx0XHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdFx0XHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHRcdFx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRcdFx0YWRkTGF0TG5nOiBmdW5jdGlvbiBhZGRMYXRMbmcobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0XHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdFx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiBfc2V0TGF0TG5ncyhsYXRsbmdzKSB7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHRcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gX2RlZmF1bHRTaGFwZSgpIHtcblx0XHRcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRcdFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiBfY29udmVydExhdExuZ3MobGF0bG5ncykge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdCAgICBmbGF0ID0gaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSxcblxuXHRcdFx0X3Byb2plY3Q6IGZ1bmN0aW9uIF9wcm9qZWN0KCkge1xuXHRcdFx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0XHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRcdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdFx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdFx0XHRweEJvdW5kcy5taW4uX3N1YnRyYWN0KHApO1xuXHRcdFx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0XHRcdHRoaXMuX3B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdFx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiBfcHJvamVjdExhdGxuZ3MobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHRcdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0XHRcdCAgICBpLFxuXHRcdFx0XHQgICAgcmluZztcblxuXHRcdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdFx0XHRfY2xpcFBvaW50czogZnVuY3Rpb24gX2NsaXBQb2ludHMoKSB7XG5cdFx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0XHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0XHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHRcdFx0ICAgIGksXG5cdFx0XHRcdCAgICBqLFxuXHRcdFx0XHQgICAgayxcblx0XHRcdFx0ICAgIGxlbixcblx0XHRcdFx0ICAgIGxlbjIsXG5cdFx0XHRcdCAgICBzZWdtZW50LFxuXHRcdFx0XHQgICAgcG9pbnRzO1xuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXNlZ21lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdFx0XHRpZiAoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSB8fCBqID09PSBsZW4yIC0gMikge1xuXHRcdFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdFx0XHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uIF9zaW1wbGlmeVBvaW50cygpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0XHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHBhcnRzW2ldID0gc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdFx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gX3VwZGF0ZVBhdGgoKSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRcdFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIF9jb250YWluc1BvaW50KHAsIGNsb3NlZCkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0ICAgIGosXG5cdFx0XHRcdCAgICBrLFxuXHRcdFx0XHQgICAgbGVuLFxuXHRcdFx0XHQgICAgbGVuMixcblx0XHRcdFx0ICAgIHBhcnQsXG5cdFx0XHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgaiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5cdFx0Ly8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG5cdFx0Ly8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG5cdFx0Ly8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcblx0XHQvLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cblx0XHRmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblx0XHRQb2x5bGluZS5fZmxhdCA9IF9mbGF0O1xuXG5cdFx0LypcbiAgICogQGNsYXNzIFBvbHlnb25cbiAgICogQGFrYSBMLlBvbHlnb25cbiAgICogQGluaGVyaXRzIFBvbHlsaW5lXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gICAqXG4gICAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqIF07XG4gICAqIGBgYFxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gICAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAgICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqICAgXSxcbiAgICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gICAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAgICogICBdXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuXHRcdHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRmaWxsOiB0cnVlXG5cdFx0XHR9LFxuXG5cdFx0XHRpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuXHRcdFx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0XHRcdH0sXG5cblx0XHRcdGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xuXHRcdFx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHQgICAgaixcblx0XHRcdFx0ICAgIHAxLFxuXHRcdFx0XHQgICAgcDIsXG5cdFx0XHRcdCAgICBmLFxuXHRcdFx0XHQgICAgYXJlYSxcblx0XHRcdFx0ICAgIHgsXG5cdFx0XHRcdCAgICB5LFxuXHRcdFx0XHQgICAgY2VudGVyLFxuXHRcdFx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0XHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICghbGVuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0XHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRcdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHRcdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdFx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIF9zZXRMYXRMbmdzKGxhdGxuZ3MpIHtcblx0XHRcdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0XHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiBfZGVmYXVsdFNoYXBlKCkge1xuXHRcdFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2xpcFBvaW50czogZnVuY3Rpb24gX2NsaXBQb2ludHMoKSB7XG5cdFx0XHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHRcdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdFx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0XHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0XHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0XHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRjbGlwcGVkID0gY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIF91cGRhdGVQYXRoKCkge1xuXHRcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0XHRcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiBfY29udGFpbnNQb2ludChwKSB7XG5cdFx0XHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0XHRcdFx0ICAgIHBhcnQsXG5cdFx0XHRcdCAgICBwMSxcblx0XHRcdFx0ICAgIHAyLFxuXHRcdFx0XHQgICAgaSxcblx0XHRcdFx0ICAgIGosXG5cdFx0XHRcdCAgICBrLFxuXHRcdFx0XHQgICAgbGVuLFxuXHRcdFx0XHQgICAgbGVuMjtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRcdFx0aWYgKHAxLnkgPiBwLnkgIT09IHAyLnkgPiBwLnkgJiYgcC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSB7XG5cdFx0XHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0XHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHRcdC8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5cdFx0ZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgR2VvSlNPTlxyXG4gICAqIEBha2EgTC5HZW9KU09OXHJcbiAgICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gICAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5nZW9KU09OKGRhdGEsIHtcclxuICAgKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gICAqIFx0fVxyXG4gICAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICAgKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAgICogfSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cblxuXHRcdHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XG5cblx0XHRcdC8qIEBzZWN0aW9uXHJcbiAgICAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcbiAgICAqXHJcbiAgICAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuICAgICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG4gICAgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuICAgICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG4gICAgKiBgYGBqc1xyXG4gICAgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG4gICAgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG4gICAgKiB9XHJcbiAgICAqIGBgYFxyXG4gICAgKlxyXG4gICAgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuICAgICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuICAgICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG4gICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG4gICAgKiBgYGBqc1xyXG4gICAgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICAgICogXHRyZXR1cm4ge31cclxuICAgICogfVxyXG4gICAgKiBgYGBcclxuICAgICpcclxuICAgICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuICAgICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcbiAgICAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuICAgICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuICAgICogYGBganNcclxuICAgICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG4gICAgKiBgYGBcclxuICAgICpcclxuICAgICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG4gICAgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG4gICAgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuICAgICogYGBganNcclxuICAgICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcbiAgICAqIFx0cmV0dXJuIHRydWU7XHJcbiAgICAqIH1cclxuICAgICogYGBgXHJcbiAgICAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcbiAgICAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuICAgICpcclxuICAgICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcbiAgICAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuICAgICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuICAgICovXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoZ2VvanNvbiwgb3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRoaXMuX2xheWVycyA9IHt9O1xuXG5cdFx0XHRcdGlmIChnZW9qc29uKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcblx0XHRcdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXG5cdFx0XHRhZGREYXRhOiBmdW5jdGlvbiBhZGREYXRhKGdlb2pzb24pIHtcblx0XHRcdFx0dmFyIGZlYXR1cmVzID0gaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxuXHRcdFx0XHQgICAgaSxcblx0XHRcdFx0ICAgIGxlbixcblx0XHRcdFx0ICAgIGZlYXR1cmU7XG5cblx0XHRcdFx0aWYgKGZlYXR1cmVzKSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxuXHRcdFx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAoIWxheWVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcblxuXHRcdFx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cdFx0XHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xuXHRcdFx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllciApOiB0aGlzXG5cdFx0XHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXG5cdFx0XHRyZXNldFN0eWxlOiBmdW5jdGlvbiByZXNldFN0eWxlKGxheWVyKSB7XG5cdFx0XHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXG5cdFx0XHRcdGxheWVyLm9wdGlvbnMgPSBleHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcblx0XHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcblx0XHRcdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cblx0XHRcdHNldFN0eWxlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiBfc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XG5cdFx0XHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcblx0XHQvLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXG5cdFx0Ly8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXG5cdFx0Ly8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXG5cdFx0ZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcblx0XHRcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcblx0XHRcdCAgICBsYXllcnMgPSBbXSxcblx0XHRcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxuXHRcdFx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcblx0XHRcdCAgICBsYXRsbmcsXG5cdFx0XHQgICAgbGF0bG5ncyxcblx0XHRcdCAgICBpLFxuXHRcdFx0ICAgIGxlbjtcblxuXHRcdFx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnUG9pbnQnOlxuXHRcdFx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xuXHRcdFx0XHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBNYXJrZXIobGF0bG5nKTtcblxuXHRcdFx0XHRjYXNlICdNdWx0aVBvaW50Jzpcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xuXHRcdFx0XHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTWFya2VyKGxhdGxuZykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmVTdHJpbmcnOlxuXHRcdFx0XHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuXHRcdFx0XHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdGNhc2UgJ1BvbHlnb24nOlxuXHRcdFx0XHRjYXNlICdNdWx0aVBvbHlnb24nOlxuXHRcdFx0XHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG5cblx0XHRcdFx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcblx0XHRcdFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcblx0XHRcdFx0XHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXG5cdFx0Ly8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcblx0XHQvLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cblx0XHRmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcblx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xuXHRcdH1cblxuXHRcdC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XG5cdFx0Ly8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxuXHRcdC8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cblx0XHQvLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXG5cdFx0ZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XG5cdFx0XHR2YXIgbGF0bG5ncyA9IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDogKF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcblxuXHRcdFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhdGxuZ3M7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxuXHRcdC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxuXHRcdGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XG5cdFx0XHRwcmVjaXNpb24gPSB0eXBlb2YgcHJlY2lzaW9uID09PSAnbnVtYmVyJyA/IHByZWNpc2lvbiA6IDY7XG5cdFx0XHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID8gW2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDogW2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XG5cdFx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcblx0XHQvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXG5cdFx0ZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XG5cdFx0XHR2YXIgY29vcmRzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgPyBsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6IGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb29yZHM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcblx0XHRcdHJldHVybiBsYXllci5mZWF0dXJlID8gZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7IGdlb21ldHJ5OiBuZXdHZW9tZXRyeSB9KSA6IGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XG5cdFx0fVxuXG5cdFx0Ly8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3Rcblx0XHQvLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cblx0XHRmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xuXHRcdFx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gZ2VvanNvbjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7fSxcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb2pzb25cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIFBvaW50VG9HZW9KU09OID0ge1xuXHRcdFx0dG9HZW9KU09OOiBmdW5jdGlvbiB0b0dlb0pTT04ocHJlY2lzaW9uKSB7XG5cdFx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcblx0XHRcdFx0XHR0eXBlOiAnUG9pbnQnLFxuXHRcdFx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcmtlclxuXHRcdC8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxuXHRcdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxuXHRcdE1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXG5cdFx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XG5cdFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxuXHRcdENpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcblx0XHRDaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBvbHlsaW5lXG5cdFx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XG5cdFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxuXHRcdFBvbHlsaW5lLmluY2x1ZGUoe1xuXHRcdFx0dG9HZW9KU09OOiBmdW5jdGlvbiB0b0dlb0pTT04ocHJlY2lzaW9uKSB7XG5cdFx0XHRcdHZhciBtdWx0aSA9ICFpc0ZsYXQodGhpcy5fbGF0bG5ncyk7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XG5cdFx0XHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcblx0XHRcdFx0XHRjb29yZGluYXRlczogY29vcmRzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQb2x5Z29uXG5cdFx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XG5cdFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXG5cdFx0UG9seWdvbi5pbmNsdWRlKHtcblx0XHRcdHRvR2VvSlNPTjogZnVuY3Rpb24gdG9HZW9KU09OKHByZWNpc2lvbikge1xuXHRcdFx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxuXHRcdFx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcblxuXHRcdFx0XHRpZiAoIWhvbGVzKSB7XG5cdFx0XHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XG5cdFx0XHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcblx0XHRcdFx0XHRjb29yZGluYXRlczogY29vcmRzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBMYXllckdyb3VwXG5cdFx0TGF5ZXJHcm91cC5pbmNsdWRlKHtcblx0XHRcdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gdG9NdWx0aVBvaW50KHByZWNpc2lvbikge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gW107XG5cblx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XG5cdFx0XHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxuXHRcdFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3Rcblx0XHRcdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxuXHRcdFx0dG9HZW9KU09OOiBmdW5jdGlvbiB0b0dlb0pTT04ocHJlY2lzaW9uKSB7XG5cblx0XHRcdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xuXG5cdFx0XHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuXHRcdFx0XHQgICAganNvbnMgPSBbXTtcblxuXHRcdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XG5cdFx0XHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xuXHRcdFx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcblx0XHRcdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXG5cdFx0XHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XG5cdFx0XHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcblx0XHRcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG5cdFx0XHRcdFx0ZmVhdHVyZXM6IGpzb25zXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIEdlb0pTT05cblx0XHQvLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcblx0XHQvLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxuXHRcdC8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxuXHRcdC8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXG5cdFx0ZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cblx0XHR2YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICAgKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAgICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICAgKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHR2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHRcdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXG5cdFx0XHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxuXHRcdFx0XHRhbHQ6ICcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxuXHRcdFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXG5cdFx0XHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxuXHRcdFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxuXHRcdFx0XHRjcm9zc09yaWdpbjogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXG5cdFx0XHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXG5cdFx0XHRcdGVycm9yT3ZlcmxheVVybDogJycsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHRcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgdGlsZSBsYXllci5cblx0XHRcdFx0ekluZGV4OiAxLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdFx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0XHRcdGNsYXNzTmFtZTogJydcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXG5cdFx0XHRcdHRoaXMuX3VybCA9IHVybDtcblx0XHRcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcblxuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xuXHRcdFx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdFx0fSxcblxuXHRcdFx0b25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuXHRcdFx0XHRfcmVtb3ZlKHRoaXMuX2ltYWdlKTtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cblx0XHRcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIHNldE9wYWNpdHkob3BhY2l0eSkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlT3B0cykge1xuXHRcdFx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcblx0XHRcdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHRcdFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cblx0XHRcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gYnJpbmdUb0Zyb250KCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0XHRcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXG5cdFx0XHRicmluZ1RvQmFjazogZnVuY3Rpb24gYnJpbmdUb0JhY2soKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXG5cdFx0XHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxuXHRcdFx0c2V0VXJsOiBmdW5jdGlvbiBzZXRVcmwodXJsKSB7XG5cdFx0XHRcdHRoaXMuX3VybCA9IHVybDtcblxuXHRcdFx0XHRpZiAodGhpcy5faW1hZ2UpIHtcblx0XHRcdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0XHRcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXG5cdFx0XHRzZXRCb3VuZHM6IGZ1bmN0aW9uIHNldEJvdW5kcyhib3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcblxuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdGdldEV2ZW50czogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuXHRcdFx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxuXHRcdFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZXZlbnRzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZDogc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpIDogdGhpc1xuXHRcdFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxuXHRcdFx0c2V0WkluZGV4OiBmdW5jdGlvbiBzZXRaSW5kZXgodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0XHRcdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXG5cdFx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXG5cdFx0XHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cblx0XHRcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0XHRcdH0sXG5cblx0XHRcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uIF9pbml0SW1hZ2UoKSB7XG5cdFx0XHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XG5cdFx0XHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcblxuXHRcdFx0XHRhZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0XHRhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdGFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG5cdFx0XHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxuXHRcdFx0XHRpbWcub25sb2FkID0gYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XG5cdFx0XHRcdGltZy5vbmVycm9yID0gYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XG5cdFx0XHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xuXHRcdFx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcblx0XHRcdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIF9hbmltYXRlWm9vbShlKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcblx0XHRcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcblxuXHRcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3Jlc2V0OiBmdW5jdGlvbiBfcmVzZXQoKSB7XG5cdFx0XHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxuXHRcdFx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXG5cdFx0XHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdFx0XHRzZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XG5cblx0XHRcdFx0aW1hZ2Uuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdFx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uIF91cGRhdGVPcGFjaXR5KCkge1xuXHRcdFx0XHRfc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gX3VwZGF0ZVpJbmRleCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiBfb3ZlcmxheU9uRXJyb3IoKSB7XG5cdFx0XHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXG5cdFx0XHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcblxuXHRcdFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xuXHRcdFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xuXHRcdFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xuXHRcdFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxuXHRcdC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuXHRcdHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiBpbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcblx0XHR9O1xuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAgICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gICAqXHJcbiAgICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICAgKiBIVE1MNSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICAgKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAgICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cblxuXHRcdHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cblx0XHRcdFx0YXV0b3BsYXk6IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxuXHRcdFx0XHRsb29wOiB0cnVlXG5cdFx0XHR9LFxuXG5cdFx0XHRfaW5pdEltYWdlOiBmdW5jdGlvbiBfaW5pdEltYWdlKCkge1xuXHRcdFx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XG5cdFx0XHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCd2aWRlbycpO1xuXG5cdFx0XHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuXHRcdFx0XHR2aWQub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXG5cdFx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcblx0XHRcdFx0dmlkLm9ubG9hZGVkZGF0YSA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xuXG5cdFx0XHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcblx0XHRcdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xuXHRcdFx0XHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fdXJsID0gc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCA/IHNvdXJjZXMgOiBbdmlkLnNyY107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHtcblx0XHRcdFx0XHR0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xuXHRcdFx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGNyZWF0ZSQxKCdzb3VyY2UnKTtcblx0XHRcdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xuXHRcdFx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcblx0XHRcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxuXHRcdC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG5cblx0XHRmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBMYXllclxyXG4gICAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAgICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAgICovXG5cblx0XHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcblx0XHR2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XG5cblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxuXHRcdFx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxuXHRcdFx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXG5cdFx0XHRcdG9mZnNldDogWzAsIDddLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxuXHRcdFx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcblx0XHRcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cblx0XHRcdFx0cGFuZTogJ3BvcHVwUGFuZSdcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucywgc291cmNlKSB7XG5cdFx0XHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0XHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuXHRcdFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XG5cdFx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFx0X3NldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvblJlbW92ZTogZnVuY3Rpb24gb25SZW1vdmUobWFwKSB7XG5cdFx0XHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZChfcmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3JlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIFBvcHVwXG5cdFx0XHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXG5cdFx0XHRnZXRMYXRMbmc6IGZ1bmN0aW9uIGdldExhdExuZygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXG5cdFx0XHRzZXRMYXRMbmc6IGZ1bmN0aW9uIHNldExhdExuZyhsYXRsbmcpIHtcblx0XHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXG5cdFx0XHRnZXRDb250ZW50OiBmdW5jdGlvbiBnZXRDb250ZW50KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cblx0XHRcdHNldENvbnRlbnQ6IGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuXHRcdFx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcblx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxuXHRcdFx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxuXHRcdFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXG5cdFx0XHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdFx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cblx0XHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRFdmVudHM6IGZ1bmN0aW9uIGdldEV2ZW50cygpIHtcblx0XHRcdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcblx0XHRcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBldmVudHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxuXHRcdFx0aXNPcGVuOiBmdW5jdGlvbiBpc09wZW4oKSB7XG5cdFx0XHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHRcdFx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXG5cdFx0XHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIGJyaW5nVG9Gcm9udCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0XHRcdC8vIEJyaW5ncyB0aGlzIHBvcHVwIHRvIHRoZSBiYWNrIG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxuXHRcdFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uIGJyaW5nVG9CYWNrKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gX3VwZGF0ZUNvbnRlbnQoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fY29udGVudCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XG5cdFx0XHRcdHZhciBjb250ZW50ID0gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcblx0XHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXG5cdFx0XHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxuXHRcdFx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XG5cblx0XHRcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0Yylcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiBfZ2V0QW5jaG9yKCkge1xuXHRcdFx0XHRyZXR1cm4gWzAsIDBdO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBjbGFzcyBQb3B1cFxyXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAgICogQGFrYSBMLlBvcHVwXHJcbiAgICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gICAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gICAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gICAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICAgKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cblxuXHRcdC8vIEBuYW1lc3BhY2UgUG9wdXBcblx0XHR2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXG5cdFx0XHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cblx0XHRcdFx0bWF4V2lkdGg6IDMwMCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxuXHRcdFx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXG5cdFx0XHRcdG1pbldpZHRoOiA1MCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxuXHRcdFx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XG5cdFx0XHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXG5cdFx0XHRcdG1heEhlaWdodDogbnVsbCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXG5cdFx0XHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cblx0XHRcdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXG5cdFx0XHRcdGF1dG9QYW46IHRydWUsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxuXHRcdFx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcblx0XHRcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxuXHRcdFx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcblx0XHRcdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxuXHRcdFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXG5cdFx0XHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxuXHRcdFx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cblx0XHRcdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxuXHRcdFx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxuXHRcdFx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxuXHRcdFx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2Zcblx0XHRcdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cblx0XHRcdFx0YXV0b0Nsb3NlOiB0cnVlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcblx0XHRcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2Zcblx0XHRcdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxuXHRcdFx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxuXHRcdFx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xuXHRcdFx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cblxuXHRcdFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHRcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cblx0XHRcdFx0Y2xhc3NOYW1lOiAnJ1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxuXHRcdFx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXG5cdFx0XHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cblx0XHRcdG9wZW5PbjogZnVuY3Rpb24gb3Blbk9uKG1hcCkge1xuXHRcdFx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcblx0XHRcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xuXHRcdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxuXHRcdFx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywgeyBwb3B1cDogdGhpcyB9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xuXHRcdFx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcblx0XHRcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywgeyBwb3B1cDogdGhpcyB9LCB0cnVlKTtcblx0XHRcdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcblx0XHRcdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXG5cdFx0XHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0b25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKG1hcCkge1xuXHRcdFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXG5cdFx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxuXHRcdFx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHsgcG9wdXA6IHRoaXMgfSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcblx0XHRcdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxuXHRcdFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywgeyBwb3B1cDogdGhpcyB9LCB0cnVlKTtcblx0XHRcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiBnZXRFdmVudHMoKSB7XG5cdFx0XHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XG5cdFx0XHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcblx0XHRcdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBldmVudHM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2xvc2U6IGZ1bmN0aW9uIF9jbG9zZSgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfaW5pdExheW91dDogZnVuY3Rpb24gX2luaXRMYXlvdXQoKSB7XG5cdFx0XHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXG5cdFx0XHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblxuXHRcdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xuXHRcdFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcblxuXHRcdFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcblx0XHRcdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcblx0XHRcdFx0b24od3JhcHBlciwgJ2NvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR0aGlzLl90aXBDb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcblx0XHRcdFx0dGhpcy5fdGlwID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XG5cdFx0XHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBjcmVhdGUkMSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcblx0XHRcdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XG5cdFx0XHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XG5cblx0XHRcdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gX3VwZGF0ZUxheW91dCgpIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxuXHRcdFx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG5cblx0XHRcdFx0c3R5bGUud2lkdGggPSAnJztcblx0XHRcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuXG5cdFx0XHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcblx0XHRcdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcblx0XHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcblxuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgMSArICdweCc7XG5cdFx0XHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcblxuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSAnJztcblxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHRcdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXG5cdFx0XHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xuXG5cdFx0XHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHRhZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gX2FuaW1hdGVab29tKGUpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXG5cdFx0XHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblx0XHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FkanVzdFBhbjogZnVuY3Rpb24gX2FkanVzdFBhbigpIHtcblx0XHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbiB8fCB0aGlzLl9tYXAuX3BhbkFuaW0gJiYgdGhpcy5fbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHRcdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcblx0XHRcdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXG5cdFx0XHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxuXHRcdFx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XG5cblx0XHRcdFx0bGF5ZXJQb3MuX2FkZChnZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcblxuXHRcdFx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcblx0XHRcdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXG5cdFx0XHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXG5cdFx0XHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxuXHRcdFx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXG5cdFx0XHRcdCAgICBkeCA9IDAsXG5cdFx0XHRcdCAgICBkeSA9IDA7XG5cblx0XHRcdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkge1xuXHRcdFx0XHRcdC8vIHJpZ2h0XG5cdFx0XHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHtcblx0XHRcdFx0XHQvLyBsZWZ0XG5cdFx0XHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7XG5cdFx0XHRcdFx0Ly8gYm90dG9tXG5cdFx0XHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7XG5cdFx0XHRcdFx0Ly8gdG9wXG5cdFx0XHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXG5cdFx0XHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXG5cdFx0XHRcdGlmIChkeCB8fCBkeSkge1xuXHRcdFx0XHRcdG1hcC5maXJlKCdhdXRvcGFuc3RhcnQnKS5wYW5CeShbZHgsIGR5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIF9vbkNsb3NlQnV0dG9uQ2xpY2soZSkge1xuXHRcdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0XHRzdG9wKGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldEFuY2hvcjogZnVuY3Rpb24gX2dldEFuY2hvcigpIHtcblx0XHRcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBvcHVwXG5cdFx0Ly8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG5cdFx0Ly8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5cdFx0dmFyIHBvcHVwID0gZnVuY3Rpb24gcG9wdXAob3B0aW9ucywgc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XG5cdFx0fTtcblxuXHRcdC8qIEBuYW1lc3BhY2UgTWFwXHJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gICAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAgICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICAgKi9cblx0XHRNYXAubWVyZ2VPcHRpb25zKHtcblx0XHRcdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcblx0XHRNYXAuaW5jbHVkZSh7XG5cdFx0XHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXG5cdFx0XHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxuXHRcdFx0Ly8gQGFsdGVybmF0aXZlXG5cdFx0XHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxuXHRcdFx0b3BlblBvcHVwOiBmdW5jdGlvbiBvcGVuUG9wdXAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFx0XHRpZiAoIShwb3B1cCBpbnN0YW5jZW9mIFBvcHVwKSkge1xuXHRcdFx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0XHRcdHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcblx0XHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xuXHRcdFx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXG5cdFx0XHRjbG9zZVBvcHVwOiBmdW5jdGlvbiBjbG9zZVBvcHVwKHBvcHVwKSB7XG5cdFx0XHRcdGlmICghcG9wdXAgfHwgcG9wdXAgPT09IHRoaXMuX3BvcHVwKSB7XG5cdFx0XHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcblx0XHRcdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBvcHVwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cblxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcblx0XHRMYXllci5pbmNsdWRlKHtcblxuXHRcdFx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcblx0XHRcdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdFx0XHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHRcdFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdFx0XHRiaW5kUG9wdXA6IGZ1bmN0aW9uIGJpbmRQb3B1cChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRcdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBQb3B1cCkge1xuXHRcdFx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xuXHRcdFx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5vbih7XG5cdFx0XHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXG5cdFx0XHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xuXHRcdFx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxuXHRcdFx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uIHVuYmluZFBvcHVwKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdFx0XHR0aGlzLm9mZih7XG5cdFx0XHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXG5cdFx0XHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0XHRcdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdFx0XHRvcGVuUG9wdXA6IGZ1bmN0aW9uIG9wZW5Qb3B1cChsYXllciwgbGF0bG5nKSB7XG5cdFx0XHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG5cdFx0XHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWxhdGxuZykge1xuXHRcdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBwb3B1cCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAudXBkYXRlKCk7XG5cblx0XHRcdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXG5cdFx0XHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcblx0XHRcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRcdFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gY2xvc2VQb3B1cCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcblx0XHRcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdFx0XHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gdG9nZ2xlUG9wdXAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRcdFx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uIGlzUG9wdXBPcGVuKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xuXHRcdFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0XHRcdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gc2V0UG9wdXBDb250ZW50KGNvbnRlbnQpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcblx0XHRcdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdFx0XHRnZXRQb3B1cDogZnVuY3Rpb24gZ2V0UG9wdXAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wb3B1cDtcblx0XHRcdH0sXG5cblx0XHRcdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIF9vcGVuUG9wdXAoZSkge1xuXHRcdFx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmICghdGhpcy5fcG9wdXApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXG5cdFx0XHRcdHN0b3AoZSk7XG5cblx0XHRcdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxuXHRcdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXG5cdFx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGgpIHtcblx0XHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcblx0XHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxuXHRcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xuXHRcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIF9tb3ZlUG9wdXAoZSkge1xuXHRcdFx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIF9vbktleVByZXNzKGUpIHtcblx0XHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xuXHRcdFx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LypcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAgICogQGFrYSBMLlRvb2x0aXBcbiAgICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICAgKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAgICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gICAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gICAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gICAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAgICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gICAqL1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBUb29sdGlwXG5cdFx0dmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHRcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdFx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0XHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRcdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdFx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdFx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0XHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHRcdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRcdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0XHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0XHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0XHRcdG9wYWNpdHk6IDAuOVxuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuXHRcdFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0XHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0XHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHsgdG9vbHRpcDogdGhpcyB9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7IHRvb2x0aXA6IHRoaXMgfSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZShtYXApIHtcblx0XHRcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRcdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHsgdG9vbHRpcDogdGhpcyB9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHsgdG9vbHRpcDogdGhpcyB9LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiBnZXRFdmVudHMoKSB7XG5cdFx0XHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdFx0XHRpZiAodG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBldmVudHM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2xvc2U6IGZ1bmN0aW9uIF9jbG9zZSgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiBfaW5pdExheW91dCgpIHtcblx0XHRcdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdFx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gX3VwZGF0ZUxheW91dCgpIHt9LFxuXG5cdFx0XHRfYWRqdXN0UGFuOiBmdW5jdGlvbiBfYWRqdXN0UGFuKCkge30sXG5cblx0XHRcdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gX3NldFBvc2l0aW9uKHBvcykge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdFx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdFx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0XHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdFx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdFx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHRwb3MgPSBwb3MuYWRkKHRvUG9pbnQoLXRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgLXRvb2x0aXBIZWlnaHQgKyBvZmZzZXQueSArIGFuY2hvci55LCB0cnVlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55LCB0cnVlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbigpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIHNldE9wYWNpdHkob3BhY2l0eSkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gX2FuaW1hdGVab29tKGUpIHtcblx0XHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0XHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiBfZ2V0QW5jaG9yKCkge1xuXHRcdFx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0XHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuXHRcdC8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcblx0XHQvLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuXHRcdHZhciB0b29sdGlwID0gZnVuY3Rpb24gdG9vbHRpcChvcHRpb25zLCBzb3VyY2UpIHtcblx0XHRcdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xuXHRcdH07XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcblx0XHRNYXAuaW5jbHVkZSh7XG5cblx0XHRcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0XHRcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0XHRcdC8vIEBhbHRlcm5hdGl2ZVxuXHRcdFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHRcdFx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdFx0XHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gb3BlblRvb2x0aXAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0XHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0XHRcdHRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0XHRcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdFx0XHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uIGNsb3NlVG9vbHRpcCh0b29sdGlwKSB7XG5cdFx0XHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdFx0LypcbiAgICogQG5hbWVzcGFjZSBMYXllclxuICAgKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICAgKlxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICAgKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqL1xuXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5cdFx0TGF5ZXIuaW5jbHVkZSh7XG5cblx0XHRcdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdFx0XHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdFx0XHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHRcdFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdFx0XHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gYmluZFRvb2x0aXAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0XHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgVG9vbHRpcCkge1xuXHRcdFx0XHRcdHNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdFx0XHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHRcdFx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gdW5iaW5kVG9vbHRpcCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiBfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMocmVtb3ZlJCQxKSB7XG5cdFx0XHRcdGlmICghcmVtb3ZlJCQxICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBvbk9mZiA9IHJlbW92ZSQkMSA/ICdvZmYnIDogJ29uJyxcblx0XHRcdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodG91Y2gpIHtcblx0XHRcdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlJCQxO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdFx0XHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0XHRcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiBvcGVuVG9vbHRpcChsYXllciwgbGF0bG5nKSB7XG5cdFx0XHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG5cdFx0XHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWxhdGxuZykge1xuXHRcdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9tYXApIHtcblxuXHRcdFx0XHRcdC8vIHNldCB0b29sdGlwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIHRvb2x0aXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxuXHRcdFx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlKCk7XG5cblx0XHRcdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdFx0XHR0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCwgbGF0bG5nKTtcblxuXHRcdFx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0XHRcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG5cdFx0XHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uIGNsb3NlVG9vbHRpcCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdFx0XHR0aGlzLl90b29sdGlwLl9jbG9zZSgpO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdFx0XHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdFx0XHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiB0b2dnbGVUb29sdGlwKHRhcmdldCkge1xuXHRcdFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHRcdFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0XHRcdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uIGlzVG9vbHRpcE9wZW4oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0XHRcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0XHRcdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiBzZXRUb29sdGlwQ29udGVudChjb250ZW50KSB7XG5cdFx0XHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0XHRcdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0XHRcdGdldFRvb2x0aXA6IGZ1bmN0aW9uIGdldFRvb2x0aXAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHRcdFx0fSxcblxuXHRcdFx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiBfb3BlblRvb2x0aXAoZSkge1xuXHRcdFx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIF9tb3ZlVG9vbHRpcChlKSB7XG5cdFx0XHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZyxcblx0XHRcdFx0ICAgIGNvbnRhaW5lclBvaW50LFxuXHRcdFx0XHQgICAgbGF5ZXJQb2ludDtcblx0XHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcblx0XHRcdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgRGl2SWNvblxuICAgKiBAYWthIEwuRGl2SWNvblxuICAgKiBAaW5oZXJpdHMgSWNvblxuICAgKlxuICAgKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICAgKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAgICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAgICpcbiAgICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAgICovXG5cblx0XHR2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRcdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdFx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdFx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0XHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0XHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0XHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRcdFx0YmdQb3M6IG51bGwsXG5cblx0XHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0XHRcdH0sXG5cblx0XHRcdGNyZWF0ZUljb246IGZ1bmN0aW9uIGNyZWF0ZUljb24ob2xkSWNvbikge1xuXHRcdFx0XHR2YXIgZGl2ID0gb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gLWJnUG9zLnggKyAncHggJyArIC1iZ1Bvcy55ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdFx0XHRyZXR1cm4gZGl2O1xuXHRcdFx0fSxcblxuXHRcdFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiBjcmVhdGVTaGFkb3coKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcblx0XHQvLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5cdFx0ZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0SWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgR3JpZExheWVyXG4gICAqIEBpbmhlcml0cyBMYXllclxuICAgKiBAYWthIEwuR3JpZExheWVyXG4gICAqXG4gICAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAgICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICAgKlxuICAgKlxuICAgKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gICAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICpcbiAgICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAgICogICAgICAgICB2YXIgZXJyb3I7XG4gICAqXG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAgICogICAgICAgICB9LCAxMDAwKTtcbiAgICpcbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvblxuICAgKi9cblxuXHRcdHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHRcdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdFx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0XHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdFx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdFx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdFx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdFx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdFx0XHR1cGRhdGVXaGVuSWRsZTogbW9iaWxlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0XHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdFx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHRcdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHRcdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdFx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdFx0XHR6SW5kZXg6IDEsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdFx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0XHRcdGJvdW5kczogbnVsbCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHRcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0XHRcdG1pblpvb206IDAsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHRcdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdFx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHRcdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdFx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0XHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdFx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0XHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHRcdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdFx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdFx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0XHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0XHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0XHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0XHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0XHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRcdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHRcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0XHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0XHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRcdFx0a2VlcEJ1ZmZlcjogMlxuXHRcdFx0fSxcblxuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRpb25zKSB7XG5cdFx0XHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvbkFkZDogZnVuY3Rpb24gb25BZGQoKSB7XG5cdFx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdFx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHRcdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdFx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIGJlZm9yZUFkZChtYXApIHtcblx0XHRcdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvblJlbW92ZTogZnVuY3Rpb24gb25SZW1vdmUobWFwKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRcdF9yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0XHRcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0XHRcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gYnJpbmdUb0Zyb250KCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHRcdFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRcdFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uIGJyaW5nVG9CYWNrKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0XHRcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0XHRcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0XHRcdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRcdFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gc2V0T3BhY2l0eShvcGFjaXR5KSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHRcdFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRcdFx0c2V0WkluZGV4OiBmdW5jdGlvbiBzZXRaSW5kZXgoekluZGV4KSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0XHRcdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0XHRcdGlzTG9hZGluZzogZnVuY3Rpb24gaXNMb2FkaW5nKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdFx0XHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0XHRcdHJlZHJhdzogZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdGdldEV2ZW50czogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuXHRcdFx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGV2ZW50cztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdFx0XHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHRcdFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHRcdFx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRcdFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gY3JlYXRlVGlsZSgpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdFx0XHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0XHRcdGdldFRpbGVTaXplOiBmdW5jdGlvbiBnZXRUaWxlU2l6ZSgpIHtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0XHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gX3VwZGF0ZVpJbmRleCgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gX3NldEF1dG9aSW5kZXgoY29tcGFyZSkge1xuXHRcdFx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0XHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uIF91cGRhdGVPcGFjaXR5KCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdFx0XHRpZiAoaWVsdDkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdFx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHRcdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdFx0XHRfc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHtcblx0XHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X29uT3BhcXVlVGlsZTogZmFsc2VGbixcblxuXHRcdFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIF9pbml0Q29udGFpbmVyKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uIF91cGRhdGVMZXZlbHMoKSB7XG5cblx0XHRcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHRcdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdFx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfcmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHRcdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0XHRcdGxldmVsLmVsID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0ZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRcdFx0cmV0dXJuIGxldmVsO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uVXBkYXRlTGV2ZWw6IGZhbHNlRm4sXG5cblx0XHRcdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG5cdFx0XHRfb25DcmVhdGVMZXZlbDogZmFsc2VGbixcblxuXHRcdFx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uIF9wcnVuZVRpbGVzKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHRcdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdFx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gX3JlbW92ZVRpbGVzQXRab29tKHpvb20pIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gX3JlbW92ZUFsbFRpbGVzKCkge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiBfaW52YWxpZGF0ZUFsbCgpIHtcblx0XHRcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdFx0XHRfcmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHRcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiBfcmV0YWluUGFyZW50KHgsIHksIHosIG1pblpvb20pIHtcblx0XHRcdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0XHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdFx0XHQgICAgejIgPSB6IC0gMSxcblx0XHRcdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdFx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cblx0XHRcdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gX3JldGFpbkNoaWxkcmVuKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIF9yZXNldFZpZXcoZSkge1xuXHRcdFx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHRcdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gX2FuaW1hdGVab29tKGUpIHtcblx0XHRcdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0XHRcdH0sXG5cblx0XHRcdF9jbGFtcFpvb206IGZ1bmN0aW9uIF9jbGFtcFpvb20oem9vbSkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gem9vbTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRWaWV3OiBmdW5jdGlvbiBfc2V0VmlldyhjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbShNYXRoLnJvdW5kKHpvb20pKTtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgdGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSkge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdFx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdFx0XHRpZiAoYW55M2QpIHtcblx0XHRcdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXRHcmlkOiBmdW5jdGlvbiBfcmVzZXRHcmlkKCkge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHRcdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRcdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW01hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSwgTWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSldO1xuXHRcdFx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksIE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uIF9vbk1vdmVFbmQoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIF9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlcikge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdFx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHRcdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHRcdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0XHRcdF91cGRhdGU6IGZ1bmN0aW9uIF91cGRhdGUoY2VudGVyKSB7XG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0XHRcdGlmICghbWFwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSAvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHRcdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdFx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0XHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdFx0XHQgICAgcXVldWUgPSBbXSxcblx0XHRcdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdFx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSwgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHRcdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG5cdFx0XHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiYgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJiBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdFx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdFx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHtcblx0XHRcdFx0XHR0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0XHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0XHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gX2lzVmFsaWRUaWxlKGNvb3Jkcykge1xuXHRcdFx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0XHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0XHRcdGlmICghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSB8fCAhY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIF9rZXlUb0JvdW5kcyhrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSB7XG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHRcdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0XHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdFx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHRcdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0XHRcdHJldHVybiBbbncsIHNlXTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0XHRcdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIF90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKSB7XG5cdFx0XHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHRcdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdFx0XHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiBfdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcykge1xuXHRcdFx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0XHRcdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIF9rZXlUb1RpbGVDb29yZHMoa2V5KSB7XG5cdFx0XHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0XHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRcdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRcdFx0cmV0dXJuIGNvb3Jkcztcblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiBfcmVtb3ZlVGlsZShrZXkpIHtcblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0XHRpZiAoIXRpbGUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXG5cdFx0XHRcdC8vIHVubGVzcyB3ZSdyZSBvbiBBbmRyb2lkJ3Mgc3RvY2sgYnJvd3Nlcixcblx0XHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xuXHRcdFx0XHRpZiAoIWFuZHJvaWRTdG9jaykge1xuXHRcdFx0XHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHRcdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdF9pbml0VGlsZTogZnVuY3Rpb24gX2luaXRUaWxlKHRpbGUpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0XHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRcdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdFx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0XHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG5cdFx0XHRcdHRpbGUub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0XHRcdGlmIChpZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdFx0XHRfc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcblx0XHRcdFx0aWYgKGFuZHJvaWQgJiYgIWFuZHJvaWQyMykge1xuXHRcdFx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9hZGRUaWxlOiBmdW5jdGlvbiBfYWRkVGlsZShjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdFx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHRcdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0XHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0XHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0XHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRcdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0XHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdGlsZVJlYWR5OiBmdW5jdGlvbiBfdGlsZVJlYWR5KGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbWFwIHx8IHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRcdGlmICghdGlsZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghZXJyKSB7XG5cdFx0XHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0XHRcdGlmIChpZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIF9nZXRUaWxlUG9zKGNvb3Jkcykge1xuXHRcdFx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHRcdFx0fSxcblxuXHRcdFx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIF93cmFwQ29vcmRzKGNvb3Jkcykge1xuXHRcdFx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KHRoaXMuX3dyYXBYID8gd3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsIHRoaXMuX3dyYXBZID8gd3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdFx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdFx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHRcdFx0fSxcblxuXHRcdFx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIF9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcykge1xuXHRcdFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0XHRcdHJldHVybiBuZXcgQm91bmRzKGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLCBib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uIF9ub1RpbGVzVG9Mb2FkKCkge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuXHRcdC8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5cdFx0ZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllclxyXG4gICAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJ30pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuXG5cdFx0dmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xuXG5cdFx0XHQvLyBAc2VjdGlvblxuXHRcdFx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHRcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0XHRcdG1pblpvb206IDAsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxuXHRcdFx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0XHRcdG1heFpvb206IDE4LFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcblx0XHRcdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cdFx0XHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xuXHRcdFx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxuXHRcdFx0XHRlcnJvclRpbGVVcmw6ICcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxuXHRcdFx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxuXHRcdFx0XHR6b29tT2Zmc2V0OiAwLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXG5cdFx0XHRcdHRtczogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcblx0XHRcdFx0em9vbVJldmVyc2U6IGZhbHNlLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXG5cdFx0XHRcdGRldGVjdFJldGluYTogZmFsc2UsXG5cblx0XHRcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxuXHRcdFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXG5cdFx0XHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cblx0XHRcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cblx0XHRcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKHVybCwgb3B0aW9ucykge1xuXG5cdFx0XHRcdHRoaXMuX3VybCA9IHVybDtcblxuXHRcdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHRcdFx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXG5cdFx0XHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiByZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xuXG5cdFx0XHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xuXG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcblx0XHRcdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcblx0XHRcdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xuXHRcdFx0XHRpZiAoIWFuZHJvaWQpIHtcblx0XHRcdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcblx0XHRcdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cblx0XHRcdHNldFVybDogZnVuY3Rpb24gc2V0VXJsKHVybCwgbm9SZWRyYXcpIHtcblx0XHRcdFx0dGhpcy5fdXJsID0gdXJsO1xuXG5cdFx0XHRcdGlmICghbm9SZWRyYXcpIHtcblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHRcdFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxuXHRcdFx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxuXHRcdFx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxuXHRcdFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gY3JlYXRlVGlsZShjb29yZHMsIGRvbmUpIHtcblx0XHRcdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuXHRcdFx0XHRvbih0aWxlLCAnbG9hZCcsIGJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xuXHRcdFx0XHRvbih0aWxlLCAnZXJyb3InLCBiaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XG5cdFx0XHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LypcclxuICAgICBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcbiAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG4gICAgKi9cblx0XHRcdFx0dGlsZS5hbHQgPSAnJztcblxuXHRcdFx0XHQvKlxyXG4gICAgIFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuICAgICBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuICAgICovXG5cdFx0XHRcdHRpbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuXG5cdFx0XHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XG5cblx0XHRcdFx0cmV0dXJuIHRpbGU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHRcdFx0Ly8gQHVuaW5oZXJpdGFibGVcblx0XHRcdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdFx0XHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcblx0XHRcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cblx0XHRcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxuXHRcdFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gZ2V0VGlsZVVybChjb29yZHMpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0cjogcmV0aW5hID8gJ0AyeCcgOiAnJyxcblx0XHRcdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcblx0XHRcdFx0XHR4OiBjb29yZHMueCxcblx0XHRcdFx0XHR5OiBjb29yZHMueSxcblx0XHRcdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XG5cdFx0XHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gX3RpbGVPbkxvYWQoZG9uZSwgdGlsZSkge1xuXHRcdFx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxuXHRcdFx0XHRpZiAoaWVsdDkpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF90aWxlT25FcnJvcjogZnVuY3Rpb24gX3RpbGVPbkVycm9yKGRvbmUsIHRpbGUsIGUpIHtcblx0XHRcdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcblx0XHRcdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcblx0XHRcdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvbmUoZSwgdGlsZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiBfb25UaWxlUmVtb3ZlKGUpIHtcblx0XHRcdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gX2dldFpvb21Gb3JVcmwoKSB7XG5cdFx0XHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0XHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXG5cdFx0XHRcdCAgICB6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcblx0XHRcdFx0ICAgIHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcblxuXHRcdFx0XHRpZiAoem9vbVJldmVyc2UpIHtcblx0XHRcdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiBfZ2V0U3ViZG9tYWluKHRpbGVQb2ludCkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXG5cdFx0XHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiBfYWJvcnRMb2FkaW5nKCkge1xuXHRcdFx0XHR2YXIgaSwgdGlsZTtcblx0XHRcdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xuXHRcdFx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xuXG5cdFx0XHRcdFx0XHR0aWxlLm9ubG9hZCA9IGZhbHNlRm47XG5cdFx0XHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBmYWxzZUZuO1xuXG5cdFx0XHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlKHRpbGUpO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXG5cdFx0Ly8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cblxuXHRcdGZ1bmN0aW9uIHRpbGVMYXllcih1cmwsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0LypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gICAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gICAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gICAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gICAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICAgKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXG5cblx0XHR2YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XG5cblx0XHRcdC8vIEBzZWN0aW9uXG5cdFx0XHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xuXHRcdFx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxuXHRcdFx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3Jcblx0XHRcdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXG5cdFx0XHRkZWZhdWx0V21zUGFyYW1zOiB7XG5cdFx0XHRcdHNlcnZpY2U6ICdXTVMnLFxuXHRcdFx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcblx0XHRcdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxuXHRcdFx0XHRsYXllcnM6ICcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xuXHRcdFx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxuXHRcdFx0XHRzdHlsZXM6ICcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcblx0XHRcdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXG5cdFx0XHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxuXG5cdFx0XHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcblx0XHRcdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXG5cdFx0XHRcdHZlcnNpb246ICcxLjEuMSdcblx0XHRcdH0sXG5cblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcblx0XHRcdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cblx0XHRcdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXG5cdFx0XHRcdGNyczogbnVsbCxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXG5cdFx0XHRcdHVwcGVyY2FzZTogZmFsc2Vcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUodXJsLCBvcHRpb25zKSB7XG5cblx0XHRcdFx0dGhpcy5fdXJsID0gdXJsO1xuXG5cdFx0XHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XG5cblx0XHRcdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XG5cdFx0XHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDE7XG5cdFx0XHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRcdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XG5cdFx0XHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcblxuXHRcdFx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcblx0XHRcdH0sXG5cblx0XHRcdG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcblxuXHRcdFx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcblx0XHRcdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XG5cblx0XHRcdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XG5cdFx0XHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XG5cblx0XHRcdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRUaWxlVXJsOiBmdW5jdGlvbiBnZXRUaWxlVXJsKGNvb3Jkcykge1xuXG5cdFx0XHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuXHRcdFx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxuXHRcdFx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcblx0XHRcdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXG5cdFx0XHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxuXHRcdFx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID8gW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6IFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcblx0XHRcdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XG5cdFx0XHRcdHJldHVybiB1cmwgKyBnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArICh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcblx0XHRcdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cblx0XHRcdHNldFBhcmFtczogZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgbm9SZWRyYXcpIHtcblxuXHRcdFx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XG5cblx0XHRcdFx0aWYgKCFub1JlZHJhdykge1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcblx0XHQvLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXG5cdFx0ZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRUaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xuXHRcdHRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgUmVuZGVyZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5SZW5kZXJlclxuICAgKlxuICAgKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICAgKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICAgKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAgICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICAgKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gICAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gICAqL1xuXG5cdFx0dmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHRcdFx0Ly8gQHNlY3Rpb25cblx0XHRcdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHRcdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0XHRcdHBhZGRpbmc6IDAuMSxcblxuXHRcdFx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdFx0XHR0b2xlcmFuY2U6IDBcblx0XHRcdH0sXG5cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucykge1xuXHRcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0XHRzdGFtcCh0aGlzKTtcblx0XHRcdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHRcdFx0fSxcblxuXHRcdFx0b25BZGQ6IGZ1bmN0aW9uIG9uQWRkKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdFx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvblJlbW92ZTogZnVuY3Rpb24gb25SZW1vdmUoKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0XHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0XHRcdH0sXG5cblx0XHRcdGdldEV2ZW50czogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuXHRcdFx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdFx0XHR6b29tZW5kOiB0aGlzLl9vblpvb21FbmRcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGV2ZW50cztcblx0XHRcdH0sXG5cblx0XHRcdF9vbkFuaW1ab29tOiBmdW5jdGlvbiBfb25BbmltWm9vbShldikge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vblpvb206IGZ1bmN0aW9uIF9vblpvb20oKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gX3VwZGF0ZVRyYW5zZm9ybShjZW50ZXIsIHpvb20pIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcblx0XHRcdFx0ICAgIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHRcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHRcdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0XHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdFx0XHQgICAgY2VudGVyT2Zmc2V0ID0gZGVzdENlbnRlclBvaW50LnN1YnRyYWN0KGN1cnJlbnRDZW50ZXJQb2ludCksXG5cdFx0XHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0XHRcdGlmIChhbnkzZCkge1xuXHRcdFx0XHRcdHNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXQ6IGZ1bmN0aW9uIF9yZXNldCgpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9vblpvb21FbmQ6IGZ1bmN0aW9uIF9vblpvb21FbmQoKSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiBfdXBkYXRlUGF0aHMoKSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuXHRcdFx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHRcdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cblx0XHRcdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHRcdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdFx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHRcdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxuICAgKiBAY2xhc3MgQ2FudmFzXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuQ2FudmFzXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAgICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cblx0XHR2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblx0XHRcdGdldEV2ZW50czogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuXHRcdFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdFx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0XHRcdHJldHVybiBldmVudHM7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uIF9vblZpZXdQcmVSZXNldCgpIHtcblx0XHRcdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHRvbkFkZDogZnVuY3Rpb24gb25BZGQoKSB7XG5cdFx0XHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHRcdFx0dGhpcy5fZHJhdygpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIF9pbml0Q29udGFpbmVyKCkge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHRcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcyk7XG5cdFx0XHRcdG9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0XHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uIF9kZXN0cm95Q29udGFpbmVyKCkge1xuXHRcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG5cdFx0XHRcdF9yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uIF91cGRhdGVQYXRocygpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbGF5ZXI7XG5cdFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmVkcmF3KCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2RyYXduTGF5ZXJzID0ge307XG5cblx0XHRcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdFx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHRcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHRcdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHRcdFx0ICAgIG0gPSByZXRpbmEgPyAyIDogMTtcblxuXHRcdFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0XHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0XHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdFx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdFx0XHRpZiAocmV0aW5hKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0XHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdFx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0XHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXQ6IGZ1bmN0aW9uIF9yZXNldCgpIHtcblx0XHRcdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9pbml0UGF0aDogZnVuY3Rpb24gX2luaXRQYXRoKGxheWVyKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0XHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHRcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0XHRcdGxheWVyOiBsYXllcixcblx0XHRcdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdFx0XHRuZXh0OiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICh0aGlzLl9kcmF3TGFzdCkge1xuXHRcdFx0XHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkUGF0aDogZnVuY3Rpb24gX2FkZFBhdGgobGF5ZXIpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gX3JlbW92ZVBhdGgobGF5ZXIpIHtcblx0XHRcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0XHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2KSB7XG5cdFx0XHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXTtcblxuXHRcdFx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblxuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiBfdXBkYXRlUGF0aChsYXllcikge1xuXHRcdFx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdFx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdFx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0XHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHRcdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHRcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIF91cGRhdGVTdHlsZShsYXllcikge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIF91cGRhdGVEYXNoQXJyYXkobGF5ZXIpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgnLCcpLFxuXHRcdFx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdFx0XHQgICAgaTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGRhc2hBcnJheS5wdXNoKE51bWJlcihwYXJ0c1tpXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiBfcmVxdWVzdFJlZHJhdyhsYXllcikge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0XHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIF9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpIHtcblx0XHRcdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuXHRcdFx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHRcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVkcmF3OiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuXHRcdFx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdFx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdFx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdF9jbGVhcjogZnVuY3Rpb24gX2NsZWFyKCkge1xuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdFx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9kcmF3OiBmdW5jdGlvbiBfZHJhdygpIHtcblx0XHRcdFx0dmFyIGxheWVyLFxuXHRcdFx0XHQgICAgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdFx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRcdFx0aWYgKCFib3VuZHMgfHwgbGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7IC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIF91cGRhdGVQb2x5KGxheWVyLCBjbG9zZWQpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdCAgICBqLFxuXHRcdFx0XHQgICAgbGVuMixcblx0XHRcdFx0ICAgIHAsXG5cdFx0XHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHRcdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHRcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdFx0XHRpZiAoIWxlbikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHRcdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiBfdXBkYXRlQ2lyY2xlKGxheWVyKSB7XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0XHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0XHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0XHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRcdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRcdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRcdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiBfZmlsbFN0cm9rZShjdHgsIGxheWVyKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHRcdFx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0XHRcdF9vbkNsaWNrOiBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLFxuXHRcdFx0XHQgICAgbGF5ZXIsXG5cdFx0XHRcdCAgICBjbGlja2VkTGF5ZXI7XG5cblx0XHRcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xpY2tlZExheWVyKSB7XG5cdFx0XHRcdFx0ZmFrZVN0b3AoZSk7XG5cdFx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiBfb25Nb3VzZU1vdmUoZSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiBfaGFuZGxlTW91c2VPdXQoZSkge1xuXHRcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0XHRcdGlmIChsYXllcikge1xuXHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpIHtcblx0XHRcdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cblx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfZmlyZUV2ZW50OiBmdW5jdGlvbiBfZmlyZUV2ZW50KGxheWVycywgZSwgdHlwZSkge1xuXHRcdFx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIF9icmluZ1RvRnJvbnQobGF5ZXIpIHtcblx0XHRcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0XHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2KSB7XG5cdFx0XHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0XHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcblx0XHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0XHRcdH0sXG5cblx0XHRcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gX2JyaW5nVG9CYWNrKGxheWVyKSB7XG5cdFx0XHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHRcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRcdFx0aWYgKHByZXYpIHtcblx0XHRcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcmRlci5wcmV2ID0gbnVsbDtcblxuXHRcdFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdFx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBvcmRlcjtcblxuXHRcdFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuXHRcdC8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cblx0XHRmdW5jdGlvbiBjYW52YXMkMShvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0LypcbiAgICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAgICovXG5cblx0XHR2YXIgdm1sQ3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHRcdFx0fTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0oKTtcblxuXHRcdC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAqL1xuXG5cdFx0Ly8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcblx0XHR2YXIgdm1sTWl4aW4gPSB7XG5cblx0XHRcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiBfaW5pdENvbnRhaW5lcigpIHtcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0XHRcdH0sXG5cblx0XHRcdF91cGRhdGU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHRcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0XHRcdH0sXG5cblx0XHRcdF9pbml0UGF0aDogZnVuY3Rpb24gX2luaXRQYXRoKGxheWVyKSB7XG5cdFx0XHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0XHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0XHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHRcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdH0sXG5cblx0XHRcdF9hZGRQYXRoOiBmdW5jdGlvbiBfYWRkUGF0aChsYXllcikge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gX3JlbW92ZVBhdGgobGF5ZXIpIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0XHRcdF9yZW1vdmUoY29udGFpbmVyKTtcblx0XHRcdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiBfdXBkYXRlU3R5bGUobGF5ZXIpIHtcblx0XHRcdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0XHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0XHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHRcdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdFx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBpc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/IG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6IG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiBfdXBkYXRlQ2lyY2xlKGxheWVyKSB7XG5cdFx0XHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0XHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHRcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6ICdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyA2NTUzNSAqIDM2MCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfc2V0UGF0aDogZnVuY3Rpb24gX3NldFBhdGgobGF5ZXIsIHBhdGgpIHtcblx0XHRcdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiBfYnJpbmdUb0Zyb250KGxheWVyKSB7XG5cdFx0XHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIF9icmluZ1RvQmFjayhsYXllcikge1xuXHRcdFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBjcmVhdGUkMiA9IHZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuXHRcdC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5TVkdcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAgICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAgICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICAgKiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuXHRcdHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdFx0XHRnZXRFdmVudHM6IGZ1bmN0aW9uIGdldEV2ZW50cygpIHtcblx0XHRcdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRcdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gZXZlbnRzO1xuXHRcdFx0fSxcblxuXHRcdFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIF9pbml0Q29udGFpbmVyKCkge1xuXHRcdFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMignc3ZnJyk7XG5cblx0XHRcdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdFx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUkMignZycpO1xuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0XHRcdH0sXG5cblx0XHRcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiBfZGVzdHJveUNvbnRhaW5lcigpIHtcblx0XHRcdFx0X3JlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uIF9vblpvb21TdGFydCgpIHtcblx0XHRcdFx0Ly8gRHJhZy10aGVuLXBpbmNoIGludGVyYWN0aW9ucyBtaWdodCBtZXNzIHVwIHRoZSBjZW50ZXIgYW5kIHpvb20uXG5cdFx0XHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHRcdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0XHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHRcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHRcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRfaW5pdFBhdGg6IGZ1bmN0aW9uIF9pbml0UGF0aChsYXllcikge1xuXHRcdFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlJDIoJ3BhdGgnKTtcblxuXHRcdFx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHRcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHRcdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FkZFBhdGg6IGZ1bmN0aW9uIF9hZGRQYXRoKGxheWVyKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiBfcmVtb3ZlUGF0aChsYXllcikge1xuXHRcdFx0XHRfcmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRcdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gX3VwZGF0ZVBhdGgobGF5ZXIpIHtcblx0XHRcdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiBfdXBkYXRlU3R5bGUobGF5ZXIpIHtcblx0XHRcdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHRcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0XHRcdGlmICghcGF0aCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIF91cGRhdGVQb2x5KGxheWVyLCBjbG9zZWQpIHtcblx0XHRcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiBfdXBkYXRlQ2lyY2xlKGxheWVyKSB7XG5cdFx0XHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdFx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdFx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHRcdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdFx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdFx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDogJ00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICsgYXJjICsgciAqIDIgKyAnLDAgJyArIGFyYyArIC1yICogMiArICcsMCAnO1xuXG5cdFx0XHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldFBhdGg6IGZ1bmN0aW9uIF9zZXRQYXRoKGxheWVyLCBwYXRoKSB7XG5cdFx0XHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdFx0XHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiBfYnJpbmdUb0Zyb250KGxheWVyKSB7XG5cdFx0XHRcdHRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiBfYnJpbmdUb0JhY2sobGF5ZXIpIHtcblx0XHRcdFx0dG9CYWNrKGxheWVyLl9wYXRoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICh2bWwpIHtcblx0XHRcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcblx0XHR9XG5cblx0XHQvLyBAbmFtZXNwYWNlIFNWR1xuXHRcdC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuXHRcdC8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cblx0XHRmdW5jdGlvbiBzdmckMShvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gc3ZnIHx8IHZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xuXHRcdH1cblxuXHRcdE1hcC5pbmNsdWRlKHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0XHRcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdFx0XHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHRcdFx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRcdFx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIGdldFJlbmRlcmVyKGxheWVyKSB7XG5cdFx0XHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHRcdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdFx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHRcdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRcdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZW5kZXJlcjtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIF9nZXRQYW5lUmVuZGVyZXIobmFtZSkge1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdFx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoeyBwYW5lOiBuYW1lIH0pO1xuXHRcdFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIF9jcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG5cdFx0XHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0XHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyQxKG9wdGlvbnMpIHx8IHN2ZyQxKG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LypcbiAgICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAgICovXG5cblx0XHQvKlxuICAgKiBAY2xhc3MgUmVjdGFuZ2xlXG4gICAqIEBha2EgTC5SZWN0YW5nbGVcbiAgICogQGluaGVyaXRzIFBvbHlnb25cbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gICAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gICAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG5cdFx0dmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0XHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0XHRcdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRcdFx0c2V0Qm91bmRzOiBmdW5jdGlvbiBzZXRCb3VuZHMobGF0TG5nQm91bmRzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpIHtcblx0XHRcdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRcdFx0cmV0dXJuIFtsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgbGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCBsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCldO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuXHRcdGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0U1ZHLmNyZWF0ZSA9IGNyZWF0ZSQyO1xuXHRcdFNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cblx0XHRHZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcblx0XHRHZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5cdFx0R2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5cdFx0R2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuXHRcdEdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuXHRcdEdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5cdFx0R2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5cblx0XHQvKlxuICAgKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICAgKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblx0XHRNYXAubWVyZ2VPcHRpb25zKHtcblx0XHRcdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0XHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0XHRcdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRcdFx0Ym94Wm9vbTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0dmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG1hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdFx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdFx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0YWRkSG9va3M6IGZ1bmN0aW9uIGFkZEhvb2tzKCkge1xuXHRcdFx0XHRvbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVIb29rczogZnVuY3Rpb24gcmVtb3ZlSG9va3MoKSB7XG5cdFx0XHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRtb3ZlZDogZnVuY3Rpb24gbW92ZWQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0XHRcdH0sXG5cblx0XHRcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcblx0XHRcdFx0X3JlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gX3Jlc2V0U3RhdGUoKSB7XG5cdFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHRcdH0sXG5cblx0XHRcdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiBfb25Nb3VzZURvd24oZSkge1xuXHRcdFx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgZS53aGljaCAhPT0gMSAmJiBlLmJ1dHRvbiAhPT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdFx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdFx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRcdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdFx0XHRvbihkb2N1bWVudCwge1xuXHRcdFx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuXHRcdFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gX29uTW91c2VNb3ZlKGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRoaXMuX2JveCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0XHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHRcdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHRcdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRcdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZmluaXNoOiBmdW5jdGlvbiBfZmluaXNoKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdFx0XHRfcmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHRcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHRcdFx0b2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG5cdFx0XHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uTW91c2VVcDogZnVuY3Rpb24gX29uTW91c2VVcChlKSB7XG5cdFx0XHRcdGlmIChlLndoaWNoICE9PSAxICYmIGUuYnV0dG9uICE9PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHRcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0XHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLCB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0XHRcdHRoaXMuX21hcC5maXRCb3VuZHMoYm91bmRzKS5maXJlKCdib3h6b29tZW5kJywgeyBib3hab29tQm91bmRzOiBib3VuZHMgfSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25LZXlEb3duOiBmdW5jdGlvbiBfb25LZXlEb3duKGUpIHtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQHNlY3Rpb24gSGFuZGxlcnNcblx0XHQvLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuXHRcdC8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5cdFx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcblxuXHRcdC8qXG4gICAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5cdFx0TWFwLm1lcmdlT3B0aW9ucyh7XG5cdFx0XHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdFx0XHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0XHRcdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHRcdFx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRcdFx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG5cdFx0fSk7XG5cblx0XHR2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRcdFx0YWRkSG9va3M6IGZ1bmN0aW9uIGFkZEhvb2tzKCkge1xuXHRcdFx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVIb29rczogZnVuY3Rpb24gcmVtb3ZlSG9va3MoKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gX29uRG91YmxlQ2xpY2soZSkge1xuXHRcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0XHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHRcdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQHNlY3Rpb24gSGFuZGxlcnNcblx0XHQvL1xuXHRcdC8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuXHRcdC8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcblx0XHQvLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcblx0XHQvL1xuXHRcdC8vIGBgYGpzXG5cdFx0Ly8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG5cdFx0Ly8gYGBgXG5cdFx0Ly9cblx0XHQvLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG5cdFx0Ly8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cblx0XHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuXHRcdC8qXG4gICAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cdFx0TWFwLm1lcmdlT3B0aW9ucyh7XG5cdFx0XHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdFx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0XHRcdGRyYWdnaW5nOiB0cnVlLFxuXG5cdFx0XHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHRcdFx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHRcdFx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHRcdFx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0XHRcdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0XHRcdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRcdFx0aW5lcnRpYTogIWFuZHJvaWQyMyxcblxuXHRcdFx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdFx0XHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdFx0XHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHRcdFx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdFx0XHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRcdFx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdFx0XHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRcdFx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdFx0XHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHRcdFx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0XHRcdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdFx0XHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdFx0XHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHRcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHRcdFx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0XHRcdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdFx0XHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdFx0XHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHRcdFx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdFx0XHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxuXHRcdH0pO1xuXG5cdFx0dmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdFx0XHRhZGRIb29rczogZnVuY3Rpb24gYWRkSG9va3MoKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVIb29rczogZnVuY3Rpb24gcmVtb3ZlSG9va3MoKSB7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRtb3ZlZDogZnVuY3Rpb24gbW92ZWQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0XHRcdH0sXG5cblx0XHRcdG1vdmluZzogZnVuY3Rpb24gbW92aW5nKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoKSB7XG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdFx0bWFwLl9zdG9wKCk7XG5cdFx0XHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksIHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSkuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZXN0YXJ0JykuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25EcmFnOiBmdW5jdGlvbiBfb25EcmFnKGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fbWFwLmZpcmUoJ21vdmUnLCBlKS5maXJlKCdkcmFnJywgZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uIF9wcnVuZVBvc2l0aW9ucyh0aW1lKSB7XG5cdFx0XHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9vblpvb21FbmQ6IGZ1bmN0aW9uIF9vblpvb21FbmQoKSB7XG5cdFx0XHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0XHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0XHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0XHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHRcdFx0fSxcblxuXHRcdFx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gX3Zpc2NvdXNMaW1pdCh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uIF9vblByZURyYWdMaW1pdCgpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0XHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdFx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkge1xuXHRcdFx0XHRcdG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHtcblx0XHRcdFx0XHRvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7XG5cdFx0XHRcdFx0b2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkge1xuXHRcdFx0XHRcdG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gX29uUHJlRHJhZ1dyYXAoKSB7XG5cdFx0XHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdFx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0XHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHRcdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdFx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0XHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdFx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHRcdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gX29uRHJhZ0VuZChlKSB7XG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cdFx0XHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRcdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdFx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cblx0XHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cdFx0XHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cdFx0XHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXHRcdFx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBAc2VjdGlvbiBIYW5kbGVyc1xuXHRcdC8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuXHRcdC8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5cdFx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cblx0XHQvKlxuICAgKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuXHRcdE1hcC5tZXJnZU9wdGlvbnMoe1xuXHRcdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0XHRcdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdFx0XHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0XHRcdGtleWJvYXJkOiB0cnVlLFxuXG5cdFx0XHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdFx0XHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0XHRcdGtleWJvYXJkUGFuRGVsdGE6IDgwXG5cdFx0fSk7XG5cblx0XHR2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0XHRcdGtleUNvZGVzOiB7XG5cdFx0XHRcdGxlZnQ6IFszN10sXG5cdFx0XHRcdHJpZ2h0OiBbMzldLFxuXHRcdFx0XHRkb3duOiBbNDBdLFxuXHRcdFx0XHR1cDogWzM4XSxcblx0XHRcdFx0em9vbUluOiBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdFx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG1hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHRcdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0XHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHRcdFx0fSxcblxuXHRcdFx0YWRkSG9va3M6IGZ1bmN0aW9uIGFkZEhvb2tzKCkge1xuXHRcdFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHRcdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0XHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uIHJlbW92ZUhvb2tzKCkge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0XHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gX29uTW91c2VEb3duKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZm9jdXNlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHRcdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdFx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0XHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHRcdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Gb2N1czogZnVuY3Rpb24gX29uRm9jdXMoKSB7XG5cdFx0XHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbkJsdXI6IGZ1bmN0aW9uIF9vbkJsdXIoKSB7XG5cdFx0XHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gX3NldFBhbkRlbHRhKHBhbkRlbHRhKSB7XG5cdFx0XHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdFx0XHQgICAgaSxcblx0XHRcdFx0ICAgIGxlbjtcblxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gX3NldFpvb21EZWx0YSh6b29tRGVsdGEpIHtcblx0XHRcdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdFx0XHQgICAgaSxcblx0XHRcdFx0ICAgIGxlbjtcblxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRfYWRkSG9va3M6IGZ1bmN0aW9uIF9hZGRIb29rcygpIHtcblx0XHRcdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9yZW1vdmVIb29rczogZnVuY3Rpb24gX3JlbW92ZUhvb2tzKCkge1xuXHRcdFx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbktleURvd246IGZ1bmN0aW9uIF9vbktleURvd24oZSkge1xuXHRcdFx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0XHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdCAgICBvZmZzZXQ7XG5cblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdG9wKGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQHNlY3Rpb24gSGFuZGxlcnNcblx0XHQvLyBAc2VjdGlvbiBIYW5kbGVyc1xuXHRcdC8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuXHRcdC8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cblx0XHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG5cblx0XHQvKlxuICAgKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gICAqL1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cdFx0TWFwLm1lcmdlT3B0aW9ucyh7XG5cdFx0XHQvLyBAc2VjdGlvbiBNb3VzZXdoZWVsIG9wdGlvbnNcblx0XHRcdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0XHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdFx0XHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdFx0XHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0XHRcdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdFx0XHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHRcdFx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdFx0XHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0XHRcdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0XHRcdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0XHRcdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0XHRcdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHRcdFx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcblx0XHR9KTtcblxuXHRcdHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdFx0XHRhZGRIb29rczogZnVuY3Rpb24gYWRkSG9va3MoKSB7XG5cdFx0XHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiByZW1vdmVIb29rcygpIHtcblx0XHRcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIF9vbldoZWVsU2Nyb2xsKGUpIHtcblx0XHRcdFx0dmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdFx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdFx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHRcdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0XHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHRcdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdFx0XHRzdG9wKGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiBfcGVyZm9ybVpvb20oKSB7XG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHRcdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0XHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0XHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdFx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0XHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0XHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHRcdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdFx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKCFkZWx0YSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBzZWN0aW9uIEhhbmRsZXJzXG5cdFx0Ly8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuXHRcdC8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5cdFx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cblx0XHQvKlxuICAgKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICAgKi9cblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXHRcdE1hcC5tZXJnZU9wdGlvbnMoe1xuXHRcdFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHRcdFx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdFx0XHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHRcdFx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHRcdFx0dGFwOiB0cnVlLFxuXG5cdFx0XHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0XHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdFx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0XHRcdHRhcFRvbGVyYW5jZTogMTVcblx0XHR9KTtcblxuXHRcdHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdFx0XHRhZGRIb29rczogZnVuY3Rpb24gYWRkSG9va3MoKSB7XG5cdFx0XHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVIb29rczogZnVuY3Rpb24gcmVtb3ZlSG9va3MoKSB7XG5cdFx0XHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uRG93bjogZnVuY3Rpb24gX29uRG93bihlKSB7XG5cdFx0XHRcdGlmICghZS50b3VjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XG5cblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRcdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdFx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdFx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHRcdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0XHRcdG9uKGRvY3VtZW50LCB7XG5cdFx0XHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25VcDogZnVuY3Rpb24gX29uVXAoZSkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0XHRcdG9mZihkb2N1bWVudCwge1xuXHRcdFx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uIF9pc1RhcFZhbGlkKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0XHRcdH0sXG5cblx0XHRcdF9vbk1vdmU6IGZ1bmN0aW9uIF9vbk1vdmUoZSkge1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0XHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uIF9zaW11bGF0ZUV2ZW50KHR5cGUsIGUpIHtcblx0XHRcdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRcdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0XHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRcdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCBlLnNjcmVlblgsIGUuc2NyZWVuWSwgZS5jbGllbnRYLCBlLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdFx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBzZWN0aW9uIEhhbmRsZXJzXG5cdFx0Ly8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuXHRcdC8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuXHRcdGlmICh0b3VjaCAmJiAhcG9pbnRlcikge1xuXHRcdFx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIFRhcCk7XG5cdFx0fVxuXG5cdFx0LypcbiAgICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gICAqL1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cdFx0TWFwLm1lcmdlT3B0aW9ucyh7XG5cdFx0XHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdFx0XHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHRcdFx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0XHRcdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdFx0XHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0XHRcdHRvdWNoWm9vbTogdG91Y2ggJiYgIWFuZHJvaWQyMyxcblxuXHRcdFx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0XHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0XHRcdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0XHRcdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0dmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0XHRcdGFkZEhvb2tzOiBmdW5jdGlvbiBhZGRIb29rcygpIHtcblx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHRcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiByZW1vdmVIb29rcygpIHtcblx0XHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHRcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiBfb25Ub3VjaFN0YXJ0KGUpIHtcblx0XHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdFx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdFx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRcdFx0bWFwLl9zdG9wKCk7XG5cblx0XHRcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0XHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gX29uVG91Y2hNb3ZlKGUpIHtcblx0XHRcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHRcdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHRcdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRcdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSB8fCB0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSB7XG5cdFx0XHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdFx0XHRpZiAoc2NhbGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRcdFx0dmFyIG1vdmVGbiA9IGJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwgeyBwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlIH0pO1xuXHRcdFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiBfb25Ub3VjaEVuZCgpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuXHRcdFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0XHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0XHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEBzZWN0aW9uIEhhbmRsZXJzXG5cdFx0Ly8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuXHRcdC8vIFRvdWNoIHpvb20gaGFuZGxlci5cblx0XHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuXHRcdE1hcC5Cb3hab29tID0gQm94Wm9vbTtcblx0XHRNYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuXHRcdE1hcC5EcmFnID0gRHJhZztcblx0XHRNYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcblx0XHRNYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuXHRcdE1hcC5UYXAgPSBUYXA7XG5cdFx0TWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuXHRcdE9iamVjdC5mcmVlemUgPSBmcmVlemU7XG5cblx0XHRleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXHRcdGV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2w7XG5cdFx0ZXhwb3J0cy5jb250cm9sID0gY29udHJvbDtcblx0XHRleHBvcnRzLkJyb3dzZXIgPSBCcm93c2VyO1xuXHRcdGV4cG9ydHMuRXZlbnRlZCA9IEV2ZW50ZWQ7XG5cdFx0ZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuXHRcdGV4cG9ydHMuVXRpbCA9IFV0aWw7XG5cdFx0ZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xuXHRcdGV4cG9ydHMuSGFuZGxlciA9IEhhbmRsZXI7XG5cdFx0ZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZXhwb3J0cy5iaW5kID0gYmluZDtcblx0XHRleHBvcnRzLnN0YW1wID0gc3RhbXA7XG5cdFx0ZXhwb3J0cy5zZXRPcHRpb25zID0gc2V0T3B0aW9ucztcblx0XHRleHBvcnRzLkRvbUV2ZW50ID0gRG9tRXZlbnQ7XG5cdFx0ZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcblx0XHRleHBvcnRzLlBvc0FuaW1hdGlvbiA9IFBvc0FuaW1hdGlvbjtcblx0XHRleHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcblx0XHRleHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG5cdFx0ZXhwb3J0cy5Qb2x5VXRpbCA9IFBvbHlVdGlsO1xuXHRcdGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcblx0XHRleHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcblx0XHRleHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcblx0XHRleHBvcnRzLmJvdW5kcyA9IHRvQm91bmRzO1xuXHRcdGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcblx0XHRleHBvcnRzLnRyYW5zZm9ybWF0aW9uID0gdG9UcmFuc2Zvcm1hdGlvbjtcblx0XHRleHBvcnRzLlByb2plY3Rpb24gPSBpbmRleDtcblx0XHRleHBvcnRzLkxhdExuZyA9IExhdExuZztcblx0XHRleHBvcnRzLmxhdExuZyA9IHRvTGF0TG5nO1xuXHRcdGV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuXHRcdGV4cG9ydHMubGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHM7XG5cdFx0ZXhwb3J0cy5DUlMgPSBDUlM7XG5cdFx0ZXhwb3J0cy5HZW9KU09OID0gR2VvSlNPTjtcblx0XHRleHBvcnRzLmdlb0pTT04gPSBnZW9KU09OO1xuXHRcdGV4cG9ydHMuZ2VvSnNvbiA9IGdlb0pzb247XG5cdFx0ZXhwb3J0cy5MYXllciA9IExheWVyO1xuXHRcdGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG5cdFx0ZXhwb3J0cy5sYXllckdyb3VwID0gbGF5ZXJHcm91cDtcblx0XHRleHBvcnRzLkZlYXR1cmVHcm91cCA9IEZlYXR1cmVHcm91cDtcblx0XHRleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcblx0XHRleHBvcnRzLkltYWdlT3ZlcmxheSA9IEltYWdlT3ZlcmxheTtcblx0XHRleHBvcnRzLmltYWdlT3ZlcmxheSA9IGltYWdlT3ZlcmxheTtcblx0XHRleHBvcnRzLlZpZGVvT3ZlcmxheSA9IFZpZGVvT3ZlcmxheTtcblx0XHRleHBvcnRzLnZpZGVvT3ZlcmxheSA9IHZpZGVvT3ZlcmxheTtcblx0XHRleHBvcnRzLkRpdk92ZXJsYXkgPSBEaXZPdmVybGF5O1xuXHRcdGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcblx0XHRleHBvcnRzLnBvcHVwID0gcG9wdXA7XG5cdFx0ZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcblx0XHRleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuXHRcdGV4cG9ydHMuSWNvbiA9IEljb247XG5cdFx0ZXhwb3J0cy5pY29uID0gaWNvbjtcblx0XHRleHBvcnRzLkRpdkljb24gPSBEaXZJY29uO1xuXHRcdGV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG5cdFx0ZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG5cdFx0ZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG5cdFx0ZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG5cdFx0ZXhwb3J0cy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXI7XG5cdFx0ZXhwb3J0cy5HcmlkTGF5ZXIgPSBHcmlkTGF5ZXI7XG5cdFx0ZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG5cdFx0ZXhwb3J0cy5TVkcgPSBTVkc7XG5cdFx0ZXhwb3J0cy5zdmcgPSBzdmckMTtcblx0XHRleHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5cdFx0ZXhwb3J0cy5DYW52YXMgPSBDYW52YXM7XG5cdFx0ZXhwb3J0cy5jYW52YXMgPSBjYW52YXMkMTtcblx0XHRleHBvcnRzLlBhdGggPSBQYXRoO1xuXHRcdGV4cG9ydHMuQ2lyY2xlTWFya2VyID0gQ2lyY2xlTWFya2VyO1xuXHRcdGV4cG9ydHMuY2lyY2xlTWFya2VyID0gY2lyY2xlTWFya2VyO1xuXHRcdGV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuXHRcdGV4cG9ydHMuY2lyY2xlID0gY2lyY2xlO1xuXHRcdGV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcblx0XHRleHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG5cdFx0ZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcblx0XHRleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuXHRcdGV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuXHRcdGV4cG9ydHMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuXHRcdGV4cG9ydHMuTWFwID0gTWFwO1xuXHRcdGV4cG9ydHMubWFwID0gY3JlYXRlTWFwO1xuXG5cdFx0dmFyIG9sZEwgPSB3aW5kb3cuTDtcblx0XHRleHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR3aW5kb3cuTCA9IG9sZEw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0Ly8gQWx3YXlzIGV4cG9ydCB1cyB0byB3aW5kb3cgZ2xvYmFsIChzZWUgIzIzNjQpXG5cdFx0d2luZG93LkwgPSBleHBvcnRzO1xuXHR9KTtcbn0pO1xuXG52YXIgTCQxID0gd2luZG93WydMJ107XG5cbnZhciBmYWN0b3J5ID0gZnVuY3Rpb24gZmFjdG9yeShzZWwsIG9wdGlvbnMpIHtcblx0dmFyIG1hcCA9IEwkMS5tYXAoc2VsKS5zZXRWaWV3KG9wdGlvbnMubG9jYXRpb25zLCAxMyk7XG5cblx0Ly9DcmVhdGUgYSB0aWxlIGxheWVyIHRoYXQgcG9pbnRzIHRvIHRoZSBBenVyZSBNYXBzIHRpbGVzLlxuXHRMJDEudGlsZUxheWVyKCdodHRwczovL2F0bGFzLm1pY3Jvc29mdC5jb20vbWFwL2ltYWdlcnkvcG5nP3N1YnNjcmlwdGlvbi1rZXk9e3N1YnNjcmlwdGlvbktleX0mYXBpLXZlcnNpb249MS4wJnN0eWxlPXNhdGVsbGl0ZSZ6b29tPXt6fSZ4PXt4fSZ5PXt5fScsIHtcblx0XHRhdHRyaWJ1dGlvbjogJ8KpICcgKyBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgKyAnIE1pY3Jvc29mdCwgwqkgMTk5MiAtICcgKyBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgKyAnIFRvbVRvbScsXG5cdFx0Ly8gLy8gbWF4Wm9vbTogMjAsXG5cdFx0Ly8gY3Jvc3NPcmlnaW46IHRydWUsXG5cdFx0c3Vic2NyaXB0aW9uS2V5OiAnekRfZnAweEpLQ05nMmZiTWZlRkRXY3E3MXRuMFo2TzlQRXZUR3UwWUUxVSdcblx0fSkuYWRkVG8obWFwKTtcblxuXHRMJDEubWFya2VyKG9wdGlvbnMubG9jYXRpb25zLCB7IGljb246IEwkMS5pY29uKHtcblx0XHRcdGljb25Vcmw6ICcuLi9tYXJrZXIuc3ZnJyxcblx0XHRcdGljb25TaXplOiBbMzUsIDQ5XSxcblx0XHRcdGljb25BbmNob3I6IFsxNywgNDldLFxuXHRcdFx0cG9wdXBBbmNob3I6IFstMywgLTc2XVxuXHRcdH0pIH0pLmFkZFRvKG1hcCk7XG59O1xuXG4vL2h0dHBzOi8vYXRsYXMubWljcm9zb2Z0LmNvbS9tYXAvdGlsZS9wbmc/YXBpLXZlcnNpb249MS4wJmxheWVyPWJhc2ljJnN0eWxlPW1haW4mem9vbT17en0meD17eH0meT17eX0mc3Vic2NyaXB0aW9uLWtleT17c3Vic2NyaXB0aW9uS2V5fVxuLy9odHRwczovL2F0bGFzLm1pY3Jvc29mdC5jb20vbWFwL2ltYWdlcnkvcG5nP3N1YnNjcmlwdGlvbi1rZXk9e3N1YnNjcmlwdGlvbi1rZXl9JmFwaS12ZXJzaW9uPTEuMCZzdHlsZT1zYXRlbGxpdGUmem9vbT17em9vbX0meD17eH0meT17eX1cblxuLy90aGVyZSBhcmVuJ3Qgc2F0ZWxsaXRlIHRpbGVzIGF2YWlsYWJsZSBvbiBhenVyZSwgb25seSAnaW1hZ2VyeSB0aWxlJyB3aGljaCBpc1xuXG52YXIgaW5kZXggPSB7XG5cdGluaXQ6IGZ1bmN0aW9uIGluaXQoc2VsLCBvcHRzKSB7XG5cdFx0cmV0dXJuIGZhY3Rvcnkoc2VsLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0cykpO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpbmRleDs7XG59KSk7XG4iLCJpbXBvcnQgTWFwIGZyb20gJy4uLy4uL2Rpc3QnO1xuXG5jb25zdCBvbkRPTUNvbnRlbnRMb2FkZWRUYXNrcyA9ICgpID0+IHtcbiAgICBNYXAuaW5pdCgnanMtbWFwJywgeyBsb2NhdGlvbnM6IFs1MC43OTI5Njk0MTk5MjI3LCAtNC41NTc5MDk5NjU1MTUxNF19KTtcbn07XG4gICAgXG5pZignYWRkRXZlbnRMaXN0ZW5lcicgaW4gd2luZG93KSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG9uRE9NQ29udGVudExvYWRlZFRhc2tzKTsiXX0=
